Larger Text,Smaller Text,Symbol
Coding In Delphi ,NA,NA
Nick Hodges,©2012 - 2013 Nick Hodges,NA
Tweet This Book!,"Please help Nick Hodges by spreading the word about this book on
  Twitter
 !
  
 The suggested tweet for this book is: 
  
 I just bought ”Coding in Delphi” by Nick Hodges. Give it a look! 
 #codingindelphi The suggested hashtag for this book is
  #codingindelphi
 .
  
 Find out what other people are saying about the book by clicking on this link to search 
 for this hashtag on Twitter: 
  
 https://twitter.com/search?q=#codingindelphi",NA
Contents,"Foreword
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 i
  
 Introduction
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 iii
  
 Acknowledgements
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 v
  
 Frameworks used in Coding in Delphi
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
 vi
  
 Delphi Spring Framework 
  
 . . 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 vi
  
 DUnitX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 vi
  
 Delphi Mocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 vii
  
 DSharp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 vii
  
 1 Exceptions and Exception Handling
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 1
  
 1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 1
  
 1.2 Structured Exception Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 1
  
 1.3 How Not to Use Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 2
  
 1.4 How to Use Exceptions Properly . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 5
  
 1.5 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 10
  
 2 Using Interfaces
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 1
 1
  
 2.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 11
  
 2.2 Decoupling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 11
  
 2.3 What are Interfaces? 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 12
  
 2.4 Interfaces Everywhere 
  
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  
 12",NA
Foreword,"I first met Nick during a Delphi 1 pre-launch “boot-camp” that was held at the brand new 
 Borland campus in Scotts Valley, California. We had invited a cadre of developers, authors 
 and long-term luminaries to get some in-depth training and presentations directly from the 
 development team and product management. Enthusiastic and exuberant are adjectives 
 that don’t fully characterize my first impressions of him. He was never afraid of asking 
 questions and absorbed the information quickly.
  
 I cannot talk about Nick without also discussing TSmiley. Inquisitive and curious, Nick 
 embraced Delphi without reservation. To that end, Nick wasn’t satisfied with what Delphi 
 did, but was just as keen on learning about how it did it. To that end, Nick holds the honor 
 of producing one of, if not the first non-Borland built component. In order to learn about 
 Delphi component building, he built TSmiley. In this one simple component all the core 
 aspects of using Delphi’s Pascal language to extend and enhance the VCL framework were 
 demonstrated. You see, Delphi component building is all about the code.
  
 I had the pleasure of working closely with Nick during his time at Borland and then 
 Embarcadero. Nick held the position of Product Manager for a while then managed a 
 portion of the Delphi R&D team. Nick was never afraid to challenge assumptions and 
 actively stand up for the Delphi developer community. Even though Nick’s position didn’t 
 require him to write code, he didn’t let that stop him. He was always looking for ways to 
 keep his programming skills as sharp as possible. As new features were developed, Nick 
 was always right there to give them a workout. To this day there is a large amount of code 
 written by Nick that remains a key portion of the overall regression and unit-testing 
 process. Nick discovered that some of the best ways to learn about new code is to test that 
 new code. It is not without irony that this process requires code to be written.
  
 It stands to reason that Nick would end up here; writing a book with a single focus on the 
 code. That is the engine that drives all the other revolutionary features of Delphi. Without 
 the code, there would be no “Visual” in the Visual Component Library (VCL). In fact, Delphi 
 has always been about getting the developer to their code as quickly as possible. The VCL 
 and the newer FireMonkey component frameworks make the use and construction of UI, 
 database, connection and others as simple as possible. Its ultimate goal is to allow the 
 developer to focus on their task, which is to produce an application that solves a specific 
 problem. It is the code that is written in between those UI, database and connection 
 components that make up the application.
  
 Developers at all levels will be able to use the information contained within this book. It 
 doesn’t matter if you’re relatively new to Delphi or programming or you’ve got many years 
 of experience. If there is one common trait I’ve found among software developers, it is their 
 desire to learn. Learning a new technique or figuring out how to apply that technique to 
 one’s unique situation is part of the excitement of being a software developer. This is right 
 up there with the thrill experienced",NA
Introduction,"Over the years, I’ve spoken in front of a lot of Delphi developers. The one thing that I notice 
 is that there are a lot more of you Delphi guys than the average Delphi guy thinks. There are 
 Delphi folks everywhere. Also, I have noticed that a lot of Delphi developers are “behind”. 
 That is, they are either using an older version of Delphi, or they aren’t using or aren’t even 
 aware of all the features in the newer versions of Delphi that they are using. Something I 
 like to do when I’m in front of folks is ask a few questions about what people are doing. I’m 
 always saddened that the response to questions like “Who is doing unit testing?” or “Who is 
 taking advantage of Generics?” is pretty meager.
  
 This is particularly true for the language features and the run-time library. It’s quite easy to 
 move forward with an older code base, utilizing the new features in the IDE and adding 
 new things to your app using the new high level frameworks and components that come in 
 the newer versions. For example, you might have been developing an application since 
 Delphi 3, moving forward through various versions. Along the way, you may have added 
 some DataSnap functionality, started using the Code Insight features in the IDE, and when 
 you moved to XE2, you start poking around with FireMonkey.
  
 But it’s fairly easy to ignore the new language features that come along with those new 
 versions. For instance, two powerful language features were added in Delphi 2009: 
 generics and anonymous methods. Both are features that enable the development of really 
 cool code and frameworks. But if you didn’t understand or feel the need for them, then it 
 was pretty easy to simply not use them. You can still do all kinds of great stuff in Delphi 
 without them, but with them, well, you can write some really beautiful, testable, and 
 amazing code.
  
 For instance, a relatively new framework that exists only because of these new language 
 features is the Spring Framework for Delphi, or Spring4D, as I’ll refer to it in this book. 
 Spring4D is a feature rich framework that provides a number of interesting services, 
 including a wide variety of collections that leverage generics, an Inversion of Control 
 container, encryption support, and much more. I view Spring4Dsolid as much a part of the 
 Delphi RTL as
  SysUtil
 s is. Using Spring4D in your code will make many, many things easier 
 and cleaner. But many Delphi developers don’t know this yet.
  
 If the above is familiar, this book is for you: The Delphi developer that hasn’t quite yet 
 made the leap over into the cool and amazing things that you can do with the latest 
 versions of the Delphi language. This book is all about introducing these new language 
 features and some of the intriguing things you can do with them. It will take a look at these 
 new language features, and then expand into some of the open source frameworks that 
 have sprung up (no pun intended) as a result. It will then show you techniques that you can 
 use to write
  SOLID¹
 , clean, testable code.",NA
Acknowledgements,"Writing a book like this is a lot of work. But it can’t all be done by the author. I had a lot of 
 help.
  
 First I want to thank everyone in my Google Plus group that proofread the early drafts. I’m 
 very grateful. I’d like to particularly thank the following people who really went above and 
 beyond in their help.
  
 These three gentlemen made great comments and suggestions in the Google Plus group.
  
 • Stefan Glienke
  
 • Kenneth Cocheran
  
 • Bruno Sonnino
  
 • Andrea Raimondi
  
 Bill Meyer read the first finished draft from cover to cover, finding countless typos and 
 providing excellent feedback. I’m grateful.
  
 I need to give a special level of thanks to Jeroen Pluimers who really went above and 
 beyond in helping with this book. He read and re-read it numerous times. He contributed 
 coding samples and managed much of the code repository for the book. I am very grateful 
 to him for all of his superb help. I probably should have put his name on the cover.
  
 I’d like to thank Allen Bauer for writing the Forward and for answering some particularly 
 sticky questions that only he can answer. Allen has been a good friend over the years and 
 I’m grateful to know such a smart, nice guy.
  
 Diane Moser proofread this book and made countless corrections and improvements. I’m 
 grateful.
  
 My daughter Piper designed the cover using an idea my wife had. I’m very proud of her 
 design skills.
  
 It almost goes without saying, but I’d like to thank my family. Writing a book is a lot of 
 work, and they put up with me being distracted and on the computer more than I should 
 have been. I’d particularly like to thank my daughter Timber who I think missed her Papa a 
 lot.",NA
Frameworks used in Coding in Delphi,"This book is about writing code in Delphi. As a result, it uses a number of open source 
 frameworks to facilitate the coding techniques that are discussed herein. I refer to them 
 here at the beginning of the book to enable you to retrieve the code and get them set up 
 before we begin.
  
 All of the frameworks below are available via source control. I recommend that you pull or 
 clone the source code in accordance with the instructions in the source repository. This 
 way you can very easily keep up with the latest changes and fixes. If you have questions 
 about how to setup and use Subversion, Git, or Mercurial, please see Appendix A.",NA
Delphi Spring Framework,"The Delphi Spring Framework is a large collection of libraries, including data structure 
 collections, a dependency injection container, encryption, and other features. In this book 
 we’ll be closely examining the collections and dependency injection features.
  
 Homepage
 :
  http://www.spring4d.org/⁴
  
 Source Location
 :
  
 https://bitbucket.org/sglienke/spring4d⁵
 Repositor
 y Type
 : Git 
  
 License
 :
  Apache License V2.0⁶",NA
DUnitX,"DUnitX is an xUnit testing framework for Delphi 2010 and greater. It uses attributes to 
 define tests and test fixtures.
  
 Source Location
 :
  
 https://github.com/VSoftTechnologies/DUnitX⁷
 Repository 
 Type
 : Git 
  
 License
 :
  Apache License V2.0⁸
  
 ⁴
 http://www.spring4d.org/
  
 ⁵
 https://bitbucket.org/sglienke/spring4d
  
 ⁶
 http://www.apache.org/licenses/LICENSE
 -2.0
  
 ⁷
 https://github.com/VSoftTechnologies/DU",NA
Delphi Mocks,"Delphi Mocks is a complete isolation framework for Delphi XE2 and up. It enables the 
 creation of stubs and mocks for use in unit testing frameworks.
  
 Source Location
 :
  https://github.com/VSoftTechnologies/Delphi-
 Mocks⁹
 Repository Type
 : Git 
  
 License
 :
  Apache License V2.0¹⁰",NA
DSharp,"DSharp is a multi-featured set of libraries for Delphi, including mocking (for Delphi 2010 
 and up), data-binding, a Dependency Injection container, an MVVM framework, Aspect 
 oriented programming, and more.
  
 Source Location
 :
  
 https://bitbucket.org/sglienke/dsharp¹¹
 Repository 
 Type
 : Subversion 
  
 License
 :
  New BSD License¹²
  
 ⁹
 https://github.com/VSoftTechnologies/Delphi-
 Mocks
  
 ¹⁰
 http://www.apache.org/licenses/LICENSE-2.0
  
 ¹¹
 https://bitbucket.org/sglienke/dsharp
  
 ¹²
 http://opensource.org/licenses/BSD-3-Clause",NA
1 Exceptions and Exception Handling,NA,NA
1.1 Introduction,"Added into Delphi back at the very beginning with Delphi 1, exception handling was a 
 fundamental change to the way we thought about and wrote our code. Unfortunately, 
 despite almost twenty years of use, there are still many misconceptions and 
 misunderstandings about how exceptions work and especially about how they should be 
 used.
  
 In this chapter, I’ll look at how exception handling should be done. I’ll start out with 
 examples of the wrong way to use and handle exceptions. Using that as a base, I’ll then 
 discuss proper ways for using exception handling. Used improperly, exception handling can 
 actually cause more problems and errors than it prevents. Used correctly, they can aid you 
 in writing clean, well-designed code that is easy to maintain. I’ll assume that you are 
 familiar with exception handling syntax, and the basics of how exceptions work.",NA
1.2 Structured Exception Handling,"An exception is a language feature that allows a programmer to stop execution of a process 
 or thread immediately, but intercept that “stop” at any point in the call stack when 
 necessary. Structured exception handling is a combination of language features and good 
 design that makes use of exceptions in order to allow programmers to make useful 
 assumptions when writing code and, most critically, respond correctly when those 
 assumptions turn out not to be true.
  
 These assumptions are often called preconditions – they are things which must be true for 
 a method to succeed. For example, a method that deletes a record from a database might 
 have the precondition that the user is logged into the database before it is run. Because the 
 program’s user interface is structured to only run the method after logging in, a 
 programmer might assume that this precondition will always be true. But what happens 
 when the database server crashes?
  
 The programmer could address this by checking to ensure that the server is connected at 
 the start of every method. But this is by no means the only precondition, and may lead to 
 duplication of code. Or the programmer might forget to include all of the relevant checks 
 when writing a new method.
  
 Structured exception handling provides an elegant solution to all of these issues. It ensures 
 that a method will fail if the preconditions are not fulfilled, and furthermore that it fails in 
 such a way that the developer can recognize and respond to the failure.",NA
1.3 How Not to Use Exceptions,"Much of the work I do involves working on existing projects that have been struggling – 
 most often because of poor design – and rewriting code that wasn’t well done in the first 
 place. One of the most common coding errors I see is the misuse of exceptions – sometimes 
 really ugly misuse. To start off, I’ll go through a few “Don’ts” for exception handling use, 
 discussing why each is not a good technique.",NA
Don’t Eat Exceptions,"Probably the most common — and really egregious – misuse of exceptions is the “eating” of 
 exceptions. Very often I’ll see code like this;
  
 try
  
 SomeRoutineThatSometimesCausesAHardToFindAccessViolation
  
 except
  
 end
 ;
  
 For the Love of Baby Elvis, please do not do this. As you can see, this code will “eat”
  any
  
 exception that gets raised in the called routine. Very often, the code in the try block raises 
 an error that isn’t easily found, and rather than do the hard work of actually tracking down 
 the error, the programmer will take the easy way out and just eat the exception. 
 Sometimes, the reason for eating the exception is nothing more than the desire to never let 
 the end user see any error messages. If that is your goal, however, you should do so in such 
 a way that you don’t conceal the errors from the rest of your code, as well.
  
 Rest assured, the user will see no error messages as a result of this code. Every single 
 exception that could possibly arise from this code will be suppressed – database 
 exceptions, out of memory exceptions, hardware failures, anything. This means that your 
 program may return incorrect results while appearing to succeed. It is better to clearly 
 indicate failure than to silently make an error that could result in an incorrect paycheck or 
 worse!
  
 The only time I can think of when simply eating an exception is acceptable is when you 
 need to prevent an exception from propagating across module boundaries. If you are doing 
 inter-module programming, for instance, code that will run in a DLL, you shouldn’t let any 
 exceptions escape from the current module. In this case, using an empty exception handler 
 on the outer boundary of a DLL can do that for you. But unless such is the case, eating 
 exception handlers like this should be considered a gross error and a coding horror. Even 
 in this situation, you should somehow log the exception, or acknowledge it in some way. 
 Eating exceptions means that the information about the error – which could make fixing it 
 easy – is gone for good. Your customer may never realize there is a problem, and even if",NA
Don’t Generically Trap Exceptions,"Sometimes I see code that looks like this:
  
 try
  
 SomeCodeThatMightCauseAProblem
  
 except
  
 on
  E
 :
  Exception
  do
  
 begin
  
 MessageDlg(E
 .
 Message
 ,
  mtWarning
 ,
  [mbOK]
 , 0
 )
 ;
  
 end
 ;
  
 end
 ;
  
 And I think “That’s sort of like drinking Caffeine-Free Diet Coke” – in other words, why 
 bother? This code doesn’t do anything other than report an exception that will likely be 
 reported anyway. Actually, it does one other thing, and that is to stop the exception in its 
 tracks. The exception will be handled locally, and will never be allowed to escape the 
 current scope, In addition, it will trap all exceptions, including ones that you may very well 
 not want trapped.
  
 The only time that you might even consider using this construct – which is only slightly 
 better than eating the exception altogether – is when you know that the calling routine 
 doesn’t want to handle any exceptions or when the calling routine expects to handle the 
 specific exception. For instance, the
  TClientDataset
  has an
  OnReconcileError
  event that actually 
 passes an exception into it. If you were doing some batch processing with a Clientdataset, 
 then allowing this exception to bubble up the stack will stop the loop. In this case, you 
 might want to generically trap all the exceptions that are passed into the event handler.",NA
Don’t Go Looking For Exceptions,"Exceptions are fairly expensive in terms of processing power to create and handle, and so 
 you shouldn’t be creating them as a matter of course. In addition, you shouldn’t be creating 
 them on purpose or using them for the purpose of error checking, per se.
  
 For instance, you might be tempting to do something like this admittedly contrived 
 example:",NA
Don’t Use the Exception Handling System as a Generic Signaling ,NA,NA
System,"type 
  
 TNormalBehaviorException
  =
  class
 (Exception)
 ;
  
 ...
  
 begin 
  
 SomeCodeThatDoesNormalThingsAndDoesntHaveAnyErrors
 ; 
  
 raise
  TNormalBehaviorException
 .
 Create(
 'Something perfectly normal'
  + 
  
 'and expected 
 happened’); end;
  
 You might be tempted to write the above code as a means of signaling the calling code 
 about some type of information, especially if your custom exception handler has additional 
 information in it that can be ‘signaled’ back to the calling routine. Remember that 
 exceptions are a flow control mechanism as well as a tool for conveying information. 
 Raising exceptions when you simply want to send a message can have unexpected 
 consequences for program flow.",NA
1.4 How to Use Exceptions Properly,"Now that you’ve seen some of the ways not to use exceptions, here are some tips for 
 properly using Delphi’s exception handling system.",NA
Use Exceptions to Allow Your Code to Flow Without the ,NA,NA
Interruption of Error Handling Code,"One of the main purposes of exception handling is to allow you to remove error-checking 
 code altogether and to separate error handling code from the main logic of your 
 application. With exception handling, you can write your code as if nothing ever goes 
 wrong, and then wrap that code up with
  try...except
  blocks to deal with any of the errors and 
 problems that may occur. This enables your code to run more efficiently, as it isn’t 
 constantly checking parameters and other data to make sure that it is in the proper form 
 before doing anything with it.
  
 One way to separate code and exceptions is to handle exceptions centrally.
  TApplication
  has 
 an event that allows you to do just that – the
  OnException
  event. You can use this event to 
 deal with all exceptions of any type that aren’t otherwise handled by your application. You 
 can use this event to log your exceptions, or provide specific handling for specific types of 
 exceptions.",NA
Application Writers Should Trap Exceptions,"As will be discussed below, components and library code should be the main source of 
 exceptions; that is, components and library code should be the place where most 
 exceptions are created and raised. When writing applications, there is little need for you to 
 create and raise exceptions. Application writers should mainly be about the business of 
 handling exceptions that are raised by components and library code.",NA
Trap only specific exceptions,NA,NA
Component Writers and Library Code Writers Raise Exceptions,"Exceptions do not mysteriously appear. The vast majority of them are created and raised 
 within framework code. (Some can actually occur outside the purview of Delphi code.) And 
 it is perfectly acceptable for you to raise your own exceptions as well.
  
 As a general rule, you should raise specific exceptions in your library code and in your 
 components. That way, application writers can trap those specific exceptions in their code 
 as discussed above.
  
 You should write library code and component methods in such a way that they do one of 
 two things: they either execute successfully and return, or they raise an exception. 
 Application writers should assume the same thing – that a routine that is called will either 
 return successfully (with a valid result if the routine is a function) or that it will raise an 
 exception.",NA
Raise Your Own Custom Exceptions,NA,NA
Let Your Users See Exception Messages,"If you are tempted to hide all errors from the tender eyes of your users, ask yourself this 
 question: Which is worse, having your users see error messages, or having the application 
 roll along as if nothing has gone wrong, possibly leaving a trail of bad calculations and 
 corrupt data?
  
 Sadly, I’ve seen a lot of code that answers that question with the latter option rather than 
 the former. That’s how you end up with code that has empty exception handlers and eats 
 any and all exceptions.
  
 Exceptions occur because something is wrong. Ignoring them can have unexpected results. 
 Eating an
  EOutOfMemory
  exception can have disastrous results, because your application – 
 and your users– will continue on as if nothing bad has happened, when in fact bad things 
 have happened.
  
 Users are fearful of dialog boxes, as many user interface experts have noted, but if your 
 dialog box actually gives them something to do, then the dialog boxes may be more useful 
 than they normally are.",NA
Feel Free To Provide Good Exception Messages,"You don’t have to be terse and uninformative with your errors. When you raise an 
 exception, feel free to make the message passed up the stack as informative as you like:
  
 No need to do this:
  
 type
  
 ESomeException
  =
  class
 (Exception)
 ;
  
 procedure
  CauseAnException
 ;
  
 begin
  
 raise
  ESomeException
 .
 Create(
 'Boring message'
 )
 ;",NA
Provide Two Versions Of A Library Routine,"Sometimes people don’t like routines that return exceptions. Well, okay, why not 
 accommodate them? The RTL does this – it sometimes provides two functions that do the 
 same thing, with one raising an exception on failure and the other returning nil or some 
 error value, depending on the result. The
  FindClass/GetClass
  pair comes to mind.
  FindClass",NA
1.5 Conclusion,"It’s quite easy to fall into the trap of using exception handling improperly. The ability to 
 make errors and problems ‘disappear’ is quite tempting. However, misunderstanding and 
 misusing exceptions in your code can lead to some real problems, including untraceable 
 crashes and data loss. The proper use of exceptions can make your code easier to read an 
 maintain. Use exceptions wisely, and you’ll be able to product robust, clean code.",NA
2 Using Interfaces,NA,NA
2.1 Introduction,"Just about everything that I write about in this book will be predicated on the use of 
 interfaces. If you aren’t using interfaces for just about everything you do, you need to start. I 
 once tweeted
  
 “
 If I could teach a new programmer one thing it would be this: Program to an interface, not an 
 implementation.
 ¹
 ”
  
  
 Program to an interface, not an implementation
  
 When you use interfaces, you can decouple yourself from any particular implementation. 
 When one module of code isn’t directly connected to another module of code, that code is 
 said to be “loosely coupled”. And as I will probably repeat countless times throughout this 
 book, loosely coupled code is a very good thing.",NA
2.2 Decoupling,"All through this book, I’ll talk a lot about decoupling your code and why that is really good. 
 But a definition here is probably a good idea. Code can be said to be decoupled when your 
 classes are designed in such a way that they don’t depend on the concrete implementations 
 of other classes. Two classes are loosely coupled when they know as little about each other 
 as possible, the dependencies between them are as thin as possible, and the communication 
 lines between them are as simple as possible.
  
 In other words, decoupling is the process of limiting your dependencies to abstractions as 
 much as possible. If you want to write good, clean code, you will try to couple only to 
 abstractions; interfaces are abstractions. Much of what will be discussed in this book will 
 be about using interfaces to code against abstractions. As I tweeted above, this is critical to 
 writing good code that is easy to maintain.
  
 ¹
 https://twitter.com/NickHodges/statuses/122114771318345728?tw_i=122114771318345728&tw_e=permalink&tw_p=archive",NA
2.3 What are Interfaces?,"Interfaces are kind of hard to describe, but I’ll have to try anyway, eh?
  
 The dictionary describes an interface as:
  
 Interface – n. : A point where two systems, subjects, organizations, etc., meet 
 and interact.
  
 In the general case of code, an interface is the means by which code modules – usually 
 classes– interact with each other to perform specified actions. Your code needs to do 
 something, and interfaces are the definitions that allow code modules to work together.
  
 That’s the general definition – but Delphi has a reserved word
  interface
  which has a specific 
 syntactical meaning and which provides a specific functionality. So what are interfaces in 
 Delphi?
  
 Interfaces are an abstract definition of functionality.
  
 Okay, that sounds all intellectual, doesn’t it, but it’s true.
  
 An interface declaration defines a set of properties and methods that you can use for a 
 specific purpose. Interfaces declare and require no specific implementation for that 
 purpose. They define what a class can do and limit the exposure of a class to only those 
 things defined by the interface.
  
 Of course, an interface must be implemented to be useful. And when you use an interface, 
 you ultimately don’t care about
  how
  it is implemented; you just know that you can call the 
 methods and properties on the interface and the functionality you need will be provided. 
 Implementation hiding (i.e., abstraction) is one of the main purposes of using interfaces.",NA
2.4 Interfaces Everywhere,NA,NA
2.5 A Simple Example,"For example, here is a declaration of a very simple interface:
  
 type
  
 IName
  =
  interface
  
 [
 '{671FDA43-BD31-417C-9F9D-83BA5156D5AD}'
 ]
  
 function
  FirstName
 :
  string
 ;
  
 function
  LastName
 :
  string
 ;
  
 end
 ;
  
 Interfaces consist of a name (in this case,
  IName
 ) and a declaration of methods and 
 properties. By convention, Delphi interfaces start with the letter “
 I
 ,” but that is not 
 enforced. You can create interfaces with any name you want, but using the “
 I
 ” makes it 
 easier to identify an interface in your code. An interface includes no “real” code for 
 implementing functionality. An interface cannot declare fields, variables or constants. Nor 
 can they define scope such as private, protected, etc. It is purely a declaration of capability. 
 Thus, every member of an interface is essentially public.
  
 In the case above, the interface says “Hey, when I am implemented, I’ll give you information 
 about someone’s name.” It tells you what functionality is available. It does not tell you how 
 the functionality will be implemented. In fact, the interface doesn’t care, and the user of the 
 interface shouldn’t care either. The implementation of the interface might do any number 
 of things to get the name information – randomly pick from a list, grab it from a file, or pull 
 it from a database or some other data store. The interface itself doesn’t care and cannot 
 dictate where the name comes from. All the interface knows is that it’s implementer will 
 return a string – that’s it. It’s not even guaranteed that the string will be a person’s name, 
 though that is obviously the intent.
  
  
 Note that the declaration of the interface has a Globally Unique Identifier (GUID) 
 right after the initial declaration. This GUID is used by the compiler to identify this 
 interface. You can use an interface without the GUID, but much of the RTL and 
 most frameworks 
 that take advantage of interfaces will require a GUID be present. (You can generate 
 a GUID any time you want in the IDE by typing
  CTRL+SHIFT+G
 ) 
 Of course, the purpose here is to create an implementing class that has some meaning when 
 it goes into “Get me a person’s name” mode. For instance, you might have a form that 
 gathers the name from the user. You might be iterating over records in a database and use 
 the interface to grab each name as they are iterated. The point is that it doesn’t matter what 
 the implementing objects are or what they do – they just produce a name when treated as 
 an
  IName
  interface.",NA
2.6 Implementing an Interface,NA,NA
2.7 Some Further Things to Note:,"• An implementing class can have any number of other fields and methods that it needs 
 or requires, as long as it has the methods defined by the interface. If you fail to 
 provide all the necessary methods, the compiler will give you an error until you do. 
 But the class can be as complex as you need it to be (though generally you should 
 frown on complex classes, right?)
  
 • The base class can be any base class as long as it implements the necessary methods 
 for Delphi’s interface reference counting. (
 TInterfacedObject
  does this automatically for 
 you– more on
  TInterfacedObject
  and what reference counting is will be discussed 
 below.) But I want to stress again – the base class can be anything. It could be a class 
 you created. It could be a VCL class. It could be
  TButton
  or
  TClientDataset
  or anything. It 
 doesn’t matter, and the interface doesn’t care, as long as you provide 
 implementations for all the necessary methods.",NA
2.8 Interface Inheritance,"Interfaces can inherit from other interfaces, so you can declare an interface like so:
  
 IFullName
  =
  interface
 (IName)
  
 [
 '{07E8CFE2-4C2B-41F4-8934-D9D3B5BE39BC}'
 ]
  
 function
  FullName
 :
  string
 ;
  
 end
 ;
  
 In this way, the child interface will require an implementation for all its declared methods 
 as well as those of its parent. Any class that implements
  IFullName
  will have to provide 
 implementations for all of the methods in
  IFullName
  as well as
  IName
 .
  
 Note that an implementation of the child interface is not an explicit implementation of the 
 parent. An implementation must explicitly declare the interface that it wants to implement, 
 even if it declares all the required members. That is, unless a class explicitly lists a given 
 interface as part of its declaration, it cannot be used to implement that interface. Thus, you 
 need to list both parent and child interfaces in an implementing declaration if you want use 
 it as both the parent and child interface.
  
 Actually, the use of the phrase ‘interface inheritance’ is a bit misleading – it’s not really 
 true inheritance in that you can’t override a method from a parent interface, and there is 
 no polymorphic 
 behavior that results. ‘Interface augmentation’ might be a better way to phrase it.",NA
2.9 Other Things to Think About,"Here are a few things to think about when creating and dealing with interfaces:
  
 • As a general rule, you should declare interfaces in their own unit, preferably one 
 interface per unit. Interfaces should be defined separately from any implementation 
 or any other code. It’s very tempting to declare an interface and a class that 
 implements it in the same unit, but you should resist this temptation. Keep interfaces 
 separate and completely decoupled from any particular implementation.
  
 • It’s a good idea to have interfaces be specific and to the point. If you have a large 
 interface– one with many methods, you might consider breaking it down. This is 
 known 
 as 
 the 
 In-terface 
 Segregation 
 Principle 
 (http://en.wikipedia.org/wiki/Interface_segregation_principle) 
 –the 
 idea 
 that 
 interfaces shouldn’t have methods that the implementer doesn’t need. There are 
 times when it’s okay to have a larger interface, but don’t be afraid to have interfaces 
 with just a handful of – or even one – methods, and don’t be shy about having a class 
 implement more than one interface.
  
 • Interfaces can be used as abstractions for your code, but not all interfaces are 
 necessarily abstractions. If you have a “leaky” abstraction, then your interface isn’t 
 truly an abstraction. A leaky abstraction is one that allows implementation details to 
 sneak through, thus dictating a certain kind of implementation. Say you had an 
 interface called
  IDataSource
  and that interface had a method called
  GetConnectionString
 . 
 Having that method appears to strongly imply the notion of a database that requires a 
 connection string. An implementation of 
 IDataSource
  might use a collection or a list, 
 and so the notion of a connection string shouldn’t be part of the implementation. In 
 this case, the implementation detail of having a connection string has “leaked 
 through” your attempt at abstracting the notion of a data source. Along those lines, if 
 your interfaces are merely a reproduction of the public class you use to implement it, 
 then it is very likely that you have a leaky abstraction. In this case, you should go back 
 to the drawing board and refactor your code accordingly.",NA
2.10 About TInterfacedObject,"Okay, so there’s a bit more to it than what I’ve discussed so far. In Delphi, interface 
 references are reference counted. That is, the compiler keeps track of each reference to the 
 implementing object, increasing the count when a reference is added and decreasing the 
 count when a reference goes out of scope. The compiler automatically generates calls 
 (
 AddRef
  and
  Release
 ) that can be used to keep track of the number of times that an interface 
 has been referenced. As we’ll see, the “normal” way for interfaces to work is to use those 
 compiler-generated calls to keep a count of those references. When the interface’s 
 reference count goes down to zero, then the compiler automatically frees the instance that 
 is implementing that interface.",NA
2.11 How to Actually Use Interfaces,"Okay, so now you know about declaring and implementing interfaces. But how do you 
 actually 
 use
  them? It’s quite straight forward. You simply declare a variable of the interface 
 type you want to create, and then assign to it an instance of an object that implements that 
 interface. A simple example would look like this:
  
 var 
  
 NamedPerson
 :
  IName
 ;
  
 begin 
  
  
 NamedPerson
 :=
  TPerson
 .
 Create
 ; 
  
  
 WriteLn
 (NamedPerson
 .
 FirstName
 ,
  ' '
 ,
  NamedPerson
 .
 LastName
 ,
  ' is a person.'
 )
 ; 
 end
 ;
  
 Here are some things to note about the simple example above:
  
 • First,
  TPerson
  descends from
  TInterfacedObject
 , and therefore it meets the minimum re-
 quirements for implementing an interface – that is,
  _AddRef
 ,
  _Release
 , and
  QueryInterface
 .•",NA
2.12 Why Should You Be Using Interfaces?,"Okay, so you know what interfaces are and how to use them. Now I’ll say it: You should be 
 using interfaces. All the time. Well, pretty much all the time, anyway. For pretty much 
 everything. As much as possible. I said earlier that they are probably the single most 
 effective tool you have in your arsenal. That’s a pretty weighty statement, and I don’t use it 
 flippantly.
  
 The what and the how are the easy part. It’s not difficult to figure out how this all works. 
 It’s the 
 why
  that seems to be the sticking point for many – I know it was for me for a long 
 time. Why in the heck would you want to use these crazy things?
  
 Well here’s why.",NA
Coding Against Abstractions,"Interfaces allow you do something that is critical to writing good code: They allow you to 
 program to an abstraction. A pure abstraction, in fact. Why do you want to program to 
 abstractions and not implementations? The simple answer is this: an interface is the 
 smallest, thinnest, and least complicated thing you can couple your code to. As discussed 
 above, loosely coupled code is good.
  
 Now, if your code is completely decoupled, then it can’t do anything at all. Code has to be 
 coupled to
  something
  in order to provide any useful functionality, so “perfectly decoupled” 
 code is going a touch too far – what you really want is loosely coupled code. Very loosely 
 coupled code. You want the coupling of your code to be as loose as humanly possible. If you 
 never couple to anything but interfaces, then that is as loosely coupled as you can get.
  
 Ultimately, this is the bottom line reason why you should use interfaces in Delphi: They 
 provide a very thin – but very powerful – abstraction to your code. Much of the rest of this 
 book is really an expansion on that one simple but fundamental idea. Think of your code as 
 Lego blocks, with pins on one side and holes on the other side. With this loosely coupled 
 interface you can join any block to every other block and create anything you want. It 
 would be very limiting if the red blocks had a different hole size than the green blocks’ pins, 
 no?",NA
Pluggable Implementations,"If you program against abstractions, you can’t couple yourself to a specific implementation. 
 Interfaces allow you to make the coupling between your classes very loose. Classes should 
 be developed and tested in isolation with few or no external dependencies. But they almost 
 certainly have to depend on something. And certainly once you have a well-designed class 
 library created, you need to piece it together to create the system you need to build – just 
 like a child can build almost anything he or she wants out of Lego blocks. In the end, an 
 interface is the lightest and thinnest thing that a class can depend on. (I’ve likened coupling 
 to interfaces as “grasping at smoke”.) So, if you program primarily with interfaces, you can’t 
 help but create very loosely coupled code. And we all know that loosely coupled code is 
 good. So interfaces help produce good code.
  
 But there’s more – interfaces also let you alter implementations, even at runtime. Because 
 you are dealing with an interface, and not an implementation, you can very easily pick and 
 choose what implementation you want when you want. For instance, you can write code 
 like this:
  
 procedure
  EncryptSomething
 (aSuperSecretStuff
 :
 TBuffer
 ;
  const
  aIWantToBeSafe
 :
  B
 \
  
 oolean)
 ;
  
 var
  
 Encryptor
 :
  IEncrypt
 ;
  
 begin
  
 if
  aIWantToBeSafe
  then
  
 begin
  
 Encryptor
  :=
  TSuperDuperPowerfulEncryption
 .
 Create
 ;
  
 end else
  
 begin
  
 Encryptor
  :=
  TWhoCaresHowSafe
 .
 Create
 ;
  
 end
 ;
  
 Encryptor
 .
 Encrypt(aSuperSecretStuff)
 ;
  
 end
 ;
  
 This is a silly example, but you can see how this can be very useful – you can have a single 
 interface and select the proper implementation at runtime as needed. In fact, I’d say that if 
 you can’t choose your implementation at runtime, then your code is too tightly coupled.
  
 A more practical example might be an
  ICreditCardProcessor
  interface where you instantiate 
 different credit card implementations based on the choice made by your customer. Because 
 you aren’t tied to a specific implementation, you can use a single
  ICreditCard
  interface while",NA
Intermodule Communications,"But wait, there is more! Interfaces are good for inter-module communications. Say you 
 have a large system with different teams working on different major modules. Those teams 
 are responsible for providing functionality in their own modules, and thus they are 
 responsible for the integrity and quality of the code in their modules. Let’s say you are on 
 the Widget team, and you need the Sprocket team to do something for you. You go to the 
 Sprocket guys and say “Hey, I need to add a few things in the Sprocket code so that we can 
 do some Sprocket-type stuff in our Widget.” The Sprocket guys are going to laugh at you – 
 like they are going to let you poke around in their carefully crafted system!
  
 No, instead, they will likely ask you what you need, build the functionality, and hand you 
 some code with an interface and a factory for instantiating an implementation of that 
 interface. They aren’t going to let you anywhere near their code – but they are happy to let 
 you have an interface into that code. You get what you want – some Sprocket functionality – 
 and they don’t have to expose anything more than an interface to you.
  
 And later, if they completely re-architect their code, what do you care? Your interface still 
 works, even if they completely change the internal implementation. That’s a sound way to 
 develop, all made possible because of interfaces.",NA
Testable Code,"It doesn’t end there – interfaces make your code testable. As noted above, because you are 
 using interfaces you can readily substitute any implementation you want. What if you are 
 testing and you don’t want to connect to the production database? You can simply provide 
 a fake implementation for your database connection interface – one that only pretends to 
 be the database and that returns canned data – and now you can test your code in isolation 
 without actually connecting to a database. I’ll discuss this more in the chapter on unit 
 testing.
  
 ³
 https://twitter.com/NickHodges/status/146018445002145792",NA
Patterns,"Finally, interfaces make it easy to implement design patterns and do things like 
 Dependency Injection. Most of the new patterns and practices – including Dependency 
 Injection frameworks– are enabled because of the power and flexibility of interfaces. 
 Development patterns and architectures such as Model-View-Controller (MVC) and Model-
 View-ViewModel (MVVM) are much easier to implement and use when designed with 
 interfaces.
  
 If you choose not to embrace interfaces, then you are locking yourself out of new and 
 effective programming frameworks and techniques. I’ll be covering Dependency Injection 
 in depth in a later chapter, and you’ll see then that without interfaces, Dependency 
 Injection would not be as easy as it could be.
  
 Still not convinced? I’ll put it another way: all the cool kids are doing interfaces, and you 
 want to be part of the cool kid group, right?",NA
3 Understanding Generics,"Added to the language in Delphi 2009, Generics are a powerful language feature that allow 
 you to write type-safe classes, interfaces, arrays and even methods that act upon a “type to 
 be named later”. Sometimes you write code and you realize that you have to do a lot of 
 type-casting to coerce something to be a specific type. Or perhaps you are writing a lot of 
 subclasses to handle the specific case of a specific type, and you are writing a lot of 
 duplicate code. This is where Generics come in.
  
 A generic type is one that takes a type as a parameter, and allows you to use that type in 
 your code without knowing ahead of time what the exact type is. (It’s kind of hard to define 
 generics without using the word ‘type’ all the time…). You can tell your generic type to 
 accept any type, or you can use constraints, which will limit the types that can be passed to 
 ones with parameterless constructors, or types of a specific class or those that implement 
 specific interfaces.
  
 The term “Generics” is sort of a common term for this language feature. I prefer the more 
 formal“Parameterized Types” to describe them. Why? Well, because I think 
 parameterized types is more accurate and descriptive. You are ‘passing in’ the type to the 
 method just like you pass in regular parameters. The syntax is slightly different, but once 
 you realize that, “parameterized types” makes 
 more sense. However, most people call them generics, and so that is the term I’ll use 
 throughout the book. However, I won’t hesitate to point out how generics really are types 
 being passed as parameters. And besides, “generics” is easier to type. 
  
  
 Most of the examples in this chapter will focus on using generics with classes, but 
 you should note that generics work equally well with interfaces and records. 
 Let’s start off with a simple example. Consider the following code:",NA
3.1 Generics to the Rescue,NA,NA
3.2 Constraints,"One of the things that you may have noticed is that since the compiler doesn’t have a clue 
 about what the type of
  T
  is, you can’t do anything to
  T
  except keep track of it. You can’t 
 manipulate it or do anything to it. As noted above, if you pass in a class, you can’t call any of 
 it’s methods. That’s not any fun.
  
 That’s where the notion of constraints comes in. Constraints allow you to tell the compiler 
 “I want to use a generic type here, but I want to constrain (i.e. limit) it to be a specific 
 subset of types”. By doing that, you can then call methods on the type or use the type in a 
 known way because you’ve given the compiler enough information to figure out what you 
 are doing.
  
 The syntax for constraints is, as with most Pascal constructs, easy to understand. It consists 
 of a colon after the parameterized type, followed by the constraint name:",NA
constructor,NA,NA
 Constraint,"The
  constructor
  constraint requires that the parameterized type include a simple, parameter-
 less constructor called
  Create
 . This constraint will not usually be used standing alone, but 
 will most normally be used in conjunction with the
  class
  constraint as described below. 
 Thus, the following code will compile:
  
 uses 
  
 SysUtils
 ;
  
 type 
  
 TSomeClass
 <
 T
 :
  constructor
 > =
  class 
  
   
 function
  GetType
 :
  T
 ; 
  
 end
 ;
  
 function
  TSomeClass
 <
 T
 >.
 GetType
 :
  T
 ; 
  
 begin 
  
 Result
  :=
  T
 .
 Create
 ; 
  
 end
 ;
  
 Given the above declaration, you now can create:
  
 SomeClass
  :=
  TSomeClass
 <
 SomeObject
 >;
  
 but you can’t create
  
 SomeClass
  :=
  TSomeClass
 <
 integer
 >;
  
 because the
  integer
  type doesn’t have a constructor.",NA
class,NA,NA
 Constraint,"The
  class
  constraint ensures that the type passed is – you guessed it! – a class. The
  class
  
 constraint means that the parameterized type must be a class type – that is, a
  TObject
  or one 
 of it’s descendants. Here is, for instance, the declaration of the
  TObjectList<T>
  from the
  
 Generics.Collections.pas 
 unit:
  
  
 TObjectList
 <
 T
 :
  class
 > =
  class
 (TList
 <
 T
 >
 ) 
  
  
 private 
  
    
 FOwnsObjects
 :
  Boolean
 ; 
  
  
 protected 
  
    
 procedure
  Notify
 (
 const
  Value
 :
  T
 ;
  Action
 :
  TCollectionNotification)
 ;
  override
 ; 
  
 public 
  
    
 constructor
  Create
 (AOwnsObjects
 :
  Boolean
  =
  True
 )
 ;
  overload
 ; 
  
    
 constructor
  Create
 (
 const
  AComparer
 :
  IComparer
 <
 T
 >;
  AOwnsObjects
 :
  Boolean
  =
  Tru
 \ 
 e)
 ;
  overload
 ; 
  
    
 constructor
  Create
 (Collection
 :
  TEnumerable
 <
 T
 >;
  AOwnsObjects
 :
  Boolean
  =
  True
 )
 ;
 \ 
 overload
 ; 
  
    
 property
  OwnsObjects
 :
  Boolean
  read
  FOwnsObjects
  write
  FOwnsObjects
 ; 
  
  
 end
 ;
  
 This class specifically tracks and contains objects, so the class constraint ensures that the 
 parame-terized type accepted by
  TObjectList<T: class>
  is indeed a class type.
  
 It should be noted that the
  class
  constraint itself is not enough to ensure that you can 
 construct an instance of the class passed in. In fact, this code will
  not
  compile:
  
 type 
  
 TSomeClass
 <
 T
 :
  class
 > =
  class 
  
   
 function
  GetType
 :
  T
 ; 
  
 end
 ;
  
 function
  TSomeClass
 <
 T
 >.
 GetType
 :
  T
 ; 
  
 begin 
  
 Result
  :=
  T
 .
 Create
 ;
  // <---- Fails here 
  
 end
 ;
  
 It produces the following compiler error:
  
 [dcc32 Error] ConstructorConstraint.dpr(20): E2568 Can't create new instance without CONSTRUCTOR 
 constraint in type parameter declaration
  
 In order to be able to create an instance of the parameterized type, the
  constructor
  constraint 
 must be included as well. Thus, the following code will compile:",NA
record,NA,NA
 Constraint,"I’m betting you can guess what the
  record
  constraint does. Yes! It constrains your type to be 
 a record– or more specifically, a non-nullable value type.
  
 Thus, if you have code like the following:
  
 type 
  
 TMyRecord
  =
  record 
  
   
 SomeInt
 :
  Integer
 ; 
  
 end
 ;
  
 type 
  
 TSomeClass
 <
 T
 :
  record
 > =
  class 
  
 private 
  
   
 FType
 :
  T
 ; 
  
 public 
  
   
 constructor
  Create
 (aType
 :
  T)
 ; 
  
   
 function
  GetType
 :
  T
 ; 
  
 end
 ;",NA
interface,NA,NA
 Constraint,"You can limit your parameterized types to accept only instances that implement specific 
 interfaces. By declaring one or more interfaces (separated by commas) you declare that the 
 type you will pass in must implement all of those interfaces. The compiler will check to 
 make sure that your type meets the constraints. When such a constraint is met, your code 
 can then call any of the interface’s methods:
  
 type 
  
 IStoppable
  =
  interface 
  
   
 procedure
  Stop
 ; 
  
 end
 ;
  
 TWidget
 <
 T
 :
  IStoppable
 > =
  class 
  
  
 FProcess
 :
  T
 ; 
  
  
 procedure
  StopProcess
 ; 
  
 end
 ;
  
 { TWidget<T> }
  
 procedure
  TWidget
 <
 T
 >.
 StopProcess
 ; 
  
 begin 
  
 FProcess
 .
 Stop
 ; 
  
 end
 ;",NA
Passing Records as Parameterized Types,"One nice feature of parameterized types is the ability to pass records as unconstrained 
 types. Consider the following example:
  
 type 
  
 TFoo
 <
 T
 > =
  class 
  
   
 AnyType
 :
  T
 ; 
  
 end
 ;
  
 TSomeRecord
  =
  record 
  
  
 procedure
  Blech
 ; 
  
 end
 ;
  
 var 
  
  
 Foo
 :
  TFoo
 <
 TSomeRecord
 >;
  
 procedure
  TSomeRecord
 .
 Blech
 ; 
  
 begin 
  
 WriteLn
 (
 'Blech!'
 )
 ; 
  
 end
 ;
  
 begin 
  
  
 Foo
  :=
  TFoo
 <
 TSomeRecord
 >.
 Create
 ; 
  
  
 try 
  
  
  
 Foo
 .
 AnyType
 .
 Blech
 ; 
  
  
 finally 
  
  
  
 Foo
 .
 Free
 ; 
  
  
 end
 ; 
  
 end
 .
  
 Here you can see that the compiler is smart enough to recognize the type of the type 
 parameter and allow you to call it at run-time.",NA
3.3 Generic Interfaces,"So far we’ve only declared generic classes. However, Delphi also allows you to add 
 parameters to interface declarations:",NA
3.4 Generic Methods,"You can pass a parameterized type to the name of any method without declaring the class 
 itself as a generic class:
  
 type
  
 TWidgetMaker
  =
  class
  
 public
  
 function
  CreateWidget
 <
 T
 :
  TWidget
 >
 (aWidgetName
 :
  string
 )
 :
  T
 ;
  
 end
 ;
  
 ...
  
 MyWidget
  :=
  TWidgetMaker
 .
 CreateWidget
 <
 TSpecialWidget
 >
 (
 'SpecialWidget'
 )
 ;
  
 Once you do that, the type parameter is available for use inside the method and no where 
 else. There are some limitations to this:
  
 • Interfaces cannot have generic methods
  
 • Constructors, destructors, message methods and record operators cannot be generic 
 methods.
  
 • Properties cannot have generic methods for their getters and setters
  
 Otherwise, you may pass parameterized types as part of a single method call. An example of 
 this might be to pass an
  IComparer
  implementation to a method called
  Compare
  that will do 
 the work of comparing things, allowing you to be flexible in just how that comparison gets 
 done.",NA
3.5 Generic Collections,"Earlier I discussed a hypothetical
  TStack<T>
  which was useful because you didn’t ever have 
 to do anything with the parameterized type inside the stack. Collections like this are good, 
 straightforward examples of how generics can be useful. And because they are useful in this 
 way, it is no surprise that Delphi includes a set of such collections that act on any type.
  
 We’ll cover these collections in detail in a coming chapter, but I mention them here because 
 they 
 are a very common use of generics in the Delphi run-time library 
 These collections are found in the
  Generics.Collections.pas
  unit. In addition, Spring4D has an 
 even more extensive and powerful collections unit that we’ll cover as well.
  
 Generics.Collections
  contains the following generic classes for common use:
  
 •
  TList<T>
  
 •
  TThreadedList<T>
  
 •
  TQueue<T>
  
 •
  TStack<T>
  
 •
  TDictionary<TKey, TValue>
  
 •
  TObjectList<T>
  
 •
  TObjectStack<T>
  
 •
  TObjectDictionary<TKey, TValue>
  
 •
  TThreadedQueue<T>
  
 The Spring4D framework contains a unit named
  Spring.Collections.pas
  which includes a 
 similar set of collection classes, but which are more powerful in that they all follow the
  
 IEnumerable<T> 
 pattern. These classes will be covered more thoroughly in a coming chapter. 
 Because of that, I won’t discuss them much here, other than to point out that:
  
 • These collections provide type-safe containers for easy use
  
 • They provide a single class as a collection for any type, improving maintenance. One 
 class to fix is much better than multiple classes for multiple types.
  
 • These classes should replace the use of their non-generic counterparts (TList, TStack, 
 etc.). You don’t have to do this right away, but you should gradually replace your 
 existing use of the regular, non-generic collection classes and their descendants with 
 the new, generic-based ones.",NA
3.6 Thinking Generically,"So far we have looked at the “consuming” side of generics. Things like
  TList<T>
  are all very 
 useful classes, and our code is made much simpler, easier to maintain, and more type-safe 
 because of them. But using them merely makes us
  consumers
  of generics. If we want to 
 truly take advantage of generics, we need to become
  producers
  of generic classes. It’s a big 
 step to see the benefit of generic collections, but the truly big step is to start seeing 
 opportunities for the use of generics in your own code.",NA
"3.7 A Contrived, Simple Example","So in order to start thinking about generics with a producer’s mindset, consider the 
 following code:
  
 type
  
 TOrderItem
  =
  class
  
 ID
 :
  integer
 ;
  
 end
 ;
  
 TOrder
  =
  class
  
 ID
 :
  integer
 ;
  
 end
 ;
  
 TCustomer
  =
  class
  
 ID
 :
  TGUID
 ;
  
 end
 ;
  
 Now this code is very simple – a set of classes that might represent a basic order entry 
 system. But right away, something should occur to you. All three have something in 
 common – they are entities in your system. Down the road, you may want to act upon all 
 the entities in your system, so you might create a superclass like so:",NA
3.8 A Practical Example,"While you will see generics used throughout the rest of the book, a straight-forward 
 practical example is in order here. So often the simple example you see is
  TList<T>
  which is 
 useful, but almost too simple. Above, I encouraged you to “Think Generically”, and so here’s 
 an example of doing just that. It also has the added advantage of being useful.",NA
TEnum,"Enumerations are cool, and sometimes it is cool to get the string value for an enumeration. 
 But who wants the hassle of using the
  TypInfo.pas
  unit and trying to figure that all out. How 
 about, instead, we come up with a nice little record that wraps that all up for us while 
 illustrating how methods can take parameterized types just like classes can?
  
 Consider the following code:
  
 uses
  
 TypInfo
 ;
  
 type
  
 TEnum
  =
  record
  
 public
  
 class function
  AsString
 <
 T
 >
 (aEnum
 :
  T)
 :
  string
 ;
  static
 ;
  
 class function
  AsInteger
 <
 T
 >
 (aEnum
 :
  T)
 :
  Integer
 ;
  static
 ;
  
 end
 ;
  
 class function
  TEnum
 .
 AsString
 <
 T
 >
 (aEnum
 :
  T)
 :
  string
 ;
  
 begin
  
 Result
  :=
  GetEnumName(
 TypeInfo
 (T)
 ,
  AsInteger(aEnum))
 ;
  
 end
 ;",NA
Problems with Generics,"Generics are a powerful and useful tool, but there are a few issues with them in Delphi.
  
 First, they tend to drastically increase the amount of code that the compiler generates. 
 Every time you declare a generic type, the compiler creates a new and separate type.
  
 For instance, if you declare
  
 var
  
 FirstIntegerList
 :
  TList
 <
 integer
 >;
  
 SecondIntegerList
 :
  TList
 <
 string
 >;
  
 the compiler creates two separate types. One would wish that the same type could be used 
 internally, but currently such is not the case.
  
 The second area where Delphi’s generics may be a problem is that they don’t support 
 covariance and contravariance
  
 Covariance is the notion that a given type can be converted from a specific type to a more 
 general type. (Example: Corvettes can be substituted for Cars). That is, you can use a child 
 class in place of a parent class because the child class has everything that the parent class 
 has.
  
 Likewise, contravariance is the notion that the general type can be substituted for the 
 specific type. (Example, a car can replace a Corvette) Contravariance is a little trickier, and 
 normally not allowed in object-oriented systems, because a child class can have more 
 functionality than a parent class, and thus a parent class cannot be a perfect substitute for 
 the child class if the child instance uses that additional functionality.
  
 Delphi doesn’t support either contravariance or covariance with generic types. This means 
 that the following code won’t compile:",NA
3.9 Conclusion,NA,NA
3.10 An Interview with Generics,"Nick
 : Generics – thanks for being with us today.
  
 Generics
 : Yeah, whatever. Usually people aren’t too interested in talking to me. I pretty 
 much don’t care what goes on, so I’m usually really boring.
  
 Nick
 : Well, I’ll bet we can find something interesting to talk about. So, what’s your deal? 
 Why are you in the language?
  
 Generics
 : That’s just it – as I said, I don’t care what goes on around me. I’m a type that can 
 be anything. I really don’t care.
  
 Nick
 : So why is that good?
  
 Generics
 : Because I can provide functionality that doesn’t care what the type being acted 
 on is. You can design me to work with anything. Whatever. I don’t care.
  
 Nick
 : Well, don’t be so hard on yourself.
  
 Generics
 : Yeah, hey, well, when you have no purpose in and of yourself, it can be tough on 
 your self-esteem, you know?
  
 Nick
 : But you are such a great team player! Team you up with another type and you really 
 have something.
  
 Generics
 : That’s true enough. You instantiate me with a specific type, and I really come 
 alive!
  
 TList<T>
  looks about as boring as it gets, but
  TList<TButton>
 ? That’s something, I guess.",NA
4 Understanding ,NA,NA
Anonymous Methods,NA,NA
4.1 Introduction,"When I speak to Delphi developers about anonymous methods, many are at least aware of 
 their existence, but almost no one uses them. That’s too bad. Anonymous methods are a 
 powerful and flexible way to make your code pluggable, expandable, and adaptable. They 
 can cause you to look at your code from different perspectives. This chapter will introduce 
 you to the notion of anonymous methods and provide a few examples of their use. By the 
 end of this chapter, I hope that you are scheming of ways to integrate anonymous methods 
 into your code.",NA
4.2 Definition,"You’re probably not going to believe this, but an anonymous method is a method without – 
 yes –a name. It is a “chunk” of code that stands alone without being attached to any class or 
 even any specific named procedure. You can declare the code to stand alone, as a variable, 
 and even pass them around as parameters to other methods.
  
 Why are they anonymous? Well, it’s a bit strange, but they are anonymous so that you can 
 give them a name at the right time. They can be given a name when they are declared as 
 variables or parameters. And since they don’t have a name, they can’t be arbitrarily called 
 elsewhere. No one can come along and go “Oh, hey, there’s a method I can use” and start 
 altering the scope of a method by using it in places where it doesn’t belong. By being 
 anonymous, such methods are naturally limited in scope. And limiting scope is good.
  
 Here is an example of an excessively simple anonymous method:
  
 procedure
 (
 const
  aString
 :
  string
 )
  
 begin
  
 WriteLn
 (aString)
 ;
  
 end
  
 There are a few things to notice here:
  
 First, a quick word on syntax. Anonymous methods have syntax similar to regular methods, 
 but with two differences. The most obvious is that they don’t have a name. That’s not 
 surprising, given that they are called Anonymous Methods.",NA
4.3 Why?,"If you aren’t already familiar with anonymous methods, you are probably at this point 
 asking, “Why in the world would you ever want to do something like that – it just looks like 
 a more complicated way to do what I’m already doing?” That’s understandable – they are a 
 bit complex. But their use will, as I mentioned above, start you thinking about your code in 
 new, interesting and powerful ways.",NA
A Simple Example,"First, they can be used to define a method signature that your code can call, but that can be 
 defined later. This enables you to define a class that is open to additional functionality at 
 run-time by consumers of that class. Here’s an example.
  
 Let’s say you want to create a simple calculator. You might do it like this:",NA
Anonymous Methods as Variables,"Above we saw anonymous methods being passed as literals. You can also assign code to a 
 variable and then pass that variable around like any other. The
  RegisterMathCalculation
  might 
 be called like this:
  
 var 
  
 SubtractCalc
 :
  TIntegerFunction
 ; 
  
 begin 
  
 SubtractCalc
  :=
  function
 (x
 ,
  y
 :
  integer
 )
 :
  integer 
  
  
  
 begin 
  
   
  
  
 Result
  :=
  x
  -
  y
 ; 
  
   
 end
 )
 ; 
  
 RegisterMathCalculation(
 'Subtract'
 ,
  SubtractCalc)
 ; 
 end
 ;
  
 In this way, you can treat blocks of code like variables.",NA
4.4 Closures,"By now, you may be saying “Why should I use anonymous methods? I’ve been doing exactly 
 this with method pointers for years.”. Okay, fair enough. But anonymous methods provide a 
 powerful feature not supported by mere method pointers – closures.
  
 A closure is the notion that an anonymous method can capture or “close around” the state 
 of the method within which they are called. Anonymous methods can reference and thus 
 capture local variables outside of their specific scope but within the scope in which they are 
 called. In this way, they are similar to nested functions but are more flexible because they 
 can be called from outside the scope where they are defined. They will not just capture 
 local variables, but all variables seen in the current scope, including any variables declared 
 by the object where the anonymous method resides.
  
 Keeping with our arithmetic theme, here is a very simple demo of a closure occurring in a 
 method:",NA
4.5 Standard Declarations,NA,NA
4.6 A Practical Example,"One way in which anonymous methods are useful is by simplifying code for common coding 
 patterns.
  
 For instance, the following code pattern is probably familiar and common:
  
 begin 
  
 OldCursor
  :=
  GetCurrentCursor
 ; 
  
 try 
  
   
 Cursor
  :=
  crHourglass
 ; 
  
   
 // Do some lengthy process that makes you want to show the hourglass cursor 
 finally 
  
   
 Cursor
  :=
  OldCursor 
  
 end
 ; 
  
 end
 ;
  
 Well, this kind of construct is screaming out for an anonymous method:
  
 procedure
  ShowHourGlass
 (Proc
 :
  TProc)
 ; 
  
 var 
  
 OldCursor
 :
  TCursor
 ; 
  
 begin 
  
 OldCursor
  :=
  Screen
 .
 Cursor
 ; 
  
 Screen
 .
 Cursor
  :=
  crHourGlass
 ; 
  
 try 
  
   
 Proc
 ; 
  
 finally 
  
   
 Screen
 .
 Cursor
  :=
  OldCursor 
  
 end
 ; 
  
 end
 ;
  
 Then, you can call it like so:",NA
"4.7 Another, Cooler Example","The C# guys love to brag about their cool
  using
  feature. It’s sort of like a combination of 
 Delphi’s
  with
  and
  try...finally
  statements. It defines a particular scope which, when left, will 
 automatically dispose of the object in question. Delphi doesn’t have this specific language 
 construct, but by combining anonymous methods and generics, we can provide the same 
 functionality:
  
 Obj
  =
  class 
  
 class procedure
  Using
 <
 T
 :
  class
 >
 (O
 :
  T
 ;
  Proc
 :
  TProc
 <
 T
 >
 )
 ;
  static
 ; 
 end
 ;
  
 class procedure
  Obj
 .
 Using
 <
 T
 >
 (O
 :
  T
 ;
  Proc
 :
  TProc
 <
 T
 >
 )
 ; 
 begin 
  
 try 
  
   
 Proc(O)
 ; 
  
 finally 
  
   
 O
 .
 Free
 ; 
  
 end
 ; 
  
 end
 ;
  
 This is basically a (sorry) generic way of wrapping up
  try...finally
  blocks just like we did with 
 the cursor above. You can use it like so:",NA
Anonymous Methods are very flexible,"Since the very beginning, Delphi has had a strong event-driven model. Methods could be 
 declared with the
  of object
  syntax and then they could be assigned object methods to run 
 when called. A typical event declaration looks like this:
  
 type 
  
 TNotifyEvent
  =
  procedure
 (Sender
 :
  TObject
 )
  of object
 ;
  
 then, you could declare a method – and it had to be a method of an object – of type
  
 TNotifyEvent 
 and assign it to a variable of that type.
  
 property
  OnClick
 :
  TNotifyEvent
  read
  FOnClick
  write
  FOnClick
  
 Then, your code could call the variable when the event is fired:
  
 procedure
  DoOnClick
 ; 
  
 begin 
  
 if
  Assigned
 (FOnClick)
  then
  FOnClick(
 Self
 )
 ; 
 end
 ;
  
 Where do anonymous methods enter into things here? If you declare a variable as an 
 anonymous method, you can assign to that variable an anonymous method (of course), a 
 method reference, and even a regular old stand-alone procedure. This means that you can 
 declare your event types as anonymous methods, and then have great flexibility in what 
 kind of code you can assign to those methods.
  
 Consider the following code:
  
 ²
 http://blogs.embarcadero.com/abauer/2008/09/25/38870",NA
4.8 Anonymous methods in the RTL,The Run-time Library in Delphi XE has begun to take advantage of anonymous methods.,NA
TThread and Anonymous Methods,"Just as above, where the
  using
  construct provides a means of using a small, discreet type 
 that needs to perform a task within the local scope, you may have a small discreet chunk of 
 code that you want to run in a separate thread.
  
 First, there is the
  CreateAnonymousThread
  method:
  
 class
  function CreateAnonymousThread(const ThreadProc: TProc): TThread; static;
  
 that will create a thread from your anonymous method. The thread is created suspended, 
 so you can call start on it as you please. It is also created with
  FreeOnTerminate
  set to
  True
 , so 
 once you start the thread, you should “forget” about it and let it run. Again, this can be used 
 as a “fire and forget”thread for a discrete, small chunk of code that you want to run in a 
 separate thread.
  
 Next, if you need to ensure that your code needs to be synchronized with the rest of your 
 application (perhaps because it calls VCL code…..) then you can use this overloaded version 
 of
  Queue
 :
  
 class
  procedure Queue(AThread: TThread; AThreadProc: TThreadProcedure); overload;\
  
 static;
  
 to call code using
  TThread
 ’s synchronization logic with an anonymous method.",NA
4.9 Predicates,"What is a predicate you ask? Well, it’s simple. A predicate is a specific type of function that 
 takes a single parameter and returns a
  Boolean
  value. It is basically a reference to a method 
 (usually an anonymous method) that is tied to a type that it takes as a parameter and 
 returns either
  True
  or 
 False
 . That’s it. Told you it was simple.
  
 Okay, I guess there is more to it than that. Most commonly, a predicate will take the form of 
 an anonymous method. The Delphi RTL declares the following type:
  
 TPredicate
 <
 T
 > =
  reference
  to function
  (Arg1
 :
  T)
 :
  Boolean
 ;
  
 Thus, a predicate is a generic type that takes the parameterized type as a single argument 
 and returns a Boolean result. Just like I said.",NA
So What?,"By now you are probably asking “So what?” Well,
  TPredicate
  allows you to declare things like 
 this:
  
 var 
  
 IsLessThan10
 :
  TPredicate
 <
 integer
 >; 
  
 begin 
  
 IsLessThan10
  :=
  function
 (
 const
  aValue
 :
  integer
 )
 :
  Boolean 
  
  
 begin 
  
   
  
 Result
  :=
  aValue
  < 10; 
  
   
 end
 ;
  
 …
  
 end
 ;
  
 Now you have a nice compact, portable way to determine if a number is less than ten. You 
 can pass that around to methods and use it to determine if a number is greater or less than 
 ten.
  
 procedure
  CheckIsLessThan10
 ; 
  
 var 
  
 IsLessThan10
 :
  TPredicate
 <
 integer
 >; 
  
 i
 :
  integer
 ; 
  
 begin 
  
 IsLessThan10
  :=
  function
 (
 const
  aValue
 :
  integer
 )
 :
  Boolean",NA
4.10 Conclusion,"That’s a brief overview of anonymous methods. You’ll see them again along with generics in 
 some of the later chapters. This powerful feature enables a lot of cool new constructs and 
 interesting techniques. The Delphi Spring Framework will make use of them as will the new 
 DUnitX Unit Testing Framework.",NA
4.11 An Interview with Anonymous Methods,"Nick
 : Anonymous Methods, you are a hard guy to find!
  
 AM
 : Yes, I am. I like it that way.
  
 Nick
 : Well, I appreciate you taking the time to answer my questions, even if it is only 
 over IM. 
 AM
 : Yeah, no problem. You’ll never figure out who I am anyway.
  
 Nick
 : Indeed – so what is up with this whole “no name” thing anyway? How is anyone 
 supposed to call you?
  
 AM
 : Well, I don’t have a name for a reason. If I had a name you could call me anywhere! We 
 can’t have that! Because I don’t have a name, I can only be called in the exact places where 
 my type is asked for. This gives me a lot of power despite the limitation of not having a 
 name.
  
 Nick
 : Like what? What can you do that a named method can’t?
  
 AM
 : Well, for starters, I can be assigned to a variable. If you declare a variable of my type, 
 say 
 TFunc<T, TResult>
 , then you can pass me around just like any other variable. Watch:
  
 MyAdditionFunction
  :=
  function
 (a
 ,
  b
 :
  integer
 )
  begin
  Result
  :=
  a
  +
  b
 ;
  end
 ;
  
 Sweet, huh?
  
 Nick
 : That could be interesting.
  
 AM
 : Yeah, it sure is, particularly when you consider I also take advantage of Closures.
  
 Nick
 : Closures?
  
 AM
 : Yeah – wherever I am, I can “close” around all the variables that are in my scope, and 
 those variables go with me wherever you send me. That can be useful and powerful.
  
 Nick
 : Yeah, I can see that. What other advantages do you have because you are anonymous?
  
 AM
 : Well, you can pass me directly as a parameter. No kidding. Like this:",NA
5 Delphi Collections,NA,NA
5.1 Introduction,"Delphi developers should be very familiar with collections, though the term itself can be 
 misleading. We’ve all used some type of data structure to hold on to a bunch of similar 
 items, whether it be an array, a
  TList
 , or some other similar structure.
  
 However, with the advent of parameterized types as well as the
  for...in
  statement, the types 
 of collections and the things that those collections can do have improved dramatically. In 
 fact, the generics-based collections are so powerful and preferable, that we won’t even 
 discuss the non-parameterized collection types in Delphi. This chapter will cover the basics 
 of those collections and how you can use them to improve your code quality.
  
 The term “collection” is a bit overloaded. In the general sense, it is used to 
 describe any data structure that is meant to hold and maintain elements of a 
 given type or interface. Lists, stacks, queues, dictionaries and a bevy of other 
 more complex structures are all collectively called “collections.” However, with 
 Delphi “collection” is itself a specific type of container – that is, one which 
 contains items in no specific order. I will endeavor to be clear about my usage of 
 the word.
  
 In this chapter, we’ll discuss two sets of collections: those provided by Delphi out of the box 
 in the 
 Generics.Collections
  unit, as well as the collections that come with the Delphi Spring 
 Framework.",NA
5.2 General Notions about Collections,"There are many types of collections. Below is a table covering the most common types of 
 collections and how they differ:
  
 Collection Type
  
 Description/Discussion
  
 Collection 
 A Collection is a group of items in no particular order. In computer science 
 terms, 
 they are often referred to as a “bag”. You can’t insert items into a specific 
 location in a collection, only add or remove them. A collection can’t be sorted 
 because it has no 
 List 
 order. 
 A list is a group of items in a particular order. Items can be sorted and inserted 
 at any 
 index position in the list. Lists are array-like. Their elements are numbered 
 from zero and have a specific index which can be used to find each item.",NA
5.3 The Delphi-Provided Collections,"Delphi includes a unit called
  System.Generics.Collections
 . In it is a set of generic collections that 
 you can easily use in place of the traditional collections that you’ve used in the past. It 
 contains the following types:
  
 •
  TList<T>
  
 •
  TQueue<T>
  
 •
  TStack<T>
  
 •
  TDictionary<TKey, TValue>
  
 In addition, there are descendant classes that can manage the lifetime of the objects that 
 they contain:
  
 •
  TObjectList<T>
  
 •
  TObjectQueue<T>
  
 •
  TObjectStack<T>
  
 •
  TObjectDictionary<TKey, TValue>
  
 Further, there are two types that handle their items via threading:
  
 •
  TThreadList<T>
  
 •
  TThreadedQueue<T>
  
 All of these collections, with the exception of
  TThreadList
  and
  TThreadedQueue
  are able to be 
 used with Delphi’s
  for...in
  syntax. (The “why” and “how” of this will be discussed below.)",NA
TList<T>,"TList<T>
  is probably the most commonly used of all the collections. As noted above, it is a 
 collection that provides indexing, insertion, deletion, exchanging, searching, and sorting. 
 Because it is generic, it can keep track of literally any type that you want, while remaining 
 completely type safe. It probably will become the “workhorse” of your collections arsenal.
  
 Here is a simple example that shows the basics of what
  TList<T>
  can do:
  
 unit uListDemo;
  
 interface
  
 procedure DemoList;
  
 implementation
  
 uses 
  
  
  
 Generics.Collections 
  
 ;
  
 type 
  
 TIntegerList
  =
  TList
 <
 integer
 >
 ;
  
 procedure OutputList(aMessage:
  string
 ; aIntegerList: TIntegerList); 
 var 
  
 i:
  integer
 ; 
  
 begin 
  
   
 Write(aMessage,
  ', the list is: '
 ); 
  
   
 for i
  in
  aIntegerList
  do 
  
   
 begin 
  
    
 Write(i,
  ', '
 ); 
  
   
 end; 
  
   
 WriteLn; 
  
 end;
  
 procedure DemoList; 
  
 var 
  
 IntegerList: TIntegerList; 
  
 Temp:
  Integer
 ; 
  
 i:
  integer
 ;",NA
TStack<T>,NA,NA
5.4,NA,NA
 TQueue<T>,"TQueue<T>
  is similar to a stack, but instead of a LIFO process, it uses a FIFO process, “First 
 In, First Out”. I like to think of it as a tube where you put golf balls in one end and then let 
 them roll through to the other end. The first golf ball you put in is the first one that comes 
 out the other end, and the rest “wait their turn” to come out after the first ones.
  
 A common use for queues is to hold on to tasks that are yet to be done. A simple demo 
 might be to track maintenance requests at an apartment building. There might be any 
 number of requests that come in for things to be fixed, and to be fair, you want to fix them 
 in the order that they are received. Thus, a very simple system might look something like 
 this:",NA
"TDictionary<TKey, TValue>","TDictionary<TKey, TValue>
  is a powerful collection type. It is a container that stores key/value 
 pairs, such that you can retrieve a value by using its key to search for it. Its strength lies in 
 the fact that it is a generic type and that both the key and the value can be of any type at all. 
 For instance, you could have a dictionary that had a
  TLabel
  as the key and a
  TButton
  as the 
 value.
  
 For a simple example, we’ll create a
  TDictionary<string, double>
  that will track student’s grade 
 point averages (GPA). In it, we can add students with their GPAs, look those GPAs up, and 
 then change them.
  
 unit
  uDictionaryDemo
 ;
  
 interface
  
 uses 
  
  
  
 Generics
 .
 Collections 
  
  
 ;
  
 type
  
 TStudentGPADictionary
  =
  TDictionary
 <
 string
 ,
  double
 >;
  
 procedure
  ProcessStudents
 ;
  
 implementation
  
 uses 
  
  
  
 System
 .
 SysUtils 
  
  
 ;
  
  
 procedure
  ReportOnStudents
 (aStudents
 :
  TStudentGPADictionary)
 ; 
  
  
 var 
  
  
  
 Student
 :
  string
 ; 
  
  
 begin 
  
  
  
 for
  Student
  in
  aStudents
 .
 Keys
  do 
  
  
  
 begin 
  
  
   
 WriteLn
 (Student
 ,
  ' has a '
 ,
  Format
 (
 '%.2f'
 ,
  [aStudents[Student]])
 ,
  ' GPA.'
 \ 
 )
 ; 
  
  
  
 end
 ; 
  
  
 end
 ;",NA
Object Collections,"All of the collections above have descendants that allow you to manage objects (i.e.,
  
 TObjectList<T>
 , 
 TObjectStack<T>
 ,
  TObjectQueue<T>
 , and
  TObjectDictionary<TKey, TValue>
 . These 
 classes behave exactly like their parents, except they are specifically designed to contain 
 objects. You can, via the constructor or the
  OwnsObjects
  property, tell the container that it is 
 the owner of the contained classes – that is, when the
  OwnsObjects
  property is
  True
 , the",NA
5.5 Collections in the Delphi Spring Framework,"The
  Spring.Collections
  unit in the Delphi Spring Framework contains a similar set of 
 functionality as does
  Generics.Collections
 , but it is more powerful and flexible in a number of 
 significant ways.
  
 The collections classes in Spring4D are similar enough and perform basically the same as 
 the ones in the Delphi RTL that I won’t spend a lot of time covering the specifics. I will 
 however, highlight some of the differences and additional capabilities provided by 
 Spring4D.",NA
General Discussion,"The Collections in Spring4D are all accessible through the
  Spring.Collections
  unit. The various 
 collections themselves are implemented in other units, but you should never need to use 
 them. Why? Because
  Spring.Collections
  defines a set of interfaces that give you access to all the 
 functionality of the other units. All the collections in Spring4D are accessed via interfaces, 
 making them more flexible and easier to use than classes.
  
 Further, the collections can all be created by a factory class called
  TCollections
 , which is a 
 collection of
  class
  methods that return implementations of the various collections. This class 
 will provide instances for most of the collection types that you will need. If you do need to 
 create a collection with a specific constructor, you can add the specific implementing units 
 to your project and call them from that unit. However, you should always access the 
 Spring4D collections via their interfaces.
  
 For instance, if you want to create an
  IQueue<T>
 , all you need to do is the following:
  
 var
  
 MyQueue
 :
  IQueue
 <
 string
 >
  
 begin
  
 MyQueue
  :=
  TCollections
 .
 CreateQueue
 <
 string
 >;
  
 ...
  
 end
 ;
  
 Spring4D provides the following collection interfaces:
  
 Non-generic collections:
  
 •
  ICollection
  
 •
  IList
  
 •
  IDictionary
  
 •
  IStack",NA
Two Collection Types Not Yet Covered,"Spring4D has two collection types that aren’t found in the set of Delphi generic collection 
 types –
 ICollection<T>
  and
  ISet<T>
 .
  
 ICollection<T>
  is the most basic collection type there is – it merely contains items in no 
 particular order. I’ve seen this collection type called a “bag” or a “bucket” before. All you 
 can do is
  Add
  and 
 Remove
  items from the collection, as well as iterate over all of them. That’s 
 it – no sorting, ordering, inserting at specific locations or any of the other things that a
  List
  
 will do. The only way to get at the items is by enumerating them.
  
 ISet<T>
  is probably what you’d expect – a set-like collection that allows you to determine 
 and create relationships between two collections.
  ISet<T>
  descends from
  ICollection<T>
  and 
 adds the ability to treat collections as sets. You can determine the union and intersection of 
 two collections, as well as whether the two collections overlap or not. You can merge two 
 collections together or create a new collection that is the intersection of the two.",NA
5.6 Why you should be using the Spring4D Collections,"I recommend that you use the collections in the
  Spring.Collections.pas
  unit instead of the ones 
 that come with the Delphi RTL. I do so for the following reasons:
  
 • The Spring4D collections are interface-based and are thus easier to manage in your 
 code.• They all implement Spring4D’s
  IEnumerable<T>
 . As we’ll see in the next chapter, 
 this is a powerful interface for managing, iterating, and using collections.
  
 • They provide two collections that are not provided by the Delphi RTL – ICollection 
 and ISet.",NA
5.7 Conclusion,"Collection classes are a common and necessary part of development. When combined with 
 generics and interfaces, they become a very powerful coding tool. In the next two chapters 
 we’ll see ways to make collections even more powerful by using enumeration and
  
 IEnumerable<T>",NA
6 Enumerators in Delphi,NA,NA
6.1 Introduction,"I’ve talked about how these collections can work with Delphi’s
  for...in
  syntax. But how do you 
 make your own classes work with the
  for...in
  statement?
  
 Well, it’s pretty easy. In order to do so, you need to provide these four things.
  
 1. A class or record that will enumerate within
  for...in
  must provide a function called 
 GetEnumerator()
 .
  
 2. The
  GetEnumerator
  function must return a class, record, or implemented interface that 
 has the following: 
  
 3. A method called
  MoveNext
  that returns a
  Boolean
  indicating whether the end of the 
 collection has been reached or not 
  
 4. A read-only property called
  Current
  that indicates the item that is currently being 
 “looked at” as the enumeration occurs.
  
 That’s a bit convoluted, so at this point a simple demo would be helpful, no?
  
 You can already enumerate the characters in a string, but it’s a simple example, and so how 
 about we create an enumerator that runs through the characters in a string?
  
 TForInDemoClassEnumerator
  =
  class 
  
  
 private 
  
   
 FString
 :
  string
 ; 
  
   
 FIndex
 :
  integer
 ; 
  
  
 protected 
  
   
 function
  GetCurrent
 :
  Char
 ;
  virtual
 ; 
  
 public 
  
   
 constructor
  Create
 (aString
 :
  string
 )
 ; 
  
  
 function
  MoveNext
 :
  Boolean
 ; 
  
   
 property
  Current
 :
  Char
  read
  GetCurrent
 ; 
  
 end
 ;
  
 TForInDemo
  =
  class 
  
  
 private 
  
   
 FTheString
 :
  string
 ;",NA
6.2,NA,NA
 IEnumerator<T>,NA,NA
 Interface,"Now, the above discussion talks a lot about specific methods that must be included as part 
 of an enumerator and as part of a class that wants to be enumerated. And of course, that 
 should immediately make you think “Interfaces!” And sure enough, there are some nice 
 interfaces that fall out of this (You knew I’d work interfaces into things here eventually, 
 didn’t you? Yes, you did.).
  
 Consider this interface:
  
 type 
  
  
 IEnumerator
 <
 T
 > =
  interface 
  
  
 [
 '{DD445F01-975D-405E-BCC1-09D3E78CB0FF}'
 ] 
  
  
 function
  GetCurrent
 :
  T
 ; 
  
   
 function
  MoveNext
 :
  Boolean
 ; 
  
   
 property
  Current
 :
  T
  read
  GetCurrent
 ; 
  
 end
 ;
  
 That should look awfully familiar. It’s the exact two methods and one property needed to 
 implement an enumerator – hence the name.
  
 I’ve declared this
  IEnumerator<T>
  interface myself, but the Delphi RTL includes a similar one 
 in the System.pas unit. And at its base,
  IEnumerable<T>
  is all about implementing the
  
 GetEnumerator 
 method.
  
 It leverages generics because the type of what is being enumerated doesn’t matter as far as 
 the interface is concerned. And remember when I said that a call to
  GetEnumerator
  could 
 return an interface? Well it can, and the compiler will happily use an
  IEnumerator<T>
  to 
 implement the 
 for...in
  loop.
  
 Thus, your enumerators can implement this interface and your calls to
  GetEnumerator
  can 
 return this interface, and you can add flexibility to how they are implemented. Here’s an 
 example:
  
 TStringEnumerator
  =
  class
 (TInterfacedObject
 ,
  IEnumerator
 <
 Char
 >
 ) 
 private 
  
  
 FIndex
 :
  integer
 ; 
  
  
 FString
 :
  string
 ; 
  
  
 function
  GetCurrent
 :
  Char
 ; 
  
 public 
  
  
 constructor
  Create
 (aString
 :
  string
 )
 ; 
  
  
 function
  MoveNext
 :
  Boolean
 ; 
  
  
 property
  Current
 :
  Char
  read
  GetCurrent
 ; 
  
 end
 ;",NA
6.3 Specialized Enumerators,"The implementation of an enumerator is, as I mentioned, really simple. But what if you 
 wanted to get a little creative in the
  GetCurrent
  method? After all, at that point you have 
 complete control over what the enumerator returns. In our simple case with characters and 
 strings, what if we decided to, say, always return the uppercase version of the character? Or 
 if we were iterating over integers, return the squares of the numbers in the collection? That 
 would be super easy, right? Well, yes, it would.
  
 Consider this code:",NA
6.4,NA,NA
 TEnumerable<T>,NA,NA
 in Generics.Collections,"All of the collections above descend from a class called
  TEnumerator<T>
 . In the Delphi RTL, 
 TEnumerator<T>
  is an abstract class that defines two methods that needs to be overridden, 
 namely 
 DoGetCurrent
  and
  DoMoveNext
 . What each does should be self-explanatory based on 
 what we’ve seen in this chapter. Each of the generic collections has a nested type called
  
 TEnumerator
  that overrides and implements these methods.
  
 Similar to what we just did in the previous section,
  DoGetEnumerator
  returns an instance of 
 TEnumerator<T>
  which in turn defines the methods needed for an enumerator. Those 
 methods are 
 DoCurrent
 , which gets the current item and returns it via the
  Current
  property, 
 and
  MoveNext
 , which returns a boolean that indicates whether or not the enumerator was 
 able to move to the next item. Thus, as a result of descending from
  TEnumerable<T>
 , the non-
 threaded collections are usable with Delphi’s
  for...in
  syntax.
  
 Note that an enumerator doesn’t guarantee that the items will be returned in 
 any given order, just that every item will be returned once.",NA
6.5 Conclusion,"Enumerators are a powerful tool to use with your collections. They enable you to control 
 access to the elements of a collection and to retrieve them out of the collection under your 
 own terms.",NA
7 IEnumerable,"In the Collections chapter, I talked about the Spring4D collections, and how they all 
 implement 
 IEnumerable<T>
 . This interface and its implementation is so cool that it requires 
 its own chapter.
  
 Normally, one of the common things that you’ll want to do with a collection is to iterate 
 over the contained items in search of a specific subset. Sometimes you want the first five of 
 them. Sometimes you want all the even ones, or all the items that start with ‘k’.
  
 For instance, let’s say you have a collection of integers, and you want to find out which one 
 of them is the biggest. The classic solution has usually been something like this:
  
 program
  ListEnumerableDemo
 ;
  
 {$APPTYPE CONSOLE}
  
 uses 
  
   
 System
 .
 SysUtils 
  
 ,
  Spring
 .
 Collections
 ;
  
 var 
  
 List
 :
  IList
 <
 Integer
 >; 
  
 i
 ,
  Biggest
 :
  integer
 ; 
  
 begin 
  
   
 List
  :=
  TCollections
 .
 CreateList
 <
 integer
 >; 
  
  
 List
 .
 AddRange([
 1,6,2,9,54,3,2,7,9,1
 ])
 ;
  
  
 Biggest
  :=
  MaxInt
  -1; 
  
  
 for
  i
  := 0
  to
  List
 .
 Count
  - 1
  do 
  
  
 begin 
  
  
  
 if
  List[i]
  >
  Biggest
  then 
  
  
  
 begin 
  
  
   
 Biggest
  :=
  List[i]
 ; 
  
  
  
 end
 ; 
  
  
 end
 ; 
  
  
 WriteLn
 (
 'The biggest is: '
 ,
  Biggest)
 ; 
  
 end
 .",NA
7.1,NA,NA
 IEnumerable<T>,"Those of you who also use .Net are probably familiar with
  IEnumerable<T>
  already, but 
 perhaps you didn’t know that much of the same power was available to you in your Delphi 
 code. For those of you not familiar, you are in for a treat.",NA
7.2 Predicates,"Remember our humble little predicates from a previous chapter? The anonymous method 
 type declared as:
  
 TPredicate
 <
 T
 > =
  reference
  to function
 (
 const
  value
 :
  T)
 :
  Boolean
 ;
  
 Well, they are about to become really important and useful.
  IEnumerable<T>
  uses them 
 frequently and effectively. Remember the example of “included or not?” Well, that’s what
  
 IEnumerable<T>
  is really good at. It holds an iteration of things. You pass a predicate, and it 
 can determine if you want the items to be part of the result or not. If the predicate is
  True
 , 
 then the individual item is “in”, or included. If it is “out”, then the predicate will return
  False
 , 
 or excluded. So if you want to get all the items in a list strings that contain the letter ‘z’, then 
 you can do the following:",NA
7.3 An Interview with,NA,NA
 IEnumerable<T>,NA,NA
 (IEoT):,"Nick
 : Hey, IEoT, thanks for stopping by and chatting with us 
 today 
 IEoT
 : No problem – I’m glad to do it.
  
 Nick
 : First, let’s talk about your role in Delphi. Up until now you haven’t been very popular. 
 IEoT
 : Well, no, and that’s bothered me. Delphi developers haven’t really paid much 
 attention to me as I think they believe that the Spring Framework is all about Dependency 
 Injection. Don’t get me wrong – I love
  TContainer
 . He’s a great guy and fun to be around. But 
 he’s not all there is. I’m a powerful part of what Spring for Delphi does, and yeah, I won’t lie 
 – I’ve felt under-appreciated. 
 Nick
 : I can understand that.
  
 IEoT
 : Well, I appreciate you having me on to talk about what I can do.
  
 Nick
 : No worries, glad to do it. First up, tell me what this whole “of T” business is all about. 
 IEoT
 : Well, I can be a container for any type you like. Just define the type that you want me 
 to keep track of, and I’ll keep track of it for you. Any type at all. Doesn’t matter.
  
 Nick
 : So, you have been accused of being implemented too much. What do you have to say 
 about that?
  
 IEoT
 : Oh, you want to get into that, eh? Well, it’s true that I get implemented by a lot of 
 classes. But that just proves the power and usefulness of interfaces, right? I mean, who 
 cares whether I’m a front for a list or a collection or whatever? That’s sort of the point. I can 
 do my thing no matter what is behind my scenes.
  
 Nick
 : Well, sure, tell us a bit about what your basic methods do.
  
 IEoT
 : Well, my most very basic functionality provides access to everything inside of the 
 container I’m implementing. You can easily do a
  for...in
  on me and get out every item I 
 contain. You can get my
  First
  item or my
  Last
 . You can get the biggest or the smallest with a 
 simple method call. Shoot, you can even tell me how to compare two things together and I’ll 
 tell you the biggest of any complex type. But that’s getting ahead of myself.
  
 Nick
 : Yeah, let’s hold off on that for now. Let’s move on to some of the more advanced 
 things you can do, say, with predicates.
  
 IEoT
 : Yeah, predicates really let me strut my stuff. Pass me a predicate and you can really 
 control what I return back. Predicates let you tell me what to keep and what to toss. Then I 
 return all the keepers, and you have another instance of me with all of them in it. It’s a win 
 all around once you learn to use predicates. Want to keep all the strings that have more 
 than three vowels in them? You can do it. And that’s just if you pass me predicates.
  
 Nick
 : What else can you be passed?
  
 IEoT
 : Well, you can pass me actions. An action is just some code that I’ll run against each 
 element I have. I’ll do anything you want to every item I have. Just call my
  ForEach
  method 
 with an Action",NA
8 Run-time Type Information,NA,NA
8.1 Introduction,"Run-time Type Information (RTTI) is information about a class that the compiler gathers 
 and attaches to a class at compile time. That information is then retrievable and modifiable 
 by the developer at run-time – hence the name. At compile time, the compiler attaches 
 information –metadata – about a given class to the class itself for retrieval and examination 
 at runtime.
  
 Delphi has had RTTI since Delphi 1.0. It is the old RTTI that lets the Object Inspector get 
 and set property values in the Form Designer. However, the old RTTI system was not based 
 on classes and was a bit cumbersome to use. The old RTTI system only stored information 
 about
  published
  values.
  
 Delphi 2010 introduced a very powerful new version of RTTI (found appropriately enough 
 in the 
 RTTI.pas
  unit) that provides run-time access to a class’s fields, properties, and 
 methods as well as the parameters of those methods.
  
 In addition, the new RTTI means that you can attach your own runtime information to 
 classes via attributes.
  
 In this chapter, we look at basic RTTI, how you can find out almost anything about a given 
 class at run-time. In the next chapter, we’ll see how you can attach your own RTTI to a class 
 with attributes, and end with a practical example of using RTTI.
  
 Though it might seem complicated on the surface, RTTI is actually a rather simple feature. 
 During the process of compiling, the compiler has a lot of information about the types that 
 it is compiling. The compiler takes that information and “attaches” it to the class in the 
 resulting binary. The RTTI unit contains a set of classes for retrieving this information from 
 the binary. Unless you otherwise specify (and how to do that will be discussed below), RTTI 
 is generated for every eligible type compiled into your binary, including classes, records, 
 enumerated types, interfaces, ordinal types, and more.
  
 With RTTI, you can do the following:
  
 • Gather information about the fields, properties, and methods of a type, including the 
 parameters of those methods.
  
 • Get and set values for fields and properties
  
 • Invoke any method, including passing values for any number of parameters, and 
 returning values for functions.
  
 However, before you can really dive into RTTI, you need to understand one of its basic 
 building blocks,
  TValue
 .",NA
8.2,NA,NA
 TValue,"TValue
  is a new record type that was introduced along with the new RTTI in Delphi 2010. In 
 some ways it is similar to a variant, but it is not the same, and should not be used as such. It 
 is able to hold data of various types, and it can convert that data to types that are 
 assignment compatible, such as
  Integer
  to
  Word
  or
  Char
  to
  String
 . It wasn’t designed to be used 
 as a variant – where you could change its type easily – but instead as a transport for getting 
 data from its concrete values to dynamic RTTI and back. A
  TValue
  can’t change its type once 
 set.
  
 TValue can hold virtually any Delphi type. Its declaration includes a private field
  FValueData
  
 of type
  TValueData
  which is declared as follows:
  
 TValueData
  =
  record 
  
 FTypeInfo:
  PTypeInfo; 
  
 // FValueData vs old FHeapData: 
  
 // FHeapData doubled as storage for interfaces. However, that was ambiguous // in the case of nil 
 interface values: FTypeInfo couldn't be trusted // because it looked like the structure was 
 uninitialized. Then, DataSize // would be 0.
  
 // FValueData is different: interfaces are always stored like strings etc., // as a reference stored in a 
 blob on the heap.
  
 FValueData:
  IValueData; 
  
 case
  Integer of 
  
 0:
  (FAsUByte
 :
  Byte); 
  
 1:
  (FAsUWord
 :
  Word); 
  
 2:
  (FAsULong
 :
  LongWord); 
  
 3:
  (FAsObject
 :
  Pointer); 
  
 4:
  (FAsClass
 :
  TClass); 
  
 5:
  (FAsSByte
 :
  Shortint); 
  
 6:
  (FAsSWord
 :
  Smallint); 
  
 7:
  (FAsSLong
 :
  Longint); 
  
 8:
  (FAsSingle
 :
  Single); 
  
 9:
  (FAsDouble
 :
  Double); 
  
 10:
  (FAsExtended
 :
  Extended); 
  
 11:
  (FAsComp
 :
  Comp); 
  
 12:
  (FAsCurr
 :
  Currency); 
  
 13:
  (FAsUInt64
 :
  UInt64); 
  
 14:
  (FAsSInt64
 :
  Int64); 
  
 15:
  (FAsMethod
 :
  TMethod);",NA
8.3 RTTI on Classes,"The basic functionality of RTTI is to look at the features of a class. So let’s define a class that 
 we can then use RTTI to look at:",NA
TRttiType,"TRttiType
  holds the information about a given type. Given the above code,
  TempType
  is now a 
 reference to the RTTI for
  TRTTIDemoClass
 . Below is part of the public interface that contains 
 the most common methods for accessing the information about the given type:
  
 function
  GetMethods
 :
  TArray
 <
 TRttiMethod
 >;
  overload
 ;
  virtual
 ;
  
 function
  GetFields
 :
  TArray
 <
 TRttiField
 >;
  virtual
 ;
  
 function
  GetProperties
 :
  TArray
 <
 TRttiProperty
 >;
  virtual
 ;
  
 function
  GetIndexedProperties
 :
  TArray
 <
 TRttiIndexedProperty
 >;
  virtual
 ;
  
 function
  GetMethod
 (
 const
  AName
 :
  string
 )
 :
  TRttiMethod
 ;
  virtual
 ;
  
 function
  GetMethods
 (
 const
  AName
 :
  string
 )
 :
  TArray
 <
 TRttiMethod
 >;
  overload
 ;
  virtual
 ;
  
 function
  GetField
 (
 const
  AName
 :
  string
 )
 :
  TRttiField
 ;
  virtual
 ;
  
 function
  GetProperty
 (
 const
  AName
 :
  string
 )
 :
  TRttiProperty
 ;
  virtual
 ;
  
 function
  GetIndexedProperty
 (
 const
  AName
 :
  string
 )
 :
  TRttiIndexedProperty
 ;
  virtual
 ;
  
 Note the RTTI for indexed properties (the last function above) only is available 
 in XE2 and above.
  
 TRttiType
  is the class that actually holds all the RTTI information about the class being 
 inspected. Using the methods listed above, you can ask it for all the fields, properties, and 
 methods of the given class. You can ask for all in an array, or a specific item by name.
  
 To get a
  TRttiType
 , you call
  TRttiContext.GetType()
 , an overloaded method. You can pass it a 
 TClass
  reference or a pointer to the type information for a given class. Above, we’ve gotten 
 the 
 TempType
  reference with a call to the
  ClassInfo
  class method of
  TRTTIDemoClass
 .
  
 Each member type has a specific RTTI type assigned to it. Fields have a
  TRttiField
  class to 
 describe them. There is also
  TRttiMethod
 ,
  TRttiProperty
 , and
  TRttiIndexedProperty
 . Each
  
 TRttiMethod 
 has within it the
  TRttiParameter
  classes needed to define the parameters (if any) 
 associated with the method.
  
 TRttiField
  
 RTTI is available for all fields of a class regardless of scope. So, for instance, you can call:",NA
8.4 Using RTTI to Affect Instances,"The previous examples all worked on classes, as opposed to instances. In other words, the 
 RTTI retrieved information from a
  TClass
  reference as opposed to an instance of that
  TClass
 .",NA
Getting and Setting Values,"One of the basic things to do with a class instance is to set and retrieve values of variables. 
 Delphi’s RTTI lets you do that for any field of a class.
  
 The first thing to note is that you must have a valid instance of a class that you want to 
 alter. Once you have that, RTTI will take it as a parameter and operate on it as desired. For 
 instance, here is some code that will take an instance of
  TRTTIDemoClass
  and set values for its 
 field called ‘FPrivateField:
  
 Note that the type of the parameter sent to the
  SetValue
  field that sets the new value is our 
 old pal 
 TValue
 . The code illustrates this by setting the new value to a
  TValue
  explicitly:
  
 WriteLn
 (
 'Getting and setting a private field....'
 )
 ; 
  
 TempType
  :=
  Context
 .
 GetType(TRTTIDemoClass
 .
 ClassInfo)
 ; 
  
 TempField
  :=
  TempType
 .
 GetField(
 'FPrivateField'
 )
 ; 
  
 NewValue
  :=
  'This is a new value for PublicProperty held by a TValue'
 ; 
  
 TempField
 .
 SetValue(RDC
 ,
  NewValue)
 ; 
  
 WriteLn
 (
 'You can get the value using RTTI: '
 ,
  TempField
 .
 GetValue(RDC)
 .
 ToString)
 ;
  
 Note that you can’t get at the value you’ve set from the object itself, but you can access it via 
 RTTI.
  
 And as a side note, while RTTI allows you to do it, it is bad practice to change the values of 
 internal 
 fields on a class. Instead, you should use the properties of a class to alter its internal state. 
 Properties work almost exactly the same way, except we can “prove” that the value was set 
 by asking for the value directly from the instance:
  
 WriteLn
 (
 'Getting and setting a property...'
 )
 ; 
  
 TempProperty
  :=
  TempType
 .
 GetProperty(
 'PublicProperty'
 )
 ; 
  
 NewValue
  :=
  'NewValue for PublicProperty'
 ; 
  
 TempProperty
 .
 SetValue(RDC
 ,
  NewValue)
 ; 
  
 WriteLn
 (
 'PublicProperty is now set to: '
 ,
  RDC
 .
 PublicProperty)
 ; 
  
 WriteLn
 (
 'You can also get the value using RTTI: '
 ,
  TempProperty
 .
 GetValue(RDC)
 .
 ToS
 \ 
 tring)
 ;
  
 Indexed properties work exactly as you’d expect:",NA
Invoking Methods,"Not only can you set and get values of a class instance, you can also call its methods. The 
 TRttiMethod
  class has a method called
  Invoke
  that takes two parameters:
  
 function
  TRttiMethod
 .
 Invoke
 (Instance
 :
  TObject
 ;
  const
  Args
 :
  array of
  TValue)
 :
  TVal
 \ 
 ue
 ;
  
 The first is the instance itself whose method you are going to call. The second is an array of
  
 TValue 
 that represent the parameters that are passed to the method. If the method is a 
 function, then the result of that function call is returned as a
  TValue
  by the call to
  Invoke
 .
  
 procedure
  CallMethodsWithRTTI
 ; 
  
 var 
  
 RDC
 :
  TRTTIDemoClass
 ; 
  
 Context
 :
  TRttiContext
 ; 
  
 TempType
 :
  TRttiType
 ; 
  
 TempMethod
 :
  TRttiMethod
 ; 
  
 TempParameters
 :
  TArray
 <
 TRttiParameter
 >; 
  
 TempParameter
 :
  TRttiParameter
 ; 
  
 TempValue
 :
  TValue
 ; 
  
 TempResult
 :
  TValue
 ; 
  
 ParameterValues
 :
  array
 [
 0..1
 ]
  of
  TValue
 ; 
  
 i
 :
  Integer
 ; 
  
 begin 
  
 RDC
  :=
  TRTTIDemoClass
 .
 Create
 ; 
  
 try 
  
   
 TempType
  :=
  Context
 .
 GetType(TRTTIDemoClass)
 ;",NA
8.5 General Notes,"Some additional things to note about Delphi’s RTTI:
  
 • You can use the
  IsClassMethod
  and the
  IsStatic
  calls to determine, well, if the method is a 
 class method or if it is a static method.
  
 • If the method is a class method, you can call it by passing the
  ClassType
  to
  Invoke
  as the 
 first parameter without having a valid instance.
  
 • You can also retrieve the calling convention and the dispatch type of a method, as well 
 as a pointer to its actual location in the Virtual Method Table.",NA
8.6 RTTI for Non-classes,"Classes are probably the most common use case, but Delphi can also track RTTI for non-
 class types such as records, enumerations, ordinal types, and others.",NA
RTTI for Ordinal Types,You can gather RTTI about the various ordinal types. Consider the following code:,NA
RTTI for Records,"Records can have RTTI attached to them as well. Their RTTI works very similarly to that of 
 a class:
  
 // Record 
  
 TempType
  :=
  Context
 .
 GetType(
 TypeInfo
 (TDemoRecord))
 ; 
  
 if
  TempType
 .
 IsRecord
  then 
  
 begin 
  
  
 TempRecord
  :=
  TempType
 .
 AsRecord
 ; 
  
  
 WriteLn
 (TempRecord
 .
 Name
 ,
  ' has the following methods: '
 )
 ; 
  
 for
  
 TempMethod
  in
  TempRecord
 .
 GetMethods
  do 
  
  
 begin 
  
   
 WriteLn
 (
 ' 
  
 '
 ,
  TempMethod
 .
 Name)
 ; 
  
  
 end
 ; 
  
  
 WriteLn
 (
 '... and the following fields:'
 )
 ; 
  
  
 for
  TempField
  in
  TempRecord
 .
 GetFields
  do 
  
  
 begin 
  
   
 WriteLn
 (
 ' 
  
 '
 ,
  TempField
 .
 Name)
 ; 
  
  
 end
 ; 
  
  
 WriteLn
 ; 
  
 end
 ;",NA
RTTI for Arrays,You can determine general information about arrays as well:,NA
8.7 Miscellaneous Methods,"There are a few other things that you can do with Delphi’s RTTI:
  
 • Every RTTI object has a
  Parent
  property that tells you its owning member. So for 
 instance, a parameter is parented by a method, which in turn is parented by a type.
  
 • The
  TRttiType
  class can tell you if a type
  IsManaged
  (strings and interfaces),
  IsOrdinal
 , 
 IsRecord
 , and
  
 •
  TRttiType
  has a set of methods that find the “Declared” fields, properties, and methods. 
 The methods with “Declared” in their names return only those items actually 
 declared in the class itself and not its ancestors.
  
 • RTTI is also available for interfaces via the
  TRttiInterfaceType
  class. You can grab the
  
 GUID 
 and declared methods for any interface.",NA
8.8 RTTI Compiler Directives,"The new RTTI features are cool and powerful, but one of the downsides is that it adds a lot 
 of data to the resulting binary. In order to limit that increase in size, Delphi provides a set of 
 compiler directives that can be used to limit the amount of RTTI information that is stored.
  
 I should add that this section covers code that should fall into the “
 only do this if 
 you really know what you are doing
 ” area. Turning off RTTI, even for certain 
 portions of your code, could make your code stop working as expected, 
 especially if you are using libraries that expect RTTI to be present, like an 
 object-relational mapping library, a Dependency Injection container, etc.
  
 If you want to turn off RTTI for all the units in your application, then put this at the top of 
 your DPR file, right before the
  uses
  clause:",NA
Strong Type Linking,"If you create a class, put in in your app, but never actually instantiate it, then by default, 
 that class will not be included in the resulting binary, and since the class isn’t there, there 
 naturally won’t be any resulting RTTI for the class. If you want to ensure that
  every
  class is 
 included and that all those classes include RTTI, you can use the following compiler 
 directive:
  
 {$STRONGLINKTYPES ON}",NA
8.9 Conclusion,"So there you have the basics of Run-time Type Information. In this chapter, we saw how 
 you can identify, evaluate, set, and invoke the fields, properties, and methods of classes and 
 records. In the next chapter we’ll see how you can add your own custom run-time 
 information to classes via a feature called Attributes.",NA
9 Attributes,NA,NA
9.1 Introduction,"Okay, so far we’ve seen how Delphi’s compiler attaches RTTI meta-data to your classes and 
 other types. We’ve seen how you can control the extent of RTTI which is included in your 
 binary. And so here is this chapter’s rhetorical question: Wouldn’t it be cool if you could 
 attach your own custom information to a class, method, property, field, or parameter?
  
 Why yes, it would be cool! And as always, I would never ask this question if the answer 
 weren’t“Yes, you can do that!”. So, yes, you can do that through a language feature called 
 attributes. By adding attributes to classes, records and other items, you can define your 
 own run-time information that can then be retrieved using the RTTI framework.",NA
9.2 What are Attributes,"Attributes are very simple, really. You can declare a custom attribute as a descendant of
  
 TCustomAttribute
 , a class declared in
  System.pas
 .
  
 // Defines a simple attribute
  
 SimpleAttribute
  =
  class
 (TCustomAttribute)
  
 private
  
 FNumber
 :
  integer
 ;
  
 public
  
 constructor
  Create
 (aNumber
 :
  integer
 )
 ;
  
 property
  Number
 :
  integer
  read
  FNumber
 ;
  
 end
 ;
  
 That’s all there is to a basic attribute – it’s a simple class that declares an integer property. 
 Things get even simpler when you see that
  TCustomAttribute
  itself is a direct descendant of
  
 TObject
 :
  
 TCustomAttribute
  =
  class
 (
 TObject
 )
  
 end
 ;
  
 That’s it – seriously. An attribute is nothing more than a class that descends from
  
 TCustomAttribute 
 and which can, if desired, have properties and a constructor to set the",NA
9.3 A Simple Example,"Attributes can be very useful. They are most often used to tag items in your code with 
 useful information. For example, you may have a class that you want to display as part of 
 your UI. However, when you do, you don’t want the identifier names in your code to be 
 used to display the labels for the associated data. Instead, you can ‘tag’ the properties that 
 you want to display with an attribute. First, you can declare an attribute type that will take 
 as a single string parameter the text that you want to use in the label:
  
 type
  
 DisplayTextAttribute
  =
  class
 (TCustomAttribute)
  
 private
  
 FDisplayText
 :
  string
 ;
  
 public
  
 constructor
  Create
 (aDisplayText
 :
  string
 )
 ;
  
 property
  DisplayText
 :
  string read
  FDisplayText
  write
  FDisplayText
 ;
  
 end
 ;
  
 Then, you place that attribute on each of the properties that you want to display:",NA
9.4 Conclusion,"Attributes are cool. You can use them to add specific data to the RTTI of your classes, 
 records, and enumerations. You can easily retrieve that data and use it in your applications, 
 enabling your code to be richer and more complete with the addition of some simple 
 syntax. If you aren’t using attributes to decorate your code, you should start.",NA
9.5 An Interview with Attributes,"Nick
 : Attributes, thanks for sitting down with me today. Very much appreciated",NA
10 Using TVirtualInterface,"By now you should realize that you need to be programming against interfaces and not 
 implemen-tations. (Didn’t I promise you in the first chapter that I’d keep harping on this 
 point?) Interfaces let you write loosely coupled code. And if you don’t believe by now that 
 decoupling your code is terribly important, I’d like you to stop reading right now, get a 
 small ball-peen hammer, and keep hitting yourself in the forehead until you change your 
 mind.
  
 So if you have made it this far, you will know that interfaces must be implemented before 
 they can be used. You have to put some code behind an interface to make it do anything. 
 Normally, this is done with an implementing class:
  
 type
  
 ISprocketProcessor
  =
  interface
  
 procedure
  ProcessSprockets
 ;
  
 end
 ;
  
 TSprocketProcessor
  =
  class
 (TInterfacedObject
 ,
  ISprocketProcessor)
  
 procedure
  ProcessSprockets
 ;
  
 end
 ;
  
 But what if you could implement an interface without having a specific class? What if there 
 were a way to implement any interface with a single module of code? What if you could 
 decide at runtime how to implement an interface? Would I even be asking these questions 
 and writing this if those things weren’t possible?
  
 So, yes, obviously there is a way. Delphi XE2 introduced a very cool new class called
  
 TVirtualInterface
 . Its purpose is to allow you to descend from it and respond to any interface 
 dynamically. If you think about that for a second, you’ll realize that this is pretty powerful. For 
 instance, it’s the thing that lets the awesome Delphi Mocks Framework (which we’ll talk about 
 in a later chapter) provide a mock implementation of any interface that you pass to it.
  
 As we saw in Chapter 2, normally when you implement an interface, you provide a class 
 that implements it in a specific way – i.e. that implementation becomes static at runtime. 
 There are ways – typically via Dependency Injection – that allow you to choose an 
 implementation, but even then you are limited to a specific set of implementations.
  
 TVirtualInterface
  allows you to dynamically – i.e. at runtime – determine how an interface will 
 be implemented. I’ll start out with some simple examples, and then we’ll move to a useful 
 use of 
 TVirtualInterface
 .
  
 Here’s the public interface for
  TVirtualInterface
 :",NA
10.1 A Slightly Better TVirtualInterface,"So far, all we’ve looked at is demo code. I can’t think of any reason why you’d actually, in 
 the real world, implement an interface that way. But it serves to show you how
  
 TVirtualInterface
  works and how you can get it to do what you want.
  
 Now
  TVirtualInterface
  is a cool class, but as is, it’s a little clumsy to use. How about we write a 
 descendant class that does most of the “under the hood” work for you and makes it really 
 easy to dynamically create a virtual interface?
  
 Back in the chapter on Generics, I tried to get you to “think generically” and how generics 
 (or as I prefer to think of them, parameterized types) are useful in more ways than just 
 collections and lists. Well, I got to looking at
  TVirtualInterface
  and I thought, “
 You know, here’s 
 a class that actually requires type information about a given type, and in order for it to do",NA
10.2 An Actually Useful Example,"Okay, enough with the not-all-that-useful examples. I mean, the previous examples were 
 illustrative, but not really “real-world useful.”
  
 The true usefulness of
  TVirtualInterface
  occurs when you use it to create code where you have 
 no idea what interface the user of your code is going to try to implement. All the examples 
 so far have shown only implementing classes where you do know which interface is being 
 used. The exception so far is the
  TReportingVirtualInterface
  example which reports information 
 on any interface you pass to it. Since we have proven that you can use
  TVirtualInterface
  to do 
 something useful, let’s take it a step further.
  
 A practical use of
  TVirtualInterface
  is to create a mocking library for unit testing. I’ve 
 mentioned previously the Delphi Mocks Framework by Vince Parrett of FinalBuilder fame 
 (We’ll be covering that framework extensively in a later chapter.). Another excellent 
 implementation of a mocking framework (as well as a bunch of other very innovative and 
 interesting stuff) is by Stefan Glienke as part of his DSharp framework. Both of these use
  
 TVirtualInterface
  to provide a mock implementation for any interface (though the DSharp 
 code implements its own version of 
 TVirtualInterface
  that works with Delphi XE – very cool). 
 Both, of course, allow you to pass them any interface, and they’ll happily mock your 
 interface for unit testing purposes. So why not do an example here of a very simple 
 mocking object that you can actually use if you want?",NA
10.3 ISimpleStub,"In the Unit Testing chapter, I will discuss “The Vocabulary of Unit Testing.” In it I’ll describe 
 fully the distinction between a stub and a mock. There, you’ll see that a “stub” is “a fake that 
 has no effect on the passing or failing of the test, and that exists purely to allow the test to 
 run.” So how about we build a universal stub – a class that can pretend to be any interface 
 you want, and not do anything at all. That can’t be that tough, can it?",NA
10.4 TSimpleMock,"Okay, so there’s a useful, dynamic way to use
  TVirtualInterface
 .
  TSimpleStub<T>
  will work great 
 for a stub that you expect absolutely nothing from. But sometimes you need a fake interface 
 that does something more than just exist, and when that is the case, you are creating a 
 mock. In the unit testing chapter, I’ll define a mock as “
 a fake that keeps track of the 
 behavior of the Class Under Test and passes or fails the test based on that behavior
 .” Thus, a 
 mock needs to do more than exist like a stub – it needs to behave in a way that you can 
 define. So how about we take ‘TSimpleMock
  
 One of the most common things that a mock interface does is to respond with “this” when 
 passed“that”. How about we create a simple mock class that lets you define a specific 
 response to a method call?
  
 First, of course, is an interface to code against:
  
 ISimpleMock
 <
 T
 > =
  interface
 (ISimpleStub
 <
 T
 >
 ) 
  
 [
 '{9619542B-A53B-4C0C-B915-45ED140E6479}'
 ] 
  
 procedure
  AddExpectation
 (aCallName
 :
  string
 ;
  aReturnValue
 :
  TValue)
 ; 
 end
 ;
  
 The interface augments (remember, “inherits from” is not quite right with interfaces)
  
 ISimpleStub<T> 
 and adds the
  AddExpectation
  method. This is the method that we’ll use to tell 
 the mock out to respond when an interface method gets called.
  
 Here’s the implementing class:
  
 TSimpleMock
 <
 T
 :
  IInvokable
 > =
  class
 (TSimpleStub
 <
 T
 >,
  ISimpleMock
 <
 T
 >
 ) 
 private 
  
 FActions
 :
  TDictionary
 <
 string
 ,
  TValue
 >; 
  
 protected
  
 procedure
  DoInvokeImpl
 (Method
 :
  TRttiMethod
 ; 
 sult
 :
  
 TValue)
 ;
  override
 ; 
  
 public 
  
 constructor
  Create
 ; 
  
 destructor
  Destroy
 ;
  override
 ;
  
 const
  Args
 :
  TArray
 <
 TValue
 >;
  out Re
 \
  
 procedure
  AddExpectation
 (aCallName
 :
  string
 ;
  aReturnValue
 :
  TValue)
 ; 
 end
 ;",NA
10.5 Conclusion,"Okay, so there you have it: A useful implementation of
  TVirtualInterface
 . Though the above 
 examples are really simple, they can actually be used in real world testing – particularly the 
 ISimpleStub<T>
  implementation. Stubbing is common in unit testing, and even though it is a 
 very basic implementation, it can be used to stub out any interface.
  
 None of this is useful if you know what interface you need and how you are going to 
 implement it. But there are cases when you don’t know what interface you will need for a 
 particular problem, and you need to be able to flex to whatever interface the situation calls 
 for. Mocking and stubbing are perfect examples. That’s a powerful and useful thing to be 
 able to do. Hopefully this chapter has helped you see that.",NA
11 Introduction to Dependency ,NA,NA
Injection,NA,NA
11.1 Introduction,"Dependency Injection is a very powerful and important coding technique. The idea became 
 popular as the notion of “Inversion of Control” after Martin Fowler wrote an article entitled
  
 “Inversion of Control Containers and the Dependency Injection Pattern”¹
 , and since then 
 the notion has advanced rapidly, spawning numerous frameworks, books, and articles 
 describing how to use the powerful and essential technique.
  
 Inversion of Control is the notion that rather than a class creating the things that it needs, it 
 should instead “ask” for those things, receiving them either via a constructor, a property, or 
 a field. Dependency Injection is just a coding technique driven by inversion of control, 
 though there are frameworks that help to support its use. To truly get the concept of 
 Dependency Injection, though, we should talk about some general topics. There are a few 
 things that need to be accepted and understood before Dependency Injection can become 
 infused into your development process.",NA
11.2 What is a Dependency?,"A dependency is something that you depend on. That’s a bit of a snarky answer to the 
 question posed by the section header, but it does get to the point: It’s quite common for one 
 class to depend on another. And if one class depends on another, then those classes are 
 coupled together. Class A depends on Class B when you can’t compile Class A without Class 
 B. That’s really what coupling amounts to – and coupled code is bad, as we know.
  
 How does a dependency get created? Most commonly, they get created any time you create 
 one class inside of another. For example:
  
 ¹
 http://martinfowler.com/articles/injection.html",NA
11.3 The Law of Demeter (LoD),"What exactly is the Law of Demeter, you ask? The strict definition goes like this:
  
 A method of an object may only call methods 
 of: 
  
 • The object itself. 
 • An argument of the method. 
 • Any object created within the method. 
 • Any direct properties/fields of the 
 object. 
 That’s a bit formal, so here’s an example:",NA
11.4 A Design Example,"For instance, in code, you may have a
  Transaction
  class that needs a form of payment to be 
 completed. And hey, look! The
  Customer
  class has different Forms of Payment, so you pass a 
 Customer
  to the
  Transaction
 . At first all is well, because you are very careful and all you do is 
 grab the Form of Payment from the customer and use it. What could possibly go wrong?
  
 But a few months pass, and that (cough, cough) “less experienced” developer comes along 
 and is doing some maintenance work on the
  Transaction class
 . He says, “Hey look! Here’s a
  
 Customer 
 object! I think I’ll change his address here instead of over there!” and suddenly all 
 heck breaks loose. Pretty soon, you are fixing a bug in the
  Transaction
  class and
  Customer
  data 
 changes. You fix a
  Customer
  bug and access violations start flying when you try to commit 
 transactions to the database. The next thing you know, changing a
  Customer
  address is 
 sending major cash bonuses to your office cleaning service, and before you know it, there is 
 no end to the havoc wreaked by that little
  Customer
  object innocently sitting in the
  
 Transaction
  class.
  
 The right thing to do, of course, is to simply pass the Form of Payment itself, or better yet, 
 forget the Form of Payment and pass in just the money itself in some form. The idea is that 
 your classes should ask for a little as possible, and refuse to accept more than they need. If 
 you have code like this –
  
 Transaction.Customer.FormOfPayment.CreditCardNumber.ProcessCreditCard;",NA
11.5 Law of Demeter in Delphi,"Delphi and the Law of Demeter can be good friends. Here are some pointers to help out in 
 your Delphi code:
  
 • Limit the scope of your uses clauses. If you can put an item in the uses clause of the 
 implementation, do so.
  
 • Use strict private and strict protected. This will limit you from the temptation to make 
 classes“friends” of each other in the same unit.
  
 • As noted above, any time you have a chain of “dotted” properties in a single line, you 
 should examine this for violations of the Law of Demeter.
  
 • Any time you are creating a lot of temporary objects, this might indicate unnecessary 
 dependencies.
  
 • Check your constructors – if they are creating anything or taking a lot of other classes 
 as parameters, then the same thing applies: the possibility of too much coupling.
  
 • Note that these aren’t iron-clad rules but rather suggestions of examination and 
 consideration. It need not become a “dot counting exercise.” The idea is to reduce",NA
11.6 A Step-by-Step Code Example,"Okay, so what does this all mean for the way you should code? Let’s go through a simple 
 example that starts the “old-fashioned way” of doing things and moves step-by-step toward 
 a loosely coupled solution that illustrates the basics of Dependency Injection.
  
 Consider the following code:
  
 unit
  Step1
 ;
  
 interface
  
 type 
  
 TOrder
  =
  class 
  
   
 function
  Amount
 :
  integer
 ; 
  
 end
 ;
  
 TOrderValidator
  =
  class 
  
  
 procedure
  ValidateOrder
 (aOrder
 :
  TOrder)
 ; 
  
 end
 ;
  
 TOrderProcessor
  =
  class 
  
 private 
  
  
 FOrderValidator
 :
  TOrderValidator
 ; 
  
 public 
  
  
 constructor
  Create
 ; 
  
  
 destructor
  Destroy
 ;
  override
 ; 
  
  
 procedure
  ProcessOrder
 (aOrder
 :
  TOrder)
 ; 
  
 end
 ;
  
 procedure
  ProcessOrders
 ;",NA
11.7 The Dependency Injection Container,"Remember, every time you call
  Create
 , you are not only creating an instance, you are also 
 creating a dependency. As we slowly push the creation of all these classes back as far as we 
 can towards the very root of our application, the more decoupled the downstream things 
 can be. And if you haven’t figured it out yet, we’re going to try to push the creation of 
 objects so far back into the bowels of your application that you can’t even really see it. That 
 way, everything is downstream from the actual creation of objects, letting you easily 
 decouple your code because you’ll mainly be coding against interfaces, and leaving the 
 creation of the code to processes at the very root of your application.
  
 So what is this method by which your classes will be created out of sight? The technique is 
 usually called a Dependency Injection Container. The Delphi Spring Framework includes a 
 container that is easy to use and is very powerful. We’ll look at the basics of using it in the 
 rest of this chapter and at its advanced use in the next chapter.
  
 A Dependency Injection container is a special class that holds information about the 
 interfaces you use and the classes that implement them. You can register a given class as 
 implementing a given interface. Once registered, you can retrieve an interface with an 
 instantiated implementation. Why is this cool and good? Because when retrieving an 
 instantiated interface,
  you only need to know about the interface and not about the class 
 implementing it.
  
 A Dependency Injection Container takes care of creating the class for you via RTTI; you 
 don’t ever have to call
  Create
  yourself. Thus, you can deal purely with interfaces without 
 ever having to worry about creating anything. And if you aren’t creating anything, you can’t 
 cause dependencies, and if you can’t cause dependencies, then you can’t cause deep 
 coupling.
  
 How does all this work? The first thing you do with a container is register classes and 
 interfaces. The code for registering can be found in the
  Spring.Container
  unit. Place that unit 
 in the uses clause of the unit where your classes are declared and you can register them. 
 The Container is registered as a singleton called
  GlobalContainer
 , and this is the class that you 
 will use to register your classes. In our simple example, we’ll register our
  TOrderValidator",NA
11.8 Conclusion,"In this chapter, we covered the very basics of Dependency Injection, including a discussion 
 about the Law of Demeter and how we should keep our coupling as thin as possible. This 
 led to talking about constructor injection as a basic DI technique. An example of decoupling 
 code caused us to use a DI Container to ensure that the creation of objects is done as far 
 away from your “real” code as possible.
  
 In the next chapter we’ll look more closely at the Spring Container and what it can do to 
 improve your ability to inject dependencies rather than create them.",NA
12 A Deeper Look at Dependency ,NA,NA
Injection,"Okay, so by now you should have the general idea about what Dependency Injection is. You 
 should understand that one class should avoid directly creating instances of a second class, 
 but instead, defer creation as far back as possible within the application, even to the point 
 of letting a container create your classes for you.
  
 But there’s a bit more structure to the notion of Dependency Injection and a lot more that 
 the Spring Container can do for you, so we’ll examine both of those things in this chapter.
  
 Let’s start with a simple example. Consider this class:
  
 type
  
 TKnight
  =
  class
  
 private
  
 FWeapon
 :
  IWeapon
 ;
  
 public
  
 constructor
  Create
 (aWeapon
 :
  IWeapon)
  
 end
 ;
  
 This is a pretty obvious example of constructor injection. The constructor takes a 
 parameter,
  aWeapon
 , indicating that you can give the knight any weapon that he needs. The 
 presence of the parameter on the constructor also is a message to developers that a Knight
  
 must
  have a weapon. You can’t create a knight without passing him a weapon (and we 
 presume that the constructor fails if
  aWeapon
  is
  nil
 ). Thus, constructor injection should be 
 used to indicate the
  required
  dependencies that a class has.
  
 As noted above, it is standard practice not to accept
  nil
  parameters when constructing an 
 object. If a constructor has a parameter, then that parameter represents a dependency that 
 can never be
  nil
 .
  
 Thus,
  TKnight
 ’s constructor might look like this:",NA
12.1 Optional Dependencies,"Sometimes, however, dependencies are not required. Thus, consider this class:
  
 type 
  
 TBasketballPlayer
  =
  class 
  
 private 
  
   
 FBall
 :
  IBasketball
 ; 
  
 public 
  
   
 constructor
  Create
 (aBasketball
 :
  IBasketball)
 ; 
 end
 ;
  
 At first glance, this looks right – but then you stop to consider that basketball teams require 
 five players and there is only one ball. Thus, you can’t create all five players, each with a 
 ball. The dependency of a ball is
  optional
  in this case. What to do?",NA
12.2 Setter Injection,"This is where “Setter Injection” comes in. Instead of passing the dependency in via the 
 constructor where it is required for creating a player, we can instead set the ball for each 
 player as they pass it around:",NA
12.3 Method Injection,"A third type of Dependency Injection that you might use is Method Injection. Similar to 
 Setter Injection, you instead use a method to assign the dependency. See the following code:",NA
12.4 The Delphi Spring Container and Service Locator,"In the last chapter we got a very basic look at the Spring Container, using it to do all of our 
 object creation and to push all of that creation back to the root of our application. In this 
 section, we’ll look a little more closely at the container: how to use it and what it can do, as 
 well as the proper way to configure your application to take advantage of it.
  
 The primary purpose of the container is to create objects. If you really want to follow the
  
 Single Responsibility Principle¹
  in your classes, then it is not the job of a class to create its 
 dependencies. Instead, a class should defer the responsibility of creation to a class that has 
 the single responsibility of creating things. That’s what a container is – a class whose single 
 responsibility is to create things.
  
 The primary purpose of the
  ServiceLocator
  is to retrieve implementations of requested 
 services, whether they be implemented interfaces or just instances of objects. However, the 
 techniques we’ll see in this chapter will remove the need for the Service Locator, and by the 
 end of the chapter I’ll argue that its use is actually an anti-pattern.
  
 The first thing you must do before using the container is to register the relevant classes. 
 Here is a look at the Container’s registration interface:
  
 function
  RegisterType
 <
 TComponentType
 >:
  TRegistration
 <
 TComponentType
 >;
  overloa
 \
  
 d
 ;
  
 function
  RegisterType
 (componentType
 :
  PTypeInfo)
 :
  TRegistration
 ;
  overload
 ;
  
 There are two ways to register a class: as a generic type or with the type information from 
 the class. Thus, you can register a class in the following two ways:
  
 GlobalContainer
 .
 RegisterType
 <
 TSword
 >;
  
 or
  
 GlobalContainer
 .
 RegisterType(TSword
 .
 ClassInfo)
 ;
  
 ¹
 https://docs.google.com/file/d/0ByOwmqah_nuGNHEtcU5OekdDMkk/edit",NA
Registering Interfaces,"Registering classes is great, but of course the real benefit comes when you register a 
 particular class as implementing an interface. The call to
  RegisterType
  returns an instance of 
 type
  TRegistration
 . 
 TRegistration
  represents the result of registering a class and allows you to 
 describe an interface that is implemented by the registered class. Thus, it has the following 
 overloaded methods available for associating interfaces to classes:
  
 function
  Implements
 (serviceType
 :
  PTypeInfo)
 :
  TRegistration
 <
 T
 >;
  overload
 ;
  
 function
  Implements
 (serviceType
 :
  PTypeInfo
 ;
  const name
 :
  string
 )
 :
  TRegistratio
 \
  
 n
 <
 T
 >;
  overload
 ;
  
 function
  Implements
 <
 TServiceType
 >:
  TRegistration
 <
 T
 >;
  overload
 ;
  
 function
  Implements
 <
 TServiceType
 >
 (
 const name
 :
  string
 )
 :
  TRegistration
 <
 T
 >;
  over
 \
  
 load
 ;
  
 Again, you can declare an implementing interface either by using generics or the type 
 information for the interface. I’ll be using the generics method throughout as I think it is 
 easier to read and understand.
  
 Note that two of the overloads here take a name parameter. I’ll be discussing the benefits of 
 this feature below.
  
 Thus, you can now register
  TSword
  as implementing the
  IWeapon
  interface like so:
  
 GlobalContainer
 .
 RegisterType
 <
 TSword
 >.
 Implements
 <
 IWeapon
 >;",NA
Lifetime Management,"Since we are using interfaces, it is easy to forget about the lifetime of the objects behind 
 those interfaces. As a consumer of interfaces, you don’t normally worry about the lifetime 
 of the implementing class because you know that it will be destroyed when the interface 
 goes out of scope. However, things are a bit different when you are using the Container. 
 Sometimes your implementing classes need finer lifetime control than just ‘when the 
 interface goes out of scope’. You may have limited resources associated with the class. You 
 may want the same instance used for every request, or you may just want a new instance 
 created for each request to the Container.
  
 The Container lets you manage the lifetime of those objects by providing further methods 
 on the 
 TRegistration
  object that is returned when registering and declaring an 
 implementation for a given class or interface.
  
 TRegistration
  provides the following methods for determining the lifetime of the objects that 
 it creates:
  
 function
  AsSingleton
 :
  TRegistration
 ;
  overload
 ;
  
 function
  AsSingleton
 (refCounting
 :
  TRefCounting)
 :
  TRegistration
 ;
  overload
 ;
  
 function
  AsSingletonPerThread
 :
  TRegistration
 ;
  
 function
  AsTransient
 :
  TRegistration
 ;
  
 function
  AsPooled
 (minPoolSize
 ,
  maxPoolSize
 :
  Integer
 )
 :
  TRegistration
 ;
  
 If you want to have your reference be a singleton – that is, one instance for all calls to the 
 given registration – then declare it as follows:
  
 GlobalContainer
 .
 RegisterType
 <
 TSword
 >.
 Implements
 <
 IWeapon
 >.
 AsSingleton
 ;
  
 That will ensure that whenever you ask for an
  IWeapon
 , you will be given back the same 
 exact instance for all requests.
  
 AsSingletonPerThread
  does what its name implies – it provides the same instance to each 
 request within a given thread. There might be multiple instances of the implementation, 
 but each thread will always get the same instance.
  
 AsTransient
  is the default behavior.
  AsTransient
  will create a new instance for each request 
 made. Assuming that you are using an interface reference, that transient instance will live 
 as long as the interface remains in scope (i.e., as long as its reference count is greater than 
 zero, presuming you are using “normal” reference counting).
  
 AsPooled
  will create a pool of instances for use upon request. You can determine the 
 minimum and maximum number of items in the pool. When an item is requested by the
  
 ServiceLocator
 , it will be retrieved from the pool of items. All the items in the pool are created",NA
Custom Creation,"As discussed, the main function of the Spring Container is to create objects for you. 
 Normally it can do that because every object in Delphi has a default constructor or because 
 the constructor’s parameters are also registered in the Container. But what happens if your 
 class has specific requirements for creation?
  
 Well, the Spring Container provides for this via a method called
  DelegateTo
 , which allows you 
 to provide an anonymous method that creates your object however you want to create it.
  
 For instance, consider the following code:
  
 type 
  
 IWeapon
  =
  interface 
  
   
 procedure
  Fire
 ; 
  
 end
 ;
  
 TSword
  =
  class
 (TInterfacedObject
 ,
  IWeapon) 
  
 private 
  
  
 FHasScope
 :
  Boolean
 ; 
  
 public 
  
  
 constructor
  Create
 (aIsValerianSteel
 :
  Boolean
 )
 ; 
 end
 ;
  
 You can register
  TSword
  with the container and grab it with the Service Locator, but it won’t 
 be properly instantiated because you don’t have a way to get a hold of a sword with or 
 without Valerian steel (In fact, because
  Boolean
  types always default to
  False
 , you’ll always 
 get a sword without Valerian steel.). What to do?
  
 Well, here’s what you do: You register two different instances by name, passing in an 
 anonymous method that will create the sword as you want it to be created for each:
  
 GlobalContainer
 .
 RegisterType
 <
 TSword
 >.
 Implements
 <
 IWeapon
 >
 (
 'ValerianSteel'
 ) 
  
 .
 DelegateTo(
 function
 :
  TSword 
  
   
 begin 
  
   
  
 Result
  :=
  TSword
 .
 Create(
 True
 )
 ; 
  
   
 end
 )
 ; 
  
 GlobalContainer
 .
 RegisterType
 <
 TSword
 >.
 Implements
 <
 IWeapon
 >
 (
 'RegularSteel'
 ) 
  
 .
 DelegateTo(
 function
 :
  TSword 
  
   
 begin 
  
   
  
 Result
  :=
  TSword
 .
 Create(
 False
 )
 ; 
  
   
 end
 )
 ;",NA
Setting a Default Type,"Since you can register multiple types to the same interface by name, it’s possible to create 
 an ambiguous situation when asking for an implementation without a name. Consider the 
 following:
  
 Say you register two weapons by name:
  
 initialization
  
 GlobalContainer
 .
 RegisterType
 <
 TSword
 >.
 Implements
 <
 IWeapon
 >
 (
 'sword'
 )
 ;
  
 GlobalContainer
 .
 RegisterType
 <
 TDagger
 >.
 Implements
 <
 IWeapon
 >
 (
 'dagger'
 )
 ;
  
 … but then later, you ask for a weapon without a name attached.
  
 var
  
 Dagger
 :
  IWeapon
 ;
  
 begin
  
 Dagger
  :=
  ServiceLocator
 .
 GetService
 <
 IWeapon
 >;
  
 end
 ;
  
 If you do this, you’ll get an “Unsatisfied Dependency” exception, because the container 
 doesn’t know which weapon you want. And of course, you won’t know this until runtime. 
 Alas.
  
 But there is a solution. You can declare one of the weapons as the default weapon, and it 
 will be the one returned if there is any ambiguity about which
  IWeapon
  is required. Thus, 
 you should declare your registrations as follows:
  
 initialization
  
 GlobalContainer
 .
 RegisterType
 <
 TSword
 >.
 Implements
 <
 IWeapon
 >
 (
 'sword'
 )
 ;
  
 GlobalContainer
 .
 RegisterType
 <
 TDagger
 >.
 Implements
 <
 IWeapon
 >
 (
 'dagger'
 )
 .
 AsDefault
 <
 \
  
 IWeapon
 >;
  
 Thus, if you ask for an
  IWeapon
  without a name, you’ll get the dagger by default. Note, 
 though, that if you ask for an
  IWeapon
  with a name that doesn’t exist, you’ll still get an 
 exception and not the default weapon.",NA
Register the same type for two interfaces,NA,NA
Using Registration to Inject Fields and Properties,"Many times, you’ll have one registered class that has a field or property of a type that is also 
 a registered class. When this happens, you can use the container to automatically connect 
 up the field or property with the appropriate, registered implementation. This means that 
 you don’t actually have to create or even assign instances for your fields and properties; the 
 container will do it for you instead ‘auto-magically’.
  
 For instance, consider this set of types:
  
 type 
  
 IFirearm
  =
  interface 
  
 [
 '{47C93F4A-D07F-4E66-964C-6E21A3F4AB17}'
 ] 
   
 procedure
  Fire
 ; 
  
 end
 ;
  
 IAimingDevice
  =
  interface 
  
 [
 '{3DB34251-B82B-443D-AF1C-7182DC46D014}'
 ] 
  
  
 procedure
  Aim
 ; 
  
 end
 ;
  
 TScope
  =
  class
 (TInterfacedObject
 ,
  IAimingDevice) 
  
 procedure
  Aim
 ; 
  
 end
 ;
  
 TRifle
  =
  class
 (TInterfacedObject
 ,
  IFirearm) 
  
 private 
  
  
 FScope
 :
  IAimingDevice
 ; 
  
 public 
  
  
 procedure
  Fire
 ; 
  
  
 property
  Scope
 :
  IAimingDevice
  read
  FScope
  write
  FScope
 ; 
 end
 ;",NA
Using Registration to Inject Constructors and Methods,"When you register a class/interface pair in the container, it can inject an instance for you 
 anywhere that interface is found. So far, we’ve been using Constructor Injection to pass in 
 dependencies to a class. That is, we’ve used the parameters of a class’s constructor to pass 
 in to it the dependencies it needs to do its job. Then, in the implementation of the 
 constructor, instead of creating an instance of the dependency, we’ve retrieved it from the 
 container. This works really nicely because it couples you only to the interfaces that you 
 have in the constructors of your objects.
  
 But that whole process seems rather algorithmic, right? And you know that RTTI can tell 
 you everything about the parameters of the constructor, right? Doesn’t it stand to reason 
 that this process could happen in an automated way? Of course it does.
  
 The Container can actually inject an entire constructor into your class so that you use that 
 class without actually having to manually call the Service Locator. This is commonly 
 referred to as “auto-wiring.”
  
 Code always explains things well. Let’s return to our Knight and give him an interface.
  
 IFightable
  =
  interface 
  
 [
 '{A24A33AD-ADD5-442A-A909-1BF7D3FE0237}'
 ] 
  
  
 procedure
  Fight
 ; 
  
 end
 ;
  
 TKnight
  =
  class
 (TInterfacedObject
 ,
  IFightable) 
 private 
  
  
 FWeapon
 :
  IWeapon
 ; 
  
 public 
  
  
 constructor
  Create
 (aWeapon
 :
  IWeapon)
 ; 
  
  
 procedure
  Fight
 ; 
  
 end
 ;
  
 constructor
  TKnight
 .
 Create
 (aWeapon
 :
  IWeapon)
 ; 
 begin 
  
  
 inherited
  Create
 ; 
  
  
 FWeapon
  :=
  aWeapon
 ; 
  
 end
 ;
  
 procedure
  TKnight
 .
 Fight
 ; 
  
 begin 
  
  
 Write
 (
 'The Knight engages in battle! '
 )
 ; 
  
  
 FWeapon
 .
 WieldWeapon
 ; 
  
 end
 ;",NA
12.5 Registering via attributes,"Back in the attributes chapter, we saw how you can use brackets ([]) to declare attributes to 
 add your own runtime information to classes.
  
 The Spring Container provides attributes to mark constructors, fields, properties, and 
 methods as injected. By using the
  [Inject]
  attribute, you can mark a class member as 
 requiring the container to inject a value for it, and avoid registering it explicitly. In general, 
 an attribute is clearer code because the declaration is right next to the affected class 
 member, rather than separated off in a registration call in an
  initialization
  section.
  
 The
  [Inject]
  attribute can be used to replace any of the method registration calls that we 
 discussed in the previous section. You can place the
  [Inject]
  attribute on fields, properties, 
 and the parameters of methods and constructors. The attribute can also take a string 
 parameter that will correspond to the name of the item that should be injected.
  
 Let’s look at a code example. This example will show the
  [Inject]
  attribute attached to a field, 
 a property, and the parameter of a constructor.
  
 First, here are some interfaces:",NA
12.6,NA,NA
 ServiceLocator,NA,NA
 as Anti-pattern,"An “anti-pattern” is defined as “
 a pattern used in … software engineering that may be 
 commonly used but is ineffective and/or counterproductive in practice²
 .” Anti-patterns 
 should be avoided, yet sometimes they appear to be good or proper solutions to problems.
  
 In all of the examples so far, we have relied on multiple calls to
  ServiceLocator
 . They have 
 occurred as far back as they can – at the point when there is no more constructor injection 
 to be done. In the next section, though, I’m going to argue that
  ServiceLocator
  is an anti-
 pattern and shouldn’t be used except once at the very root of your program.
  
 So in the previous demos, we used the ServiceLocator to grab instances of registered 
 classes. It helped us to properly decouple the code and end up with nothing but a unit of 
 interfaces in your uses clause. Nice. Things were really well decoupled. However, those 
 calls might start to bug you after a while– they did me. I noticed that, in essence, the calls to
  
 ServiceLocator
  merely became replacements for calls to
  Create
 . They became a proxy for the 
 very code that we were trying to avoid.
  
 Now here is the thing: you can write all of that code without using the
  ServiceLocator
 , and 
 instead, you can accomplish the same thing by injecting everything. Previously, we used 
 these methods to inject dependencies:
  
 function
  InjectConstructor
 (
 const
  parameterTypes
 :
  array of
  PTypeInfo)
 :
  TRegistrati
 \
  
 on
 <
 T
 >;
  overload
 ;
  
 function
  InjectProperty
 (
 const
  propertyName
 :
  string
 )
 :
  TRegistration
 <
 T
 >;
  overload
 ;
  
 function
  InjectMethod
 (
 const
  methodName
 :
  string
 )
 :
  TRegistration
 <
 T
 >;
  overload
 ;
  
 function
  InjectMethod
 (
 const
  methodName
 :
  string
 ;
  const
  parameterTypes
 :
  array of
  PT
 \
  
 ypeInfo)
 :
  TRegistration
 <
 T
 >;
  overload
 ;
  
 function
  InjectField
 (
 const
  fieldName
 :
  string
 )
 :
  TRegistration
 <
 T
 >;
  overload
 ;
  
 These methods allow you to inject (duh) different items into your classes and automatically 
 instantiate them as a result. And when you inject something directly with them, the 
 Container becomes smart enough to create them for you automatically, even without the 
 psuedo-Create call that is
  ServiceLocator
 .
  
 We’ve discussed how you should be using Constructor Injection (and possibly Setter 
 Injection) as often as you can, and how you need to push the creation of your component 
 graph all the way back to the composite root. In Delphi, that means all the way back to the 
 first line of the DPR file. And if you do that, you could end up with this monster constructor 
 that requires every single class your application needs. Think about it – every class 
 dependency, with its constructors passing in dependencies for its dependencies, and so on, 
 and you could end up with a royal mess back at the very root of the problem.
  
 But remember, every time you use one of the five above methods, you eliminate the need 
 for a call to the
  ServiceLocator
 . Thus, it stands to reason that they can be used to cause the 
 creation of",NA
12.7 Dependency Injection Summary,"Do’s.
  
 1. Do program against interfaces, not implementations.
  
 2. Do keep constructors simple – assignments only and no logic.
  
 3. Do use constructor injection everywhere you can.
  
 4. Do use a container to do all your creating.
  
 5. Do give a name to all your implementation registrations.
  
 6. Do use injection methods and attributes to hook up all your dependencies.
  
 Dont’s:
  
 1. Don’t mix UI code and business logic 
  
 2. Don’t use event handlers for anything other than displaying data and changing the UI. 
 Don’t put business logic in your UI event handlers.
  
 3. Don’t create anything except known, proven RTL classes and the like.
  
 4. Don’t use the Service Locator anywhere except at the very root of your application.
  
 [1] http://en.wikipedia.org/wiki/Anti-pattern",NA
13 Unit Testing,"Am I suggesting 100% test coverage? No, I’m demanding it. Every single line of 
 code that you write should be tested. Period.
  
 I don’t want management to mandate 100% test coverage. I want your conscience 
 to mandate it as a point of honor.
  
 How about: if you have 100%, you can refactor savagely whenever you want with 
 confidence.
  
 I took the above quotes from a Twitter conversation that
  Uncle Bob Martin¹
  had with some 
 of his followers. He is pretty passionate about code coverage and unit testing. We all might 
 not be quite as serious as Uncle Bob, but we all definitely should be at least a little 
 passionate about unit testing.
  
 And that passion should stem from a desire to write good code. I’m going to make the case 
 that the only way you can call your code “good” is if it is fully unit tested. If you write and 
 deliver code that isn’t completely unit tested, you should feel like you are walking down the 
 street naked. You should feel exposed and like everyone is looking at you. You should 
 believe firmly that your code will fail miserably unless it is completely covered by unit 
 tests.",NA
13.1 So What is Unit Testing?,"Unit testing is the testing of code to ensure that it performs the task that it is meant to 
 perform. It tests code at the very lowest level possible – the individual methods of your 
 classes. It is the key to writing clean, maintainable code. If you concentrate on writing code 
 that is easily testable, you can’t help but end up with decoupled, clean, high-quality code 
 that is easy to maintain. What’s not to like?
  
 But sometimes there are questions over the definition of terms when it comes to unit 
 testing. For instance, what, exactly, is a “unit”? What does “mocking” mean? How do I know 
 whether I actually am doing unit testing? In this chapter, we’ll cover what these terms all 
 mean, and then we’ll take a look at a simple example that illustrates the way to go about 
 writing tests and code together.
  
 ¹
 https://twitter.com/unclebobmartin",NA
What is a “Unit”?,"The first question that comes up when discussing unit testing is, well, what is a unit? You 
 can’t do unit testing without knowing what a unit is.
  
 When it comes to unit testing, I view a “unit” as any discreet module of code that can be 
 tested in isolation. It can be something as simple as a stand-alone routine (think
  
 StringReplace
  or
  IncMonth
 ), but normally it will be a single class and its methods. A class is the 
 basic, discrete code entity of modern languages. In Delphi, classes (and records which are 
 conceptually very similar) are the base building blocks of your code. They are the data 
 structures that, when used together, form a system.
  
 In the world of unit testing, that class is generally referred to as the “Class Under Test 
 (CUT)” or the “System Under Test (SUT).” You’ll see those terms used extensively – to the 
 point where it is strongly recommended that you use CUT as the variable name for your 
 classes being tested.
  
 Definition
 : A unit is any code entity that can be tested in isolation, usually a class.",NA
Am I Actually Doing Unit Testing?,"So when you are doing unit testing, you are generally testing classes (And for the sake of 
 the discussion, that will be the assumption hereafter.). But the key thing to note is that 
 when unit testing a class, you are unit testing the given class and only the given class. Unit 
 testing is always done in isolation – that is, the class under test needs to be completely 
 isolated from any other classes or any other systems. If you are testing a class and you need 
 some external entity, then you are no longer unit testing. A class is only “testable” when it’s 
 dependencies can be and are “faked” and thus tested without any of its real external 
 dependencies. So if you are running what you think is a unit test, and that test needs to 
 access a database, a file system, or any other external system, then you have stopped doing 
 unit testing and you’ve started doing integration testing.
  
 One thing I want to be clear about: There’s no shame in doing integration testing. 
 Integration testing is really important and should be done. Unit testing frameworks are 
 often a very good way to do integration testing. I don’t want to leave you with the 
 impression that because integration is not unit testing, you shouldn’t be doing it – quite the 
 contrary. Nevertheless, it is an important distinction. The point here is to recognize what 
 unit tests are and to strive to write them when it is intended to write them. By all means, 
 write integration tests, but don’t write them in lieu of unit testing.
  
 Think of it this way: Every unit test framework – DUnit and DUnitX included – creates a test 
 executable. If you can’t take that test executable and run it successfully on your mother’s 
 computer in a directory that is read only, then you aren’t unit testing anymore.
  
 Definition
 : Unit testing is the act of testing a single class in isolation, completely 
 apart from any of its actual dependencies.",NA
What is an Isolation Framework?,"Commonly, developers have used the term “mocking framework” to describe code that 
 provides faking services to allow classes to be tested in isolation. However, as we’ll see 
 below (and discuss more fully in the next chapter), a “mock” is actually a specific kind of 
 fake class, along with stubs. Thus, it is probably more accurate to use the term “Isolation 
 Framework” instead of “Mocking Framework.” A good isolation framework will allow for 
 the easy creation of both types of fakes– mocks and stubs.
  
 Fakes allow you to test a class in isolation by providing implementations of dependencies 
 without requiring the real dependencies.
  
 Definition
 : An isolation framework is a collection of code that enables the easy 
 creation of fakes.
  
 Definition
 : A Fake Class is any class that provides functionality sufficient to 
 pretend that it is a dependency needed by a class under test. There are two kind 
 of fakes – stubs and mocks.
  
 If you really want to learn about this stuff in depth, I strongly recommend you read
  “The 
 Art of Unit Testing: With Examples in .Net” by Roy Osherove²
 . For you Delphi guys, don’t be 
 scared off by the C# examples – this book is a great treatise on unit testing and gives plenty 
 of descriptions, proper techniques, and definitions of unit testing in far more detail than 
 I’ve done here. Or you can listen to 
 Roy talk to Scott Hanselman on the Hanselminutes 
 podcast³
 . If you really want to get super geeky, get a hold of a copy of
  “xUnit Test Patterns: 
 Refactoring Test Code” by Gerard Meszaros⁴
 . This heavy tome is a tour de force of unit 
 testing, outlining a complete taxonomy of tests and testing patterns. It’s not for the faint of 
 heart, but if you read that book, you’ll know everything there is to know and then some.
  
 Stubs
  
 A stub is a class that does the absolute minimum to appear to be an actual dependency for 
 the Class Under Test. It provides no functionality required by the test, except to appear to 
 implement a given interface or descend from a given base class. When the CUT calls it, a 
 stub usually does nothing. Stubs are completely peripheral to testing the CUT, and exist 
 purely to enable the CUT to run. A typical example is a stub that provides logging services. 
 The CUT may need an implementation of, say,
  ILogger
  in order to execute, but none of the 
 tests care about the logging. In fact, you specifically don’t want the CUT logging anything. 
 Thus, the stub pretends to be the logging service
  
  
 ²
 http://www.amazon.com/gp/product/1617290890/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&cr
 eativeASIN= 1617290890&linkCode=as2&tag=nickhodgeshomepa
  
  
 ³
 http://hanselminutes.com/169/the-art-of-unit-testing-with-roy-osherove
  
  
 ⁴
 http://www.amazon.com/gp/product/0131495054/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&cr
 eativeASIN= 0131495054&linkCode=as2&tag=nickhodgeshomepa",NA
13.2 Why Do Unit Testing?,"I find that there is a lot of resistance to doing unit testing. Many developers seem to view it 
 as a waste of time or as effort that will merely delay the completion of a project under 
 deadline. They feel that they can’t get any benefit from it. I couldn’t disagree more. Here’s 
 why.",NA
Unit Testing will find bugs,"Whether you do Test Driven Development and write your tests first, write your tests as you 
 go along, or write tests long after the code as been written, unit testing will find bugs. When 
 you write a full suite of tests that define what the expected behavior is for a given class, 
 anything in that class that isn’t behaving as expected will be revealed.",NA
Unit Testing will keep bugs away,"A complete and thorough suite of unit tests will help to ensure that any bugs that creep into 
 your code will be revealed immediately. Make a change that introduces a bug, and your 
 tests can reveal it the very next time you run your tests. If you find a bug that is outside the 
 realm of your unit test suite and you can write a test for it to ensure that the bug never 
 returns.",NA
Unit Testing saves time,"This is the most controversial notion about unit testing. Most developers believe that 
 writing unit tests takes more time than it saves. I don’t believe this - in fact, I argue the 
 opposite. Writing unit tests helps ensure that your code is working as designed right from 
 the start. Unit tests define what your code should do, and thus you won’t spend time 
 writing code that does things that it shouldn’t do. Every unit test becomes a regression test, 
 ensuring that things continue to work as designed while you develop. They help ensure 
 that subsequent changes don’t break things. They help ensure that what you write the first 
 time is the right thing. All of these benefits save time both in the short and the long term.
  
 And if you think about it, you already test your code while you are writing it. Maybe you 
 write a simple console app. At the very least you compile and see it running. No one checks 
 in code that they don’t believe works, and you have to do
  something
  to make yourself think 
 that it works. Spend that time writing unit tests, and you’ll have decoupled working coding 
 with a suite of regression tests.",NA
Unit Testing gives peace of mind,"Having a full, complete, and thorough set of tests that cover the complete functionality of 
 your code might be difficult to achieve, but having it will give you peace of mind. You can 
 run all those tests and know that your code works as it is supposed to. You can refactor and 
 change the code knowing that if you break anything, you’ll know right away. Knowing the 
 state of your code, that it works, and that you can update and improve it without fear is a 
 very good thing.
  
 All code ages, but you can keep your code from ever truly becoming legacy code. There are 
 a number of ways to define legacy code, but one way is “Code you are afraid to touch”. If 
 your code has unit tests, it is really hard for it to become legacy code. Many of us have that 
 chunk of code that we are afraid to touch – but with unit testing, you’ll not have that kind of 
 code. Unit testing removes that fear of touching code. In “
 Working Effectively with Legacy 
 Code⁷
 ,” Michael Feathers goes so far as to define legacy code as any code that doesn’t have 
 unit tests. Want to avoid your code becoming legacy code? Write unit tests for it.",NA
Unit Testing documents the proper use of a class,"One of the benefits of unit testing is that your tests can define for subsequent developers 
 how the class should be used. Unit tests become, in effect, simple examples of how your 
 code works, what it is expected to do, and the proper way to use the code being tested. 
 Consumers of your code can look to your unit tests for information about the proper way to 
 make your code do what it is supposed to do.
  
  
 ⁷
 http://www.amazon.com/gp/product/0131177052/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&cr
 eativeASIN= 0131177052&linkCode=as2&tag=nickhodgeshomepa”",NA
13.3 Unit Testing in Delphi,"For many years, the main unit testing framework has been
  DUnit⁸
 . Based on the original 
 Delphi RTTI, it’s been the mainstay of Delphi unit testing for a decade or more. DUnit is a 
 complete xUnit testing solution, but while venerable and well-used, it is at this point 
 somewhat outdated.
  
 Recently a new framework has appeared called
  DUnitX⁹
 . DUnitX leverages attributes and 
 Delphi’s new RTTI to make test classes and methods more flexible and easy to manage. As 
 of this writing, DUnitX is quite usable but still under development.
  
 I’ll be discussing both here in the book. First, I’ll give a basic overview of each and how they 
 work, and then I’ll be mixing in examples of each as we go along.",NA
DUnit,"DUnit was originally published in the late 1990s and was written by Juanco Añez. He 
 followed the original pattern set forth for all xUnit frameworks defined by
  Kent Beck¹⁰
 .
  
 DUnit is an open source project that can be found on SourceForge. ¹¹
  
 Starting with Delphi 2005, DUnit has shipped with RAD Studio and has been integrated into 
 the IDE. Developers can use the IDE expert to automatically generate test cases for a given 
 Delphi unit.
  
 DUnit is based on the “old” RTTI built into Delphi. Tests are based on a class called
  
 TTestCase
 . To use
  TTestCase
 , you create a descendant class and add published methods as 
 tests. The framework then uses RTTI to find all the published methods and execute them.
  
 Testing is done using a set of overloaded functions that start with
  CheckXXX
 , such as
  
 CheckEquals 
 or
  CheckNotEquals
 . They take as parameters an expected value, an actual value, 
 and an optional message parameter that lets you provide information for output in the 
 event of a test failure. The 
 Check
  calls raise an internal exception if the test fails, and in this 
 way tests can be tracked as passing or failing.
  TTestCase
  also included virtual methods called
  
 Setup
  and
  TearDown
  that allow you to do as their names say – setup things for testing and 
 then “tear down” anything you created in
  Setup
 . 
 Setup
  and
  TearDown
  are run once for every 
 test, allowing you to ensure that each test is run with a“clean slate.”",NA
DUnitX,"DUnitX, on the other hand, utilized the new RTTI to allow any class you want to contain 
 tests. Using the
  [TestFixture]
  attribute on a class allows it to contain methods that are tests. 
 Any method on such a class can be labeled as a test by attaching the attribute
  [Test]
  to it. 
 Setup and tear down is done by decorating any method with
  [Setup]
  and
  [TearDown]
  
 attributes. In addition, the framework
  
 ⁸
 http://dunit.sourceforge.net/
  
 ⁹
 https://github.com/VSoftTechnologies/DU",NA
13.4 General Rules for Unit Tests,NA,NA
Test one thing at a time in isolation.,"This is probably the baseline rule to follow when it comes to unit tests. All classes should be 
 tested in isolation. They should not depend on anything other than mocks and stubs. They 
 shouldn’t depend on the results of other tests. They should be able to run on any machine. 
 You should be able to take your unit test executable and run it on your mother’s machine 
 while it isn’t even connected to the Internet.
  
 Follow the AAA rule: Arrange, Act, Assert
  
 When it comes to unit testing, AAA stands for “Arrange, Act, Assert”. It is a general pattern 
 for writing individual tests to make them more readable and effective. First, you “Arrange.” 
 In this step, you set things up to be tested. You set variables, fields and properties to enable 
 the test to be run, as well as define the expected result. Then you “Act” – that is, you actually 
 call the method that you are testing. Finally, you “Assert” – call the testing framework to 
 verify that the result of your “Act”is what was expected. Follow the AAA principle, and your 
 test will be clear and easy to read.
  
 Here’s an example of a test that follows the AAA rule:
  
 procedure
  TDateUtilsOfTests
 .
 TestDateOf
 ;
  
 var
  
 Expected
 :
  TDateTime
 ;
  
 Actual
 :
  TDateTime
 ;
  
 Input
 :
  TDateTime
 ;
  
 begin
  
 //Arrange
  
 Input
  :=
  EncodeDateTime(
 1944, 1, 2, 3, 4, 5, 6
 )
 ;
  
 Expected
  :=
  EncodeDate
 (
 1944, 1, 2
 )
 ;
  
 //Act
  
 Actual
  :=
  DateOf(Input)
 ;
  
 // Assert
  
 Assert
 .
 AreEqual(Expected
 ,
  Actual)
 ;
  
 end
 ;",NA
"Write simple, “right down the middle” tests first","The first tests you write should be the simplest tests – the “happy path,” They should be the 
 ones that easily and basically illustrate the functionality you are trying to write. If you are 
 writing an addition algorithm, the early tests that you write should make sure that your 
 code can do 2 + 2 = 4. Then, once those tests pass, you should start writing the more 
 complicated tests (as discussed below) that test the edges and boundaries of your code.",NA
Write tests that test the edges,"Once the basics are tested and you know that your basic functionality works, you should 
 test “the edges.” That is, you should test what happens if an overflow occurs. What if values 
 go to zero or below zero? What if they go to
  MaxInt
 ?
  MinInt
 ? If you doing something with 
 geometry, what if you try to create an arc of 361 degrees? What happens if you pass in an 
 empty string? A string that is 2GB in size? A good set of tests will explore the outer edges of 
 what might happen to a given method.",NA
Test across boundaries,"Unit tests should test both sides of a given boundary. If you are building some tests for
  
 TDateTime
 , try testing one second before midnight and one second after. Test across the date 
 value of
  0.0
 . If you are dealing with a structure that holds a rectangle, then test what 
 happens to points inside and outside the rectangle. What about above or below? To the left 
 or right? Above and to the right? Below and to the left? Moving across boundaries are 
 places where your code might fail or perform in unpredictable ways.",NA
"If you can, test the entire spectrum","If it is practical, test the entire set of possibilities for your functionality. If it involves an 
 enumerated type, test the functionality with every one of the items in the enumeration. It 
 might be impractical to test every possible string or every integer, but if you can test every 
 possibility, do it.",NA
"If possible, cover every code path","This one is challenging as well, but if your code is designed for testing, and you make use of 
 a code coverage tool, you can ensure that every line of your code is covered by unit tests at 
 least once. Delphi has
  a very good code coverage tool available for your use¹³
 . Use it in 
 concert with your unit tests. Covering every code path won’t guarantee that there aren’t 
 any bugs, but it surely gives you valuable information about the state of every line of code.
  
 ¹³
 https://code.google.com/p/delphi-code-coverage/",NA
"Write tests that reveal a bug, then fix it","This is a powerful and useful technique. If you find a bug, write a test that reveals it. Then, 
 you can easily fix the bug by debugging the test. Then you have a nice regression test to 
 make sure that if that bug comes back for any reason, you’ll know right away. It’s really 
 easy to fix a bug when you have a simple, straightforward test to run in the debugger.
  
 A side benefit here is that you’ve “tested your test.” Because you’ve seen the test fail and 
 then have seen it pass, you know that the test is valid in that it has proven to work 
 correctly. This makes it an even better regression test.",NA
Make each test independent of each other,"Tests should never depend on each other. If your tests have to be run in a certain order, 
 then you need to change your tests. Instead, you should make proper use of the Setup and 
 TearDown features of your unit testing framework to ensure each test is ready to run 
 individually. Unit tests frameworks don’t guarantee that tests are going to be run in any 
 particular order, and if your tests depend on tests running in a specific order, then you may 
 find yourself with some subtle, hard to track down bugs in your tests themselves. Make 
 sure each test stands alone, and you won’t have this problem.",NA
Write one assert per test,"You should write one assert per test. If you can’t do that, then refactor your tests so that 
 your SetUp and TearDown events are used to correctly create the environment so that each 
 test can be run individually. If your tests require elaborate setup and you feel the need to 
 run multiple tests and call
  Check/Assert
  multiple times, then you need to create a new test 
 case class and utilize its 
 Setup/TearDown
  feature for that particular test case, enabling you to 
 create multiple tests for the specific situation.",NA
Name your tests clearly. Don’t be afraid of long names.,"Since you are doing one assert per test, each test can end up being very specific. Thus, don’t be afraid 
  
 to use a long, complete test name. It is better to have
  TestDivisionWhenNumeratorPositiveDenominatorNegative 
 than
  DivisionTest3
 . A long complete name lets you know immediately what test failed and what 
  
 exactly what the test was trying to do. Long, clearly named tests also can document your tests. For 
  
 example, a test named “DivisionByZeroShouldThrowException” documents exactly what the code 
  
 does when you try to divide by 0.",NA
Test that every raised exception is in fact raised.,"If your code raises exceptions, then write tests to ensure that every exception you raise in 
 fact gets raised when it is supposed to. Both DUnit and DUnitX have the ability to test for an 
 exception being raised, so you should use that feature to ensure that every exception your 
 code raises is indeed raised under the proper circumstances.",NA
Avoid the use of CheckTrue or Assert.IsTrue,"Avoid checking for a Boolean condition. For instance, instead of checking if two things are 
 equal with CheckTrue or Assert.IsTrue, use CheckEquals or Assert.AreEqual instead. Why? 
 Because this:
  
 CheckTrue(Expected
 ,
  Actual)
  
 will report something like “
 Some test failed: Expected True but actual result was False
 ”. That 
 doesn’t tell you anything. Instead, use CheckEquals:
  
 CheckEquals(Expected
 ,
  Actual)
  
 which will tell you the actual values involved, such as “
 Some test failed: Expected 7 but 
 actual result was 3
 .”",NA
Constantly run your tests,"Run your tests while you are writing code. Your tests should run fast, enabling you to run 
 them after even minor changes. If you can’t run your tests as part of your normal 
 development process then something is going wrong – unit tests are supposed to run 
 almost instantly. If they aren’t, it’s probably because you aren’t running them in isolation.",NA
Run your tests as part of every automated build.,"Just as you should be running your tests as you develop, they should also be an integral 
 part of your continuous integration process. A failed test should mean that your build is 
 broken. Don’t let a failing test linger – consider it a build failure and fix it immediately.",NA
13.5 Test Driven Development,"Probably the most controversial facet of unit testing is the question “When should I write 
 my tests?”This question is controversial because the rise of unit testing coincided with the 
 rise of the notion of Test Driven Development, or TDD. TDD says that you should write unit 
 tests first, before anything else, and that your tests should drive your code and your design.
  
 Some people object to TDD because they say that adding the writing of tests will add time 
 to the project and make it either late or longer. Proponents say that the time spent up front 
 will save more time in the long run because your code will work right the first time and 
 you’ll have a set of tests to prove it. I’m not here to settle this debate or even to engage",NA
13.6 A Basic Example,"So far all we’ve had is a lot of theory, so how about a little practice?
  
 Let’s say we have a requirement to write a class that does basic mathematical actions. It 
 needs to add, subtract, multiply, divide, and provide a Power function (that is, x raised to 
 the y). For simplicity’s sake, we’ll assume all the math will be done with integers.
  
 And here’s what we are going to do:
  
 1. Write a test
  
 2. Write code until the application compiles but the test fails
  
 ¹⁴
 http://www.amazon.com/gp/product/0321146530/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&creat
 iveASIN= 0321146530&linkCode=as2&tag=nickhodgeshomepa
  
 ¹⁵
 http://en.wikipedia.org/wiki/Code_smell",NA
14 Testing with an ,NA,NA
Isolation ,NA,NA
Framework,"In the previous chapter, we looked at the whys and hows of unit testing. We went through a 
 very simple example of how to do Test Driven Development. But as I mentioned at the close 
 of the chapter, it was simple – too simple, in fact for real world use.
  
 In previous chapters, I have stressed many things, but particularly the notion of testing 
 your code in isolation, and the decoupling of your code via Dependency Injection. So now, 
 it’s time for it all to come together. The proper use of Dependency Injection should make 
 testing your classes in isolation a piece of cake. I exhorted you to create a testing executable 
 that could run on any machine without any specific dependencies present. But if you are 
 going to do that, you’ll have to substitute your actual dependencies with ones that don’t 
 actually couple to anything “real”. If only there were a way to do that simply and easily.
  
 Hah – by now you should know that I drop the “If only” on you, there will be a way to do 
 that: in this case, it’s Isolation Frameworks. We discussed them a bit in the last chapter, 
 talking about the difference between Stubs and Mocks and how you can use them to test 
 your classes in isolation. I promised that in this chapter we’d dive deeper into unit testing 
 by showing how to use fakes – that is, stubs and mocks – to be able to test almost any code 
 with any dependencies.",NA
14.1 A Quick Review,"Okay, first, let’s do a quick review. First, an isolation framework is a set of classes that 
 enables you to provide fake dependencies for your classes. There are two kinds of fakes – 
 stubs and mocks. Stubs do nothing other than the very minimum to replace their real 
 counterpart. A test success or failure won’t depend on a stub, and generally, a stub will do 
 nothing. A test should never fail because of a stub. A mock, however, is a fake 
 representation that can and should provide feedback and information to a given test. In 
 fact, the reason to use a mock instead of a stub is to interact with the Class Under Test and 
 provide the ability to fail the test. That is the big distinction between a mock and a stub: a 
 mock can fail a test where a stub never should.",NA
14.2 Isolation Frameworks for Delphi,"While there were mocking frameworks for Delphi before the introduction of virtual 
 interfaces and generics, a true and complete isolation framework really wasn’t available 
 until XE2.
  The Delphi",NA
14.3 Getting Started,"In their simplest form, a fake object is an alternate implementation of a class that provides 
 “fake”responses to method calls. For example, you have an interface
  ICustomer
  that has a 
 method 
 GetCustomerName
 , and normally, that call goes to the production database and gets 
 the name (a simple, unlikely example, I know, but you get the idea). So to avoid the call to 
 the database, you just create
  MockCustomer
  and implement its call to
  GetCustomerName
  and 
 have it return “George Jetson” every time. This enables you to test the class that is using
  
 ICustomer
  without having to hit the database at all.
  
 But that can get a bit clumsy. What if you want to return different values based on different 
 inputs? What if you find a bug based on specific input or output, and you want to create a 
 unit test for that specific case? What if you don’t want to return anything at all because you 
 are testing something different, but need to call to
  GetCustomerName
 ? Then a specially 
 created fake class as described above gets harried, complicated, and hard to maintain.",NA
Enter an Isolation Framework,"What if we could have a framework that would allow us to implement any interface and 
 define easily and exactly what the inputs and outputs should be? That would be cool. This 
 would enable you to easily create a fake object that can respond to method calls in defined 
 ways in a flexible, easy to set up manner. This is what an isolation framework does.
  
 Obviously something this flexible needs some powerful language features. Such a 
 framework would have to be able to flex to dynamically implement an interface. It would 
 have to be able to dynamically recognize method calls and respond accordingly. 
 Fortunately, as of XE2, Delphi is up to the task. As we saw in a previous chapter, Delphi XE2 
 introduced the
  TVirtualInterface
  class that lets you dynamically implement any interface at 
 run-time. Combine that with the new RTTI, and you have the ability to build a very 
 powerful mocking framework.",NA
A Simple Stub,"The Delphi Mocks Framework can easily create a simple stub for you to use to stub out a 
 dependency that you don’t need for a given test. For instance, say you had a class as follows:
  
 ¹
 https://github.com/VSoftTechnologies/Delphi-
 Mocks",NA
Testing the Logger,"Now you’ve written tests to ensure that the currency converter works as it should. But you 
 still have something else to test – that is, does the logger actually do what it is supposed to 
 do when you make a conversion? You expect (remember that word) that the logger will",NA
Stubs That Do Stuff,"Sometimes in the process of testing you need your stub to return a value from a function 
 call. As your tests run, you know that your CUT will be calling a function on your stub, and 
 you want it to behave in a predetermined way. No problem – Delphi Mocks allows you to 
 tell your stubs to return values of functions. Instead of calling
  Expect
 , you can call
  WillReturn
 , 
 passing to it an expected value as well as the actual method call with parameters via the
  
 When
  method.
  
 Consider the following interface and implementing class:
  
 unit
  uCreditCardValidator
 ;
  
 interface
  
 uses
  
 SysUtils
 ;
  
 type
  
 ICreditCardValidator
  =
  interface
 (IInvokable)
  
 [
 '{68553321-248C-4FD4-9881-C6B6B92B95AD}'
 ]
  
 function
  IsCreditCardValid
 (aCreditCardNumber
 :
  string
 )
 :
  Boolean
 ;
  
 procedure
  DoNotCallThisEver
 ;
  
 end
 ;
  
 TCreditCardValidator
  =
  class
 (TInterfacedObject
 ,
  ICreditCardValidator)
  
 function
  IsCreditCardValid
 (aCreditCardNumber
 :
  string
 )
 :
  Boolean
 ;
  
 procedure
  DoNotCallThisEver
 ;
  
 end
 ;",NA
Dependencies that Do Expected Things,"Stubs are fakes that do nothing, or at least don’t do anything that can cause the test to fail. 
 In fact, a Stub might be defined as a fake for which you have no declared expectations. 
 Mocks, on the other hand, are fakes that do cause tests to fail and which do have declared 
 expectations. Often the reason for that failure is that your class under test interacts with a 
 dependency in an unexpected way.",NA
Dependencies That Raise Exceptions,"Often, your dependencies will raise exceptions, and you need to ensure that your testing 
 class handles that properly. Here’s an interface and an implementing class that raises an 
 exception when you try to validate a bad widget. In this case, we need a Mock, because we 
 want to let the test pass or fail depending on whether or not the dependency raises the 
 exception as expected. Basically, any time you are using a fake and you can call the
  Verify
  
 method, you are using a mock.
  
 So for example, consider this unit:
  
 unit
  uDependencyRaisesObjection
 ;
  
 interface
  
 uses 
  
  
  
 SysUtils 
  
  
 ;
  
 type 
  
 IWidget
  =
  interface
 (IInvokable) 
  
   
 function
  IsValid
 :
  Boolean
 ; 
  
 end
 ;
  
 TWidget
  =
  class
 (TInterfacedObject
 ,
  IWidget) 
 public 
  
  
 function
  IsValid
 :
  Boolean
 ; 
  
 end
 ;
  
 IWidgetProcessor
  =
  interface
 (IInvokable) 
  
 procedure
  ProcessWidget
 (aWidget
 :
  IWidget)
 ; 
 end
 ;
  
 TWidgetProcessor
  =
  class
 (TInterfacedObject
 ,
  IWidgetProcessor) 
 public 
  
  
 procedure
  ProcessWidget
 (aWidget
 :
  IWidget)
 ; 
  
 end
 ;
  
 EInvalidWidgetException
  =
  class
 (Exception)
 ;
  
 implementation
  
 procedure
  TWidgetProcessor
 .
 ProcessWidget
 (aWidget
 :
  IWidget)
 ; 
 begin",NA
Only One Mock Per Test,"A given test should only ever have one mock per test. For instance, if you have a class that 
 has three dependencies, you should always test that class with zero or one mocks and three 
 or two stubs. You should never have two mocks because then you’d have two different 
 ways for the tests to fail. Having only one mock means that the test can only fail one way. 
 No matter how many dependencies you have, only one of them should be a Mock, and the 
 rest should be stubs",NA
Expectation Parameters Must Match,"When you set an expectation and make a call to the interface, you must pass in parameters. 
 Those parameters must then be used exactly as “expected” because if they are not, the 
 Mock won’t properly verify. In other words, those parameter values are expected just as 
 much as the behavior itself. So for instance, if you set the following expectation
  
 SomeMock
 .
 Setup
 .
 Expect
 .
 Once
 .
 When
 .
 Add(
 5, 9
 )
 ;
  
 then that expectation will not be met if you call the actual test with
  
 MyAdder
 .
 Add(
 4, 3
 )
 ;",NA
14.4 Conclusion,"That should give you a good overview of Isolation Frameworks. Isolation Frameworks exist 
 to allow you to test your classes in isolation. If you’ve used proper Dependency Injection, 
 then testing your classes in isolation along with an Isolation Framework should be very 
 easy. Stubs allow you to test classes by providing expectation-less fake classes and 
 interfaces. Mocks allow you to test your class’s interaction with its dependencies by 
 providing numerous ways to verify that your Class Under Test behaved as expected when 
 tested – all without having to create real dependencies.",NA
Appendix A: Resources,NA,NA
Dependency Injection,"• The best book on Dependency Injection is
  Dependency Injection in .Net by Mark 
 Seamann³
 . The examples are all in C#, but don’t be put off by that – it’s an excellent, 
 in-depth resource on a topic that I was only able to cover briefly.
  
 •
  Mark’s website⁴
  is also a great source of Dependency Injection information, Unit 
 Testing, and general, all around techniques for writing good code.",NA
Unit Testing,"• The book I recommend on unit testing is
  “The Art of Unit Testing: With Examples in 
 .NET”⁵
 by Roy Osherove. Again, the examples are in C#, but that’s of little matter. 
 What is important is the thorough, clear descriptions that Roy gives of all aspects of 
 unit testing.
  
 • The seminal book for Test Driven Development is entitled – surprise! –
  “Test Driven 
 Development: By Example”⁶
  by Kent Beck. He pretty much originated the idea and the 
 term.
  
 • Another book to consider is the reference book entitled
  “xUnit Test Patterns.”⁷
  This is 
 a deep and thorough book on the topic of testing patterns. Seriously, it’s a big, deep 
 book. Really cool, though.
  
 • Misko Hevery is a Google employee who writes extensively about writing testable 
 code.
  You can read his blog⁸
  as well as watch the three videos below to see what 
 Misko has to say on the subject of testing and testable code.
  
 •
  The Clean Code Talks: Don’t Look for Things⁹
  
 •
  How to Write Clean, Testable Code¹⁰
  
 •
  The Clean Code Talks – Unit Testing¹¹
  
  
  
 ³
 http://www.amazon.com/gp/product/1935182501/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&cre
 ativeASIN= 1935182501&linkCode=as2&tag=nickhodgeshomepa
  
  
  
 ⁴
 http://blog.ploeh.dk/
  
  
  
 ⁵
 http://www.amazon.com/gp/product/1617290890/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&cre
 ativeASIN= 1617290890&linkCode=as2&tag=nickhodgeshomepa
  
  
  
 ⁶
 http://www.amazon.com/gp/product/0321146530/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&cre
 ativeASIN= 0321146530&linkCode=as2&tag=nickhodgeshomepa
  
  
  
 ⁷
 http://www.amazon.com/gp/product/0131495054/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&cre
 ativeASIN= 0131495054&linkCode=as2&tag=nickhodgeshomepa
  
  
  
 ⁸
 http://misko.hevery.com/",NA
Source Control,"Most of the frameworks I recommend in the book are obtained via public source control 
 repositories. Here are some links to get you started if you aren’t familiar with Git, Mercurial, 
 or Subversion.",NA
Subversion,NA,NA
Git,"• A nice, step-by-step tutorial that teaches Git Basics:
  
 http://gitimmersion.com/¹²
 • An excellent, online book teaching Git:
  
 http://git-scm.com/book/en/¹³",NA
Mercurial,"• A simple and well-done tutorial for Mercurial is
  hginit.com¹⁴
 . It’s specifically designed 
 for people moving to a distributed source control system from a server-based world.
  
 • The Mercurial team has a nice tutorial:
  http://mercurial.selenic.com/wiki/Tutorial¹⁵",NA
Projects,"• The Delphi Spring Framework:
  https://code.google.com/p/delphi-spring-
 framework/¹⁶
 • The DUnitX Framework:
  
 https://github.com/VSoftTechnologies/DUnitX¹⁷
  
 • The Delphi Sorcery Framework:
  https://code.google.com/p/delphisorcery/¹⁸
  
 • The Delphi Mocks Framework:
  https://github.com/VSoftTechnologies/Delphi-
 Mocks¹⁹
 • The OmniThread Library:
  
 https://code.google.com/p/omnithreadlibrary/²⁰",NA
General Good Stuff,"• Mason Wheeler has an excellent discussion on Contravariance and Covariance:
  
 http://tech.turbu-rpg.com/149/generics-and-the-covariance-problem ²¹
  
 • Barry Kelly on closures and anonymous methods:
  
 http://blog.barrkel.com/2008/07/anonymous-method-details.html²²
  
 ¹²
 http://gitimmersion.com/
  
 ¹³
 http://git-scm.com/book/en/
  
 ¹⁴
 http://hginit.com
  
 ¹⁵
 http://mercurial.selenic.com/wiki/Tutorial
  
 ¹⁶
 https://code.google.com/p/delphi-spring-framework/
  
 ¹⁷
 https://github.com/VSoftTechnologies/DUnitX
  
 ¹⁸
 https://code.google.com/p/delphisorcery/
  
 ¹⁹
 https://github.com/VSoftTechnologies/Delphi-Mocks
  
 ²⁰
 https://code.google.com/p/omnithreadlibrary/",NA
Appendix B: My Delphi Story,"In 1991, I was a newly-married, Lieutenant (jg) in the United States Navy. I had just come 
 off of an overseas tour of ship duty. Life had slowed down considerably for me in my new 
 job, and I was looking for a hobby. A friend of mine was talking about how he had written a 
 flight and training scheduling application when he was in flight training, and that he’d used 
 Turbo Pascal to do it. I was intrigued.
  
 In the early 70’s I had been taught BASIC in my Seventh Grade math class. You know:
  
 200
  REM
  ***
  MAKE A RANDOM LIST A(
 1
 ) TO A(N)
  
 210
  A(
 1
 )
 =
 INT((N
 -1
 )
 *
 RND(
 1
 )
 +2
 )
  
 220
  FOR K
 =2
  TO N
  
 230
  A(K)
 =
 INT(N
 *
 RND(
 1
 )
 +1
 )
  
 240
  FOR J
 =1
  TO K
 -1
  
 250
  IF A(K)
 =
 A(J) THEN
  230
  
 260
  NEXT J
 :
 NEXT K
  
 etc. It was fun, and a couple of my friends and I actually built crude adventure games using 
 it: “You are walking down the street and a bum asks you for a quarter: Do you…..” We typed 
 the programs in on punch hole tape, and ran it through on a teletype that was hooked to a 
 computer at the University of Minnesota via one of those modems where you press the 
 phone into the rubber cups. Wild to think about now.
  
 I kept programming after school and ended up being a “Computer Rat” in tenth grade – the 
 guy that would take everyone’s punch cards and run them through the reader and then 
 return them with the printout results. About that same time I finally discovered these 
 strange things called “girls” and soon realized that these creatures didn’t think much of 
 computer rats, so my early programming career ended. Alas – had I stuck with it I might 
 have ended up rich in Silicon Valley – my timing would have been perfect. But it was not to 
 be.
  
 When that Navy friend handed me a copy of Tom Swan’s Programming Turbo Pascal 5.5 
 and a –ahem – copy of Turbo Pascal 5.5 on a floppy, I dove in with abandon. Hey, I was 
 already married, so it was a perfect way to expand the brain and build something. It took 
 me a while to understand how you could program without line numbers, but I got the hang 
 of it. My first purchase was Turbo Pascal for (the then brand new) Windows 1.0. I soon 
 upgraded to Turbo Pascal for Windows 1.5 with (gasp) syntax highlighting!
  
 This was the heyday of the PC age – you could use your modem to download shareware 
 from a local bulletin board! Windows 3.0 was just taking off and I was totally into it. I was 
 downloading Windows shareware and trying it out by the bucket load. I was teaching 
 myself Windows programming with",NA
