Larger Text,Smaller Text,Symbol
Expert Delphi,NA,NA
Robust and fast cross-platform application development,NA,NA
Paweł Głowacki,BIRMINGHAM - MUMBAI,NA
Expert Delphi,"Copyright © 2017 Packt Publishing All rights reserved.
  
 No part of this book may be reproduced, stored in a retrieval system, or transmitted in any 
 form or by any means, without the prior written permission of the publisher, except in the 
 case of brief quotations embedded in critical articles or reviews.
  
 Every effort has been made in the preparation of this book to ensure the accuracy of the 
 information presented. However, the information contained in this book is sold without 
 warranty, either express or implied. Neither the author, nor Packt Publishing, and its 
 dealers and distributors will be held liable for any damages caused or alleged to be caused 
 directly or indirectly by this book.
  
 Packt Publishing has endeavored to provide trademark information about all of the 
 companies and products mentioned in this book by the appropriate use of capitals.
  
 However, Packt Publishing cannot guarantee the accuracy of this information.
  
 First published: June 2017
  
 Production reference: 1300617
  
 Published by Packt Publishing Ltd.
  
 Livery Place 
  
 35 Livery Street 
  
 Birmingham 
  
 B3 2PB, UK.
  
 ISBN 978-1-78646-016-5
  
 www.packtpub.com",NA
Credits,"Author 
  
 Copy Editors
  
 Paweł Głowacki 
  
 Safis Editing
  
 Muktikant Garimella
  
 Reviewer 
  
 Project Coordinator
  
 Dave Nottage 
  
 Vaidehi Sawant
  
 Commissioning Editor 
  
 Proofreader
  
 Kunal Parikh 
  
 Safis Editing
  
 Acquisition Editor 
  
 Indexer
  
 Nitin Dasan 
  
 Aishwarya Gangawane
  
 Content Development Editor 
  
 Graphics
  
 Anurag Ghogre 
  
 Abhinash Sahu
  
 Technical Editors 
  
 Madhunikita Sunil Chindarkar 
 Rutuja Vaze
  
 Production Coordinator 
 Shantanu Zagade",NA
Foreword,"I have known and worked with Paweł Głowacki for more than 16 years. Paweł is one of the 
 world-wide Delphi community leading experts. In this book, 
 Expert Delphi
 , Paweł takes you 
 on a learning journey that started in the early 1980s with Compas Pascal, Poly Pascal, and 
 Turbo Pascal. For more than 20 years, Delphi has continued to evolve to meet the needs of 
 developers around the world. During most of this time, Paweł has been a key team member 
 and advocate for the continuous innovation of the compilers, frameworks, runtime library, 
 integrated development environment, and tool chain, allowing developers to easily build 
 applications across desktop, server, mobile, internet, and cloud platforms.
  
 With FireMonkey (FMX), developers can build on top of a modern multiplatform 
 framework based on a rich history of objects, components, and libraries and that has 
 included Turbo Vision, Object Windows, and the VCL. Leveraging these frameworks, 
 libraries, and tools allows developers to create applications for a wide range of 
 architectures, databases, and distributed computing environments.
  
 In his presentations and examples, Paweł shows you how easy it is to create a wide range of 
 applications using SQL/NoSQL databases, XML, and JSON. Paweł also helps developers 
 create multitier applications using the latest technologies, including REST.
  
 As a member of and a leading advocate for the large, global Delphi community and 
 ecosystem, Paweł is uniquely qualified to show you how to become a mobile developer 
 superhero, become a hyper-productive software engineer, and build one source code 
 application that can be compiled to all major mobile platforms and form factors. Paweł also 
 shows you how to build stunning 2D and 3D multidevice graphical user interfaces with the 
 FireMonkey library, providing an outstanding user experience for your application's users.
  
 With 
 Expert Delphi
 , you'll learn the best practices for writing high-quality, reliable, and 
 maintainable code with Delphi's Object Pascal language and component architecture. After 
 you complete Paweł's book, you'll understand how to take full advantage of mobile 
 operating systems, frameworks, and hardware capabilities, including working with sensors 
 and the Internet of Things.",NA
About the Author,"Paweł Głowacki
  is Embarcadero's European Technical Lead for Developer Tools.
  
 Previously, he spent over 7 years working as a senior consultant and trainer for Delphi 
 within Borland Education Services and CodeGear. In addition to working with 
  
 Embarcadero customers across the region, he represents Embarcadero internationally as a 
 conference and seminar speaker.",NA
About the Reviewer,"Dave Nottage
  is an independent software consultant who lives in Adelaide, South 
 Australia.
  
 Developing software with Delphi since 1995 when Delphi 1 was first released, he has been a 
 valued member of Embarcadero's TeamB since 2001, and an Embarcadero MVP since 2014.
  
 Dave is considered an expert in Delphi and has shared his expertise as a speaker at Delphi 
 developer conferences, including BorCon, Delphi Live, and ADUG Symposia. He is an 
 active member on Embarcadero forums and Stack Overflow, and his popular blog articles, 
 which can be found at Delphi Worlds, provide solutions for common Delphi problems. His 
 blog is followed by many developers across the globe and is considered a go-to source.
  
 Having worked on projects for major global enterprises, corporations, and governments, he 
 is now working on his own commercial product, a set of code libraries that aids developers 
 in cross-platform development.
  
 In his spare time, Dave enjoys playing bass guitar in a band, art exhibitions, puzzles that 
 challenge the mind, and traveling the world.
  
 Dave can be contacted at 
 dave@delphiworlds.com.",NA
www.PacktPub.com,"For support files and downloads related to your book, please visit 
 www.PacktPub.com
 .
  
 Did you know that Packt offers eBook versions of every book published, with PDF and 
 ePub files available? You can upgrade to the eBook version at 
 www.PacktPub.com
  and as a 
 print book customer, you are entitled to a discount on the eBook copy. Get in touch with us 
 at 
 service@packtpub.com
  for more details.
  
 At 
 www.PacktPub.com
 , you can also read a collection of free technical articles, sign up for a 
 range of free newsletters and receive exclusive discounts and offers on Packt books and 
 eBooks.
  
  
 https://www.packtpub.com/mapt
  
 Get the most in-demand software skills with Mapt. Mapt gives you full access to all Packt 
 books and video courses, as well as industry-leading tools to help you plan your 
 personal development and advance your career.",NA
Why subscribe?,"Fully searchable across every book published by Packt
  
 Copy and paste, print, and bookmark content
  
 On demand and accessible via a web browser",NA
Customer Feedback,"Thanks for purchasing this Packt book. At Packt, quality is at the heart of our editorial 
 process. To help us improve, please leave us an honest review on this book's Amazon page 
 at 
 https://www.amazon.com/dp/1786460165
 .
  
 If you'd like to join our team of regular reviewers, you can e-mail us at 
  
 customerreviews@packtpub.com
 . We award our regular reviewers with free eBooks and 
 videos in exchange for their valuable feedback. Help us be relentless in improving our 
 products!",NA
Table of Contents,"Preface
  
 1
  
 Chapter 1: Fasten Your Seat Belts
  
 8
  
 Delphi installation 
  
  
 Delphi versions 
  
  
 Running the Delphi installer 
  
  
 Installing custom components 
  
  
 IDE options 
  
  
 Riding the Integrated Development Environment 
 Delphi compilers and toolchains 
  
 Hello World app 
  
 Deploying to mobile devices 
  
  
 Deploying to Android 
  
  
 Deploying to iOS 
  
 Summary
  
 Chapter 2: Mind Your Language
  
 8 
  
 9 
  
 10 
  
 14 
  
 16 
  
 17 
  
 17 
  
 19 
  
 32 
  
 32 
  
 36 
  
 42
  
 43
  
 Do you speak Object Pascal?
  
  
 Program structure 
  
  
 Console application 
  
  
 Forms applications 
  
 Object Pascal Phrase Book 
  
  
 Tokens 
  
  
 Constants 
  
  
 Types 
  
  
 Sets and arrays 
  
  
 Helpers 
  
  
 Generics 
  
  
 Anonymous code 
  
  
 Operator overloading 
  
  
 Custom attributes 
  
  
 Runtime Type 
 Information 
  
 Summary
  
 Chapter 3: Packing Up Your Toolbox
  
 4
 3 
  
 4
 4 
  
 4
 5 
  
 4
 9 
  
 6
 2 
  
 6
 2 
  
 6
 3 
  
 6
 4 
  
 6
 5 
  
 6
 6 
  
 6
 8 
  
 7
 2 
  
 7
 Parallel Programming Library
  
 78",NA
Preface,"The world of a mobile app developer is getting more and more complicated. The 
 technology is not standing still. Every day, new versions of mobile operating systems are 
 released to the market. Mobile devices are getting new capabilities. User expectations are 
 constantly growing, and it is becoming increasingly harder to meet them.
  
 The only way to meet and exceed all challenges in the contemporary world of mobile 
 development is to become a developer superhero! Super heroes have super tools. In this 
 book, we are going to embark on the journey of mastering Delphi development. We will 
 learn how to gain amazing productivity powers and rapidly build stunning cross-platform 
 mobile apps from one codebase.
  
 We will start with getting comfortable with using the Delphi IDE. Then, we will review the 
 key constructs of the Object Pascal language and everyday programmer tasks, so you can 
 easily understand and write solid and maintainable source code. Over the course of this 
 book, the fun levels are only going to increase. We will start our adventure with mobile 
 development with Delphi from building small projects that will make you feel like a real 
 Delphi developer. Having mastered simple things, you will be ready for doing more serious 
 stuff. We will go deep into understanding the concept of FireMonkey styles, which is the 
 cornerstone of building stunning cross-platform user interfaces that will make the 
  
 difference in the end user experience of your apps. The rest of the journey is all about 
 gaining practical knowledge of using more complex Delphi frameworks. We will get down 
 to the metal and harness the full power of mobile hardware and operating systems. We will 
 be working with sensors, extending to the Internet of Things, building data-driven user 
 interfaces, embedding mobile databases, integrating with REST web services, architecting 
 scalable, multiuser backends, and more.
  
 This book is packed with practical code examples and best practices for you to become an 
 excellent mobile developer!",NA
What this book is not about,"If you have never written any line of code, this book is not for you. The chances are that you 
 have been using Delphi already to build applications for Windows. You will not learn about",NA
Why Delphi?,"Mobile apps are everywhere. There are two main platforms for mobile apps that are 
 dominating the mobile market: Android and iOS. It is a common requirement to develop an 
 app for both the platforms. This typically means using different tools, frameworks, and 
 programming languages. If you want to build a mobile app for iOS, you should probably 
 use the Xcode development environment from Apple and use Swift or Objective-C as the 
 programming language. Android development requires different tools. For Android, you 
 would typically use a tool such as Android Studio from Google and the Java programming 
 language. These are two different worlds that speak different languages. If you want to 
 build your app for both, this means having two different sets of skills and, in practice, two 
 different teams of developers. Mobile app development gets more and more fragmented. 
 One can be an iOS developer, and somebody else can specialize in Android.
  
 A mobile app is quite often more than just what you download from an app store and install 
 in your phone or tablet. There must be a mobile backend deployed in the cloud that a 
 mobile app is communicating with. This adds another dimension to mobile development 
 landscape. One can be a frontend and one can be a backend mobile developer. There is a 
 growing segmentation in the market and you might think that mobile app development is 
 not for individuals anymore. Fear not! With Delphi, you can become a mobile developer 
 superhero and gain unmatched productivity powers to build complete mobile apps using 
 just one tool, one framework, and one programming language to create mobile apps for iOS, 
 Android, and desktop applications for Windows, Mac, and Linux. With Delphi, you can 
 also build scalable REST API backends that will power your mobile apps on all platforms.",NA
What this book covers,"Chapter 1
 , 
 Fasten Your Seat Belts
 , covers how to install Delphi and prepare it for mobile 
 cross-platform development. We'll build a Hello World FireMonkey app and natively 
 compile it from the same source code to Android and iOS.
  
 Chapter 2
 , 
 Mind Your Language
 , reviews the basic constructs of the Object Pascal 
 programming language used in Delphi. After covering the fundamentals, we'll quickly 
 move on to the discussion of more advanced language concepts used in FireMonkey 
 programming, including class helpers, generics, anonymous code, and Runtime Type 
 Information.
  
 Chapter 3
 , 
 Packing Up Your Toolbox
 , covers some of the most useful, everyday programmer 
 skills, such as writing multithreaded code with parallel programming library and working 
 with JSON and XML.
  
 Chapter 4
 , 
 Playing with FireMonkey
 , teaches the basics of building cross-platform mobile GUI 
 with FireMonkey. you'll learn how to use shapes, effects, and animation components. We'll 
 cover working with touch, multitouch, and gestures. At the end of this chapter, we'll write 
 the complete mobile 
 Game of Memory
  game.
  
 Chapter 5
 , 
 FireMonkey in 3D
 , explores how to build stunning interactive 3D graphical user 
 interfaces, including working with wireframes, 3D controls, and importing 3D models into 
 your Delphi apps.
  
 Chapter 6
 , 
 Building User Interfaces with Style
 , covers FireMonkey styling. We'll look into 
 using built-in styles and custom styles with 
 TStyleBook
  component, and customizing the",NA
What you need for this book,"You are expected to have a basic knowledge of Delphi and an interest in building cross-
 platform mobile apps for Android and iOS.
  
 The Delphi IDE is a Windows program, so you will need a physical or virtual Windows 
 installation. In order to develop for iOS, you will need a Mac computer. You will also need 
 an Enterprise or Architect license for Delphi itself. In the beginning of the first chapter of 
 this book, we cover the installation process of Delphi in a great detail.",NA
Who this book is for,"If you want to create stunning applications for mobile, desktop, the cloud, and the IoT, then 
 this book is for you. This book is for developers who like to build native cross-platform apps 
 from a single codebase for iOS and Android. A basic knowledge of Delphi is assumed, 
 although we do cover a primer on the language.",NA
Conventions,"In this book, you will find a number of text styles that distinguish between different kinds of 
 information. Here are some examples of these styles and an explanation of their meaning.
  
 Code words in text, database table names, folder names, filenames, file extensions, 
 pathnames, dummy URLs, user input, and Twitter handles are shown as follows: ""The 
 TForm
  class, which is an ancestor to 
 TFormSettings
 , is, in turn, inherited from the 
 TComponent
  class.""
  
 A block of code is set as follows:
  
 Application.Initialize; 
  
 Application.CreateForm(TFormMain, FormMain); 
  
 Application.CreateForm(TFormSettings, FormSettings); Application.Run;
  
 When we wish to draw your attention to a particular part of a code block, the relevant lines 
 or items are set in bold:
  
 const
  EL = #13;
  
 procedure
  TForm1.ButtonMultilineClick(Sender: TObject); 
 begin
  
  ShowMessage('Welcome!' + EL + 'Good morning!'); 
  
 end;",NA
Reader feedback,"Feedback from our readers is always welcome. Let us know what you think about this book-
 what you liked or disliked. Reader feedback is important for us as it helps us develop titles 
 that you will really get the most out of. To send us general feedback, simply e-mail 
 feedback@packtpub.com
 , and mention the book's title in the subject of your message. If there 
 is a topic that you have expertise in and you are interested in either writing or contributing 
 to a book, see our author guide at 
 www.packtpub.com/authors
 .",NA
Customer support,"Now that you are the proud owner of a Packt book, we have a number of things to help you 
 to get the most from your purchase.",NA
Downloading the example code,"You can download the example code files for this book from your account at 
 http://www.p 
 acktpub.com
 . If you purchased this book elsewhere, you can visit 
 http://www.packtpub.c 
 om/support
 and register to have the files e-mailed directly to you. You can download the code 
 files by following these steps:
  
 1. 
  
 Log in or register to our website using your e-mail address and password.
  
 2. 
  
 Hover the mouse pointer on the 
 SUPPORT
  tab at the top.
  
 3. 
  
 Click on 
 Code Downloads & Errata
 .
  
 4. 
  
 Enter the name of the book in the 
 Search
  box.
  
 5. 
  
 Select the book for which you're looking to download the code files.
  
 6. 
  
 Choose from the drop-down menu where you purchased this book from.
  
 7. Click on 
 Code Download
 .",NA
Errata,"Although we have taken every care to ensure the accuracy of our content, mistakes do 
 happen. If you find a mistake in one of our books-maybe a mistake in the text or the code-
 we would be grateful if you could report this to us. By doing so, you can save other readers 
 from frustration and help us improve subsequent versions of this book. If you find any 
 errata, please report them by visiting 
 http://www.packtpub.com/submit-errata
 , selecting your 
 book, clicking on the 
 Errata Submission Form
  link, and entering the details of your errata. 
 Once your errata are verified, your submission will be accepted and the errata will be 
 uploaded to our website or added to any list of existing errata under the Errata section of 
 that title. To view the previously submitted errata, go to 
 https://www.packtpub.com/book 
 s/content/support
 and enter the name of the book in the search field. The required information 
 will appear under the 
 Errata
  section.",NA
Piracy,"Piracy of copyrighted material on the Internet is an ongoing problem across all media. At 
 Packt, we take the protection of our copyright and licenses very seriously. If you come 
 across any illegal copies of our works in any form on the Internet, please provide us with 
 the location address or website name immediately so that we can pursue a remedy. Please 
 contact us at 
 copyright@packtpub.com
  with a link to the suspected pirated material. We 
 appreciate your help in protecting our authors and our ability to bring you valuable 
 content.",NA
Questions,NA,NA
Fasten Your Seat Belts ,NA,NA
,"The key benefit of Delphi in mobile development is that you can design your app once and, 
 from the same source code, you can natively compile it for both Android and iOS. This 
 chapter is exactly about this capability. We are going to first install Delphi, create a simple 
 one-button ""Hello World"" app, and then run the same app on Google Nexus 7 and on Apple 
 iPhone 6S.
  
 The 
 Integrated Development Environment
  (
 IDE
 ) is where the programmer spends the 
 most of the time. Learning best practices of using the IDE will pay off in the future and will 
 increase your developer productivity. Before going into building apps, you need to feel 
 comfortable working in the IDE.
  
 The objective of this chapter is to install the Delphi IDE, learn basic IDE functionality, and 
 prepare it for mobile development.",NA
Delphi installation,"Delphi is a Windows program, so you need to have a computer with a proper version of 
 Windows installed and enough free space on your hard drive. You may want to install 
 Delphi on a physical computer or onto a Windows virtual machine image using one of the 
 available virtualization solutions such as VMware. Installing onto a virtual machine has 
 some advantages in cross-platform development. In order to create iOS apps, you will need 
 to have access to a Mac computer. This could be another computer available on a local 
 network or the same physical machine. One of the most convenient configurations is to have 
 just one physical machine that allows you to target all operating system platforms 
 supported by Delphi.",NA
Delphi versions,"Delphi comes in different versions, so before downloading the installer, we need to decide 
 which version to choose. There are four Delphi versions--Starter, Professional, Enterprise, 
 and Architect:
  
 The 
 Starter
  version is the simplest one and it does not contain features necessary 
 for doing mobile development. This version is aimed at hobbyists, students, and 
 in general for anyone that just wants to learn Delphi. 
 Starter
  supports building 
 application for Windows 32-bit only. That's not what we need.
  
 The next version is 
 Professional
 . It also does not contain features for mobile 
 development, but they can be installed separately in the form of 
 mobile add-on 
 packs
 . The 
 Professional
  is a good choice if you plan to build applications for 
 Windows and you do not need the possibility to connect to remote databases.
  
 The third version is 
 Enterprise
 . This is the full version of Delphi and contains 
 everything that is in the 
 Professional
  plus more. It allows you to create apps for all 
 supported mobile and desktop platforms including Android, iOS, Windows, Mac, 
 and Linux. It also contains the 
 DataSnap
  framework for building scalable, 
 multitier systems that is not available in Professional edition. This is the version 
 of Delphi that we are going to use in this book.
  
 The highest Delphi version is 
 Architect
 . This is a product bundle that contains 
 Delphi 
 Enterprise
  and separately installed 
 ER/Studio Developer Edition
  for 
 modeling relational SQL databases and 
 DB Power Studio Developer Edition 
 that contains tools for working with SQL databases.",NA
Running the Delphi installer,"Delphi installer is available in two different formats. You can either choose to install Delphi 
 using the so-called 
 Electronic Software Delivery
  (
 ESD
 ) for short, or you can install from the 
 ISO image of the full Delphi installation DVD. The first option is the default one and it 
 makes for faster installation. The ESD installer is a relatively small application that 
 downloads and installs only those parts of Delphi that you have chosen at the beginning of 
 the installation process. After Delphi is installed you can always choose to install or 
 uninstall different features. The second option is to install from the DVD ISO image. This is 
 useful when the internet access is slow, unreliable, or for some security reasons the 
 Windows machine that you install Delphi onto does not have internet access at all.",NA
Installing custom components,"Delphi IDE has an open architecture and provides many ways to extend its functionality 
 through additional packages. You can see the list of currently installed packages in the 
 Installed Packages
  option available from the 
 Component
  menu. The most typical Delphi 
 building block is a 
 Component
 . Technically, this is about taking the object-oriented 
 programming principles and moving it one step further. With components, you have the 
 ability to manipulate regular programming language object instances during the design 
 time, before the project is built for a given platform. Packages may also contain custom 
 property editors and the 
 Open Tools
  API extension to the IDE itself that may add custom 
 functionality to the IDE, such as additional menus and windows.
  
 Out of the box, with the default Delphi installation, you will get a few hundred components 
 already preinstalled. Depending on your Delphi version and selected features, this list may 
 differ. Click on the 
 Installed Packages
  option in the 
 Component
  menu to verify which 
 components are actually installed, as shown in the following screenshot:
  
  
 Installed Packages window with components shown for a selected package",NA
IDE options,"You can manage all aspects of how the Delphi IDE works from the 
 Options
  dialog available 
 from the 
 Tools
  menu. Here, you can control various aspects of how Delphi operates as a 
 whole. Take a look at the following screenshot:
  
  
 Delphi Options
  
 [ 16 ]",NA
Riding the Integrated Development Environment,"In a nutshell, Delphi is a program for making other programs. The actual program 
 responsible for generating executable files from the source code is a compiler. It is typically 
 implemented as a command-line application. When executing a command-line application, 
 you can pass to it command-line parameters. Compilers take different command-line 
 parameters, including the location of source code files necessary to generate the resulting 
 binary file. Take a look at the following diagram:
  
  
 Simplified compiler architecture
  
 It is possible to write your programs using a text editor like Notepad and then execute the 
 compiler from the command line, but it is not the most efficient way of creating 
  
 applications. Most programmers use IDE for working on apps. The idea of an integrated 
 development environment originates from the Delphi ancestor, 
 Borland Turbo Pascal,
  and 
 comes from the integration of three previously separate programs: Code Editor, compiler, 
 and debugger.",NA
Delphi compilers and toolchains,"Delphi IDE contains different compilers for generating apps for different platforms. The IDE 
 manages all necessary source code files needed for building an app. It also takes care of 
 passing correct parameters to right compilers and manages their output. In the IDE, it is 
 possible to build, deploy, and run an app directly on the mobile device connected with a 
 USB cable by just pressing the 
 Run
  button. Obviously, it is also possible to generate an 
 executable application without running it. Sometimes it is very handy to be able to step into 
 an application as it is executed in the host operating system. This process is called 
  
 debugging. In the Delphi IDE, you can run your program 
 with
  or 
 without
  debugging.",NA
Hello World app,"Starting with a new programming language or framework typically involves creating a 
 program that displays the famous ""Hello World"" message, and we will follow this 
 convention. Our app will have just one button. When you press the button, a 
 Delphi Hello 
 World!
  message will be displayed. Later in this chapter, we are going to put this app on 
 an iPhone and on an Android device.
  
 Click on the 
 Multi-Device Application - Delphi
  option in the 
 File
  | 
 New
  menu, as shown 
 in the following screenshot:",NA
Deploying to mobile devices,"Our 
 DelphiHelloWorld
  project is now ready for deployment to mobile devices. We have 
 already built and run it on Windows. Now, we are going to first deploy it to an Android 
 device and then to iOS.
  
 This is a one-time preparation for mobile development that you need to go through after 
 Delphi is installed. We want to get to the point that you can see your devices as targets 
 inside the 
 Project Manager
 .
  
 For Android, all steps to configure your system to detect your device are described at 
 http://docwiki.embarcadero.com/RADStudio/en/Configuring_Your_System_to_Detect_Y
  
 our_Android_Device
 .",NA
Deploying to Android,"Deploying apps from Delphi to Android devices is simpler then deploying to iOS. You only 
 need to have an Android device and a USB cable to connect your device to a Windows 
 machine where you have Delphi installed.
  
 Before deploying to an Android device, you need to find out if your device is supported by 
 the version of Delphi you are using. For details, consult 
  
 http://docwiki.embarcadero.com/RADStudio/en/Android_Devices_Supported_for_Appli
  
 cation_Development
  for the list of currently supported Android versions.
  
 The first step is to enable USB debugging on the device. This option can be set in 
 Developer 
 options
  on your device. This option is not easy to find. It is, in fact, hidden. On your 
 Android device, go to the 
 Settings
  | 
 About
  menu. Tap the 
 Build number
  seven times to 
 make 
 Settings
  | 
 Developer options
  available. Then, check the 
 USB Debugging
  option. 
 Connect your Android device with a USB cable to a computer where your PC is running. If 
 you are using VMware make sure that your Android device is connected to the virtual 
 machine where you have Delphi and not to your Mac. The first time you connect your 
 Android device, you may see a message displayed on the device to 
 Allow USB debugging 
 from the computer, identified by a string of hexadecimal numbers that represents the 
 computer's RSA key fingerprint. Check the 
 Always allow from this computer
  option and 
 click on 
 OK
 .
  
 More info on enabling USB debugging on Android devices is available at 
  
 http://docwiki.embarcadero.com/RADStudio/en/Enabling_USB_Debugging_on_an_Androi
  
 d_Device
 .",NA
Deploying to iOS,"Deploying apps from Delphi to an iOS device requires a Mac computer. As compared to 
 Android, deploying to iOS requires more steps because you also need to enroll for the 
 Apple iOS Developer Program and to provision the device you want to deploy to.
  
 First, you need to make sure that the iOS device that you want to deploy your application to 
 is compatible. In case of iPhone, the oldest supported model is 4GS, but you want to have a 
 device that can have iOS 10 installed. In my case, it is iPhone 6S.
  
 The first steps to prepare your Mac and an iOS device for deployment are exactly the same 
 that any iOS developer needs to do. This is something that you do once. During the process 
 of deploying to an iOS device, an app needs to be digitally signed with the special 
  
 command-line tool that comes with Apple Xcode installation. You could install just the 
 Xcode command-line tools, but in practice it is easier to install the whole Xcode 
  
 development environment from Apple.
  
 In order to be able to deploy apps to an iOS device, it needs to be provisioned first. The 
 process of provisioning iOS devices, joining the Apple iOS Developer Program, and 
 installing various certificates is the same as in the case of any app developed with Xcode. In 
 order to be sure that you will be able to deploy an app from Delphi into iOS, it is 
  
 recommended to create an empty app from a template in Xcode and try to run it on the 
 device. If this is successful, the next step is to install a special 
 PAServer
  Mac program on the 
 machine where you have Xcode installed. The 
 PAServer19.0.pkg
  installable package is 
 installed in the 
 PAServer
  subdirectory of Delphi. Just copy it over to your Mac and execute.
  
 This will install the PAServer. The PAServer is implemented as a command-line app, and 
 after it is launched on Mac, it will display a command-line interface where you will be 
 prompted to enter your Mac password. Your Mac will also display a dialog asking if it is 
 OK to give PAServer debugging permissions. Accept it.",NA
Summary,"In this chapter, we have installed Delphi and configured it for mobile development. We 
 have also learned the basic functionality of the Integrated Development Environment.
  
 Now we are going to change gears and focus on Object Pascal, the programming language 
 of Delphi.
  
 [ 42 ]",NA
Mind Your Language ,NA,NA
,"The Object Pascal language used in Delphi is constantly evolving. With every new version 
 of Delphi, new features are added to the language. For every mobile and desktop operating 
 system, there is a different Delphi compiler with slightly different functionality, such as 
 automatic reference counting for mobile. Fluency in using the Object Pascal language is a 
 key skill for every Delphi developer.
  
 This chapter will cover the following points:
  
 The basic Object Pascal language features
  
 Advanced constructs, such as generics, anonymous methods, class helpers, 
  
 custom attributes, and Runtime Type Information (RTTI)
  
 The objective of this chapter is gaining fluency in using the Object Pascal language with a 
 focus on mobile Delphi compilers. This chapter is not a definitive reference to every single 
 feature of the programming language of Delphi. The goal is to cover most of the everyday 
 constructs, to be able to understand the FireMonkey library source code, and to write solid 
 and maintainable code.",NA
Do you speak Object Pascal?,"The Object Pascal language has been designed for teaching good programming practices. It 
 is a high-level, modern, and strongly typed compiled language that supports structured and 
 object-oriented programming.
  
 In order to solve a problem using a computer, you need to define a finite set of actions that 
 operate on certain data or, in other words, to define an algorithm. An algorithm expressed",NA
Program structure,"Each program begins with a heading, which specifies the name of the program, followed by 
 an optional 
 uses
  clause and a block of declarations and statements. Object Pascal programs 
 are typically divided into modules of source code called 
 units
 . The optional 
 uses
  clause 
 contains the list of units that are used by the program. These units, in turn, may use other 
 units specified in their own 
 uses
  clauses.",NA
Console application,"The simplest possible type of program that can be written in Delphi is a console application. 
 It does not contain any graphical user interface. Console programs can be executed from the 
 command prompt and can optionally take command-line parameters. A console application 
 may output some text back to the command line, perform some calculations, process files, or 
 communicate with remote services running somewhere on the internet.",NA
Forms applications,"It is time to start building our first fully functional mobile app 
 The Game of Memory
 . In this 
 chapter, we will only create the main architecture. Our app is going to be very simple. There 
 will be two forms--one main form will contain a grid of squares, which will serve as the 
 game board, and the second form will contain the game settings. This simple architecture 
 will help us understand the structure of a typical Delphi 
 forms
  applications.",NA
Object Pascal Phrase Book,"This book is aimed at Delphi programmers with some previous Delphi experience. The 
 Object Pascal language of Delphi keeps evolving, and knowing it well is of the utmost 
 importance to every programmer, even the experienced ones. Not all the concepts that you 
 can find in many Object Pascal tutorials are discussed here, but the idea is to have a solid 
 walkthrough of even the fundamental language concepts, with the focus on newer 
 constructs and those that are important to mobile development with Delphi.",NA
Tokens,"Tokens are the smallest meaningful pieces of text that a compiler understands. Tokenization 
 is the very first thing that the compiler does when starting to process a source code file. 
 There are different types of tokens, including identifiers, numbers, strings, constants, and 
 special symbols. An Object Pascal program is made up of tokens and separators. A 
  
 separator is either a blank space or a comment. There must be at least one separator between 
 tokens.
  
 In Object Pascal source code, you can use any Unicode characters for identifiers, but it 
 makes a lot of sense to stick to just ASCII characters and consistently use just the English 
 language in your code. Different Object Pascal language elements are in English, and it is 
 easier to work with other programmers who might use other languages as their mother 
 tongue.
  
 The Delphi Code Editor displays different fragments of Delphi source code using different 
 colors. Some words are displayed in bold and some others in italics. The color scheme of the 
 Code Editor can be customized in the IDE Options, but here we will stick to the defaults.
  
 The Object Pascal language defines a set of 
 reserved words
  that the compiler knows about, 
 and they cannot be used as identifiers in our code. Keywords are displayed in bold, so they 
 are easy to spot. Keywords have a special meaning to the compiler. For example, if you try 
 to save your program as 
 program
 , you would get an error message that 
 program
  is a reserved 
 word and cannot be used as an identifier. If, for some reason, you really want to use a 
 keyword as an identifier in your code, you can escape it by prepending the identifier with 
 the 
 &
  character.",NA
Constants,"A constant is an identifier that marks a value that cannot change. The normal decimal 
 notation is used for numbers that are integer or real constants. A hexadecimal integer 
 constant uses a dollar sign as a prefix. It is also possible to use the engineering notation, 
 where an exponent follows the 
 E
  or 
 e
  character.
  
 A character string is a sequence of zero or more characters written in one line in the 
 program and enclosed within apostrophes. A character string with nothing between the 
 apostrophes is called a 
 null
  string. Two sequential apostrophes in a character string denote a 
 single apostrophe character.
  
 For example, a string constant would print out as just 
 Paweł's computer
 , as shown in the 
 following program:
  
 const
  
  s = 'Paweł''s computer';
  
 Object Pascal allows the use of 
 constant expressions
 . The compiler evaluates them at compile 
 time without actually executing the program.
  
 Object Pascal makes it possible to embed control characters in character strings. The 
 # 
 character followed by an unsigned integer in the range of 0 to 255 means a character of the 
 corresponding ASCII value. A useful example of this capability is embedding a newline 
 character in a string constant, so it is displayed in multiple lines. For example, check out the 
 following code snippet:
  
 const EL
  = #13;
  
 procedure
  TForm1.ButtonMultilineClick(Sender: TObject); 
 begin
  
  ShowMessage('Welcome!' + EL + 'Good morning!'); 
  
 end;
  
 Embedding the new ASCII 13 
 newline
  control character displays the message in two lines. 
 For readability, the actual newline character is defined as a constant.",NA
Types,"Writing applications in Object Pascal starts from defining custom types. Only the simplest 
 programs can get away with just using built-in types. Once you have defined your types, 
 you start writing code and implement algorithms that operate on your types or data 
 structures. The more carefully your types are designed, the more clean and readable your 
 code will be.
  
 Object Pascal comes with many different built-in types that you can use to define your own 
 custom types. With experience, it will become more obvious how to model your problem 
 domain. If you write an app to manage grades in a school, you would probably want to 
 model the abstraction of a school grade. Should it be a constant, an enumerated type, a 
 record, or a class?
  
 Every country and education level has different grading schemes. As an example, let's 
 consider the grading system that was used in my primary school in Poland. There were only 
 four grades: very good (5), good (4), sufficient (3), and insufficient (2). At first, we could be 
 tempted to use numbers as grades in our code. Refer to the following code snippet:
  
 var
  
  grade: integer;
  
 That is not an optimal design. What if our application assigns a value by mistake to a 
 grade 
 variable that is negative or too big?
  
 In this particular case, it would be better to define a school grade as an enumerated type. 
 This will make our code less error-prone and much more readable. There are two different 
 ways of defining an enumerated type. Traditionally, we would define the 
 TSchoolGrade 
 enumeration as follows:
  
 type
  
  TSchoolGrade = (sgVeryGood, sgGood, sgSufficient, sgInsufficient);
  
 Somewhere in our code, we have a variable of the 
 TSchoolGrade
  type, which can only 
 hold one of the four possible grades defined by this type. Now our code is better. The 
 sg 
 prefix helps us remember that the 
 sgGood
  identifier, for example, is, in fact, one of the 
 possible school grade values. The other possibility is to use the enumerated values in the 
 fully qualified form. With the 
 SCOPEDENUMS ON
 /
 OFF
  compiler directive, we can enforce 
 using a fully qualified form of an enumeration, as shown in the following code snippet:
  
 {$SCOPEDENUMS ON} 
  
 type
  
  TSchoolGrade = (VeryGood, Good, Sufficient, Insufficient);",NA
Sets and arrays,"After defining a type, we will use it in our code, either as a standalone variable or as a 
 collection. The most basic 
 collection
  type is a 
 set
 . It is very powerful and not available in 
 other programming languages. We could, for example, define a set of 
 qualifying
  school 
 grades. The elements of a set are enclosed in square brackets. Refer to the following code:
  
 type
  
  TSchoolGrade = (sgVeryGood, sgGood, sgSufficient, sgInsufficient); TSchoolGrades = 
 set of
  
 TSchoolGrade;
  
 const
  
  QUALIFYING_GRADES: TSchoolGrades = [sgVeryGood, sgGood, sgSufficient];
  
 function
  IsQualifyingGrade(sg: TSchoolGrade): boolean; 
 begin
  
  Result := sg 
 in
  QUALIFYING_GRADES; 
  
 end;
  
 Using the 
 in
  operator, we can check if a given value belongs to a set. It is also possible to use 
 other operators to combine sets, calculate their intersections, and, in general, implement 
 other set theory operations.
  
 Another built-in type for dealing with collections of values is an array. Arrays can have 
 either a fixed or a varying size. If it is fixed, then we need to define upfront how many 
 elements an array can hold. It is also possible to use 
 dynamic arrays
 . In this case, we can 
 change the size of an array in code using the 
 SetLength
  procedure and check its current size 
 with the 
 Length
  function. Once we are done with using a dynamic array, it is a good idea to 
 pass it to the 
 Finalize
  procedure, so the memory it occupies can be properly freed.",NA
Helpers,"Manipulating types in code can be even more readable when we define type 
 helpers
 .
  
 Helpers extend a type 
 vertically
 . You can define them on simple types, enumerations, 
 records, or even on dynamic arrays. Delphi already comes with helpers defined for many 
 built-in types, so they are easier to use in code. One good example is the very common task 
 of converting an integer to a string, so it could be displayed as shown in the following code:
  
 var
  s: 
 string
 ; i: integer; 
  
 begin
  
  i := 10;
  
  s := IntToStr(i); // ""old"" style
  
  s := i.ToString;  // more readable
  
  s := 10.ToString; // that would work too
  
 Just right-click on the 
 ToString
  method in this code and jump to the declaration. In the 
 System.SysUtils
  unit, you will see helpers defined for many built-in types providing 
 some additional useful methods, such as the minimum and maximum values for given 
 built-in numerical types.
  
 It is easy to define your own helper classes. Until Delphi 10, using helpers it was possible to 
 access some private functionality of types that come out of the box with Delphi libraries, but 
 since then this hack no longer works.
  
 We already have the 
 TSchoolGrade
  custom enumerated type. It would be useful to provide 
 methods to convert a school grade value to a string or to a number. With helpers, it can be 
 done in a really elegant way, as shown in the following code:
  
 type
  
  TSchoolGrade = (sgVeryGood, sgGood, sgSufficient, sgInsufficient); TSchoolGrades = 
 set of
  
 TSchoolGrade;
  
 const
  
  QUALIFYING_GRADES: TSchoolGrades = [sgVeryGood, sgGood, sgSufficient];
  
 type
  
  TSchoolGradeHelper = 
 record helper for
  TSchoolGrade 
  
 public 
  
    
 function
  ToString: 
 string
 ; 
  
    
 function
  ToInteger: integer;
  
    
  function
  IsQualifying: boolean;
  
  end;
  
 { TSchoolGradeHelper }",NA
Generics,"One of the most powerful concepts in the Object Pascal language is a 
 generic type
 . This way, 
 we can write our code in a more generic way, so the same algorithm can operate not on 
 just one data type, but many. Generics are 
 things
  that can be parameterized by type. The 
 code is not fully specified, providing the implementation details to the code that uses 
 generics.
  
 There could be generic types where the whole type definition is parameterized by an 
 unknown type, or we can just define generic methods that operate on a type that is not fully 
 specified.",NA
Anonymous code,"Anonymous code is all about treating code as data. You can assign an implementation of a 
 function or procedure to a variable; you pass functions as parameters to other functions and 
 receive them as results. This is a very powerful feature of the Object Pascal language. With 
 anonymous code, the source code of your app can be more compact and maintainable.
  
 A declaration of an anonymous method type has the following syntax:
  
 type
  
  TStringProc = reference 
 to procedure
  (s: 
 string
 );
  
 We are saying that 
 TStringProc
  is a procedure that takes a string parameter. Now, we can 
 define variables of this string type, assign implementation to them, pass them to functions, 
 or, simply, just call them. Refer to the following code snippet:
  
 procedure
  CallMe(
 const
  proc: TStringProc; msg: 
 string
 ); begin
  
  proc(msg); 
  
 end;
  
 procedure
  DoStringProc; 
  
 var
  
  proc: TStringProc; 
  
 begin
  
  proc := 
 procedure
 (x: 
 string
 )
  
  begin
  
  
  Log('Declared proc got: ' + x);
  
  end;
  
  CallMe(proc, 'Hello');
  
  CallMe(
  
  
  procedure
 (v: string) 
  
  
  
 begin",NA
Operator overloading,"Your code can be more readable with operator overloading. You cannot overload the 
 meaning of arbitrary operators in Object Pascal, only the built-in operators. You can also 
 implement implicit conversion operators that make it possible to assign different types to a 
 given type and define what would happen during the assignment. You can also define 
 comparison operators to define the results of the built-in operators, 
 =,<
 , and 
 >
 .
  
 Operator overloading leads to more compact, more readable code. For example, Delphi 
 comes with a 
 System.Math.Vectors
  unit with different useful types such as 
 TVector3D 
 with 
 useful overloaded operations, as shown in the following code snippet:
  
 uses
  
  System.Math.Vectors;
  
 procedure
  DoSomeVectorMath; 
  
 var
  
  A, B, C: TVector3D; 
  
 begin
  
  A := TVector3D.Create(1,2,4);
  
  B := TVector3D.Create(2,3,1);
  
  C := A + B;
  
  // ...",NA
Custom attributes,"Custom attributes let you add custom information to a class itself or to its individual 
 members. Many libraries that come with Delphi use custom attributes. They are useful 
 when we want to mark certain types or type members that need to be treated in a special 
 way. For example, in the 
 DUnitX
  unit testing framework that comes with Delphi, we use the 
 Test
  custom attributes to mark a method as 
 testable
  and optionally provide 
  
 parameters to be used by the unit test runner. Another example is the REST API resources, 
 which are published from EMS modules. With custom attributes, we can tell the framework 
 what should be the name of the REST resource to access a certain method.
  
 A custom attribute is just a regular class that inherits from the 
 TCustomAttribute
  type 
 defined in a built-in system unit.
  
 Let's consider the definition of a custom 
 documentation
  attribute. A programmer could 
 use such an attribute to associate a given class member in code with a custom URL, with 
 more information about it. Take a look at the following code snippet:
  
 unit
  uDocAttribute;
  
 interface
  
 type
  
  DocAttribute = 
 class
 (TCustomAttribute)
  
  private
  
   
  FURL: 
 string
 ;
  
  public
  
   
  constructor
  Create(URL: 
 string
 ); 
  
   
 property 
 URL: 
 string read
  FURL 
 write
  FURL;
  end;
  
 implementation
  
 { DocAttribute }
  
 constructor
  DocAttribute.Create(URL: 
 string
 ); 
 begin
  
  FURL := URL; 
  
 end;",NA
Runtime Type Information,"RTTI provides reflection capabilities to the Object Pascal language. With reflection, different 
 types of 
 meta-programming
  scenarios are possible. You can, for example, write code that will 
 be able to operate on objects that it does not know about. RTTI provides abstractions for all 
 the different types available in the Object Pascal language in the 
 System.Rtti
  unit that comes 
 with Delphi. All classes and built-in simple types can be treated in a unified way using the 
 TValue
  record. If you want to programmatically inspect a type and to know whether it is a 
 class and what members it contains, you can use 
 TRttiContext
 , which has a 
 GetType
  method 
 that returns an instance of the 
 TRttiType
  reference, which has methods that let you 
 inspect
  a 
 given type and iterate through all its members if it is a class.
  
 In our 
 documentation
  attribute example, we can use RTTI to retrieve documentation URLs 
 for the type itself and for its methods. Refer to the following code snippet:
  
 uses
  RTTI, uDocAttribute, uMySuperClass;
  
 procedure
  TFormDemo.Button1Click(Sender: TObject); 
 var
  
  ctx: TRttiContext;
  
  t: TRttiType;
  
  m: TRttiMethod;
  
  a: TCustomAttribute;",NA
Summary,"In this chapter, we reviewed different basic and more advanced elements of the Object 
 Pascal language used in Delphi. There are many tutorials and language primers that cover 
 each and every element of the language in detail.
  
 In the first part, we reviewed the structure of a typical Delphi application from the 
  
 perspective of the Memory Game app that we are going to build in the next chapters. The 
 second part of the chapter covered selected elements of the Object Pascal language, such as 
 type helpers, generics, anonymous code, and more, which are needed to better understand 
 the code that comes with the Delphi installation and which you need to use very frequently, 
 such as generic lists of objects.",NA
Packing Up Your Toolbox ,NA,NA
,"There are many simple every day programming skills that every Delphi developer needs to 
 have. Pack your every day programmer toolbox with everything you will need from simple 
 things such as file I/O to more complex things such as working with JSON and the Parallel 
 Programming Library.
  
 This chapter will cover the following points:
  
 Parallel Programming Library
  
 File I/O
  
 JSON
  
 XML
  
 The objective of this chapter is to become fluent in using a Delphi programmer with every 
 day useful techniques, such as working with files, streams, JSON, and XML. We will also 
 look into making your apps faster and more responsive with the Parallel Programming 
 Library (PPL).",NA
Parallel Programming Library,"Writing multithreaded code is considered to be one of the most difficult things in 
  
 programming. Debugging multithreaded apps is even more difficult. When an operating 
 system starts an app, it creates an operating process for it. In each process, there could be 
 one or more threads running. Processors that power mobile devices typically have multiple 
 cores. This means that there could be multiple threads executing in parallel on each core. A",NA
Parallel loops,"The most easy concept to grasp in the PPL is a 
 parallel for loop
 . This is useful when 
  
 calculations for different values of a control variable are independent and it is not important 
 in which order they are executed. A good example of this use case comes from the ray 
 tracing algorithm used in computer graphics. To generate an image, we need to calculate the 
 color of each pixel that makes up the resulting image. This is done by calculating the path of 
 each ray of light in space. Calculating the color of a given pixel is completely independent 
 from other pixels and can be performed simultaneously to generate the resulting bitmap 
 faster.
  
 Instead of implementing a ray tracer here, let's create a really simple demo that would allow 
 us to observe how much faster a parallel loop would execute as compared to a traditional 
 loop. Instead of calculating pixel colors in each iteration of the loop, we will just call, 
 Sleep 
 procedure that will make the current thread sleep for a given amount of milliseconds and 
 then it will continue to run. Create a new multi-device project in Delphi. Drop two buttons 
 on the form and write the following code that will display in the caption of each button, 
 how much time it took to execute the loop.
  
 For calculating the elapsed time, we are using the 
 TStopwatch
  record type from 
 System.Diagnostics
  unit; refer to the following code snippet:
  
 uses
  
  System.Threading, // parallel programming library 
 System.Diagnostics; // TStopwatch
  
 procedure
  TForm1.DoTimeConsumingOperation(milis: integer); 
 begin
  
  Sleep(milis); 
  
 end
 ;
  
 procedure
  TForm1.btnForLoopRegularClick(Sender: TObject); 
 var
  sw: 
 TStopwatch; i: Integer;",NA
Tasks,"One of the key use cases for multithreading code is to keep the user interface responsive 
 while performing some long running operation, such as downloading data from the internet 
 or performing calculations. The main thread of the application, the one when the user 
 interface runs, should not be busy with those time consuming operations. They should be 
 executed in the background thread to keep the user interface responsive.
  
 Add two more buttons to the form and enter the following code in their 
 OnClick
  events:
  
 procedure
  TForm1.btnNonResponsiveClick(Sender: TObject); 
 begin
  
  DoTimeConsumingOperation(3000);
  
  (Sender 
 as
  TButton).Text := 'Done'; 
  
 end;
  
 procedure
  TForm1.btnResponsive1Click(Sender: TObject); 
 var
  aTask: 
 ITask; 
  
 begin",NA
Futures,"PPL also provides the notion of a future. It is a specialization of a task. It is a task that 
 returns a value. In the case of a task, you call its 
 Start
  method to execute. In the case of a 
 future, you can just declare it and assign it to a variable. When you try to retrieve the value 
 of this variable, then the future is executed in a background thread and the value is 
 returned.
  
 There are some interesting use cases when futures are useful. For example, you may want to 
 calculate something based on the values of two or more parameters that need to be 
  
 calculated first. Instead of calculating these parameters sequentially, we could perform these 
 calculations simultaneously.
  
 For example, a management board of some large organization would like to know what is 
 the ratio of actual versus planned expenses for the last year. Calculating both values could 
 be a lengthy process. At the end you get just two currency values that you want to divide.
  
 Let's first have a look at how we could implement this functionality without futures, just by 
 using standard code:
  
 function
  GetPlannedExpenses: currency; 
  
 begin
  
  Sleep(1000);
  
  Result := 100; 
  
 end;
  
 function
  GetActualExpenses: currency; 
  
 begin
  
  Sleep(2000);
  
  Result := 110; 
  
 end;
  
 procedure
  TForm1.btnFuture1Click(Sender: TObject); 
 var
  
  planned, actual: currency;
  
  ratio: double;
  
  sw: TStopwatch; 
  
 begin
  
  sw := TStopwatch.StartNew;
  
  planned := GetPlannedExpenses;
  
  actual := GetActualExpenses;
  
  ratio := actual / planned;",NA
Working with files,"Almost every app needs to persist data. You have just downloaded an app, worked with it 
 for a while, and the next time you open it, you would like to see that it remembers what you 
 have done so far. An app can store its data in the cloud, in an embedded database or in a 
 file. This last option is the most easy to use. A local file can store information in different 
 formats. It could be a binary file, which is just an array of bytes, that is left to an app to make 
 sense of, or it could be a text file. Your app can store information in plain text or it can use 
 some of the file formats, such as JSON or XML, to make it easier to process text 
  
 information.
  
 Imagine that you would like to write a small mobile app to keep track of your favorite 
 locations on the internet. To keep it simple, it could be just a list of favorite items made of 
 two strings: an URL and a caption. Let's go for it! Create a new multi-device application in 
 Delphi. Select a blank application template. Save the main form as 
 uFormFavMain
  and the 
 whole project as 
 FavoritesDemo
 . Add a new unit to the project and save it as 
 uFavorite
 .
  
 Let's define there a simple 
 TFavorite
  class for individual favorite items. It will contain only 
 two public string fields, 
 URL
  and 
 Caption
 . For convenience, let's add there a 
  
 constructor that will take initial values for both fields. If we define a custom constructor that 
 takes parameters, we will not be able to call a normal parameterless constructor, so we also 
 need to explicitly define one. We could have defined both string fields as properties, but in 
 fact there is no need for properties here.
  
 There is also the 
 TFavorites
  class definition, which is a generic object list of 
 TFavorite 
 objects. It is going to be easier to use it in code instead of the full generic notation with 
 < 
 and 
 >
  characters, as shown in the following code snippet:
  
 unit
  uFavorite;
  
 interface
  
 uses
  
  System.Generics.Collections;
  
 type
  
  TFavorite = 
 class
  
    
  URL: 
 string
 ;
  
    
  Caption: 
 string
 ; 
  
    
 constructor
  Create; 
 overload
 ; 
  
    
 constructor
  Create(AURL, ACaption: 
 string
 ); 
 overload
 ; 
  
 end;
  
  TFavorites = 
 class
 (TObjectList<TFavorite>);",NA
JSON,"A better format for storing favorite entries is JSON. This is currently the most popular data 
 interchange format. Its strength is its simplicity. The JSON specification makes for an 
 interesting read at 
 http://json.org
 . With a very simple type system, JSON is able to represent 
 complex data structures. One of the key design objectives of a JSON is to keep it simple. 
 Most programming languages can process JSON and Object Pascal is not an exception.
  
 There are two main ways to work with JSON in Delphi. One approach is to build an in-
 memory representation of JSON tree using objects from the 
 System.JSON
  unit. The second 
 approach is based on streaming and provides sequential access to JSON data. In reality, 
 both ways have their advantages and disadvantages. Let's look at both.
  
 JSON is a very popular format for sharing information. You have just locally downloaded a 
 piece of JSON and now what?
  
 Here is our favorites information expressed as JSON:
  
 {
  
  ""Favorites"": [
  
   
  {
  
    
  ""URL"": ""www.embarcadero.com/products/delphi"",
   
  
  ""Caption"": ""Delphi Home Page""
  
   
  },
  
   
  {
  
    
  ""URL"": ""docwiki.embarcadero.com/RADStudio/en"",
   
  
  ""Caption"": ""RAD Studio online documentation""
  
  
  }
  
  ] 
  
 }
  
 Notice that unlike plain text the favorites data is more structured. Here we have an object 
 with just one property called 
 Favorites
  and its value is an array made up of two objects.
  
 Each object contained in the array has two string properties: 
 URL
  and 
 Caption
 . In a 
 programmer's life, a typical objective might be to convert JSON data into programming 
 language constructs that can be manipulated in code or to output JSON text from a 
 program.
  
 Add another form to the demo app and call it 
 FormFavJSON
 . Add all the functionality to 
 navigate to this form and back to the main form exactly like we did for the 
  
 FormFavTextFile
  form.",NA
Writing JSON,"First let's look at different ways of generating JSON. We will save this information to a file 
 and later we will read this information back into a local favorites list.
  
 Again we are going to start with implementing a 
 GetFilename
  function, but this time to 
 write and read from the 
 favs.json
  file:
  
 function
  TFormFavJSON.GetFilename: 
 string
 ; 
  
 begin
  
  Result := TPath.Combine(TPath.GetDocumentsPath, 'favs.json'); 
 end;
  
 We will also need a simple function to write a string with JSON text to a file. It is so simple 
 with the 
 TStreamWriter
  class that we saw earlier. Refer to the following code snippet:
  
 procedure
  TFormFavJSON.WriteJsonTextToFile(txt: 
 string
 ); 
  
 var
  sw: TStreamWriter; 
  
 begin
  
  sw := TStreamWriter.Create(GetFilename, False, TEncoding.UTF8); 
  
 try
  
    
  sw.WriteLine(txt); 
  
  
 finally
  
    
  sw.Free;
  
  end; 
  
 end;
  
 The first approach for generating JSON is based on building an in-memory graph of JSON 
 data and then converting it to a string in one operation. For this we will define the 
 FavListToJsonTextWithDOM
  method that will return JSON text generated from our global 
 TFavorites
  list in the main form of the demo app:
  
 uses
  System.JSON;
  
 function
  TFormFavJSON.FavListToJsonTextWithDOM: 
 string
 ; 
 var
  
  fav: TFavorite; favs: TFavorites;
  
  objFavs, objF: TJSONObject; arrFavs: TJSONArray;
  
 begin
  
  favs := FormFavMain.Favs;
  
  objFavs := TJSONObject.Create; 
  
  
 try
  
   
  arrFavs := TJSONArray.Create;
  
 for
  fav 
 in
  favs 
 do",NA
Reading JSON,"The JSON specification does not provide any way for expressing the schema or a metadata 
 describing the structure of JSON information. Consequently, when we write code that 
 processes JSON, we are assuming to find there certain data structures. There are two ways 
 of reading JSON. One that is based on its in-memory representation and the second based 
 on streaming.
  
 The key to parsing JSON using DOM is the 
 ParseJSONValue
  class method belonging to the 
 TJSONObject
  type. This an overloaded method defined in 
 System.JSON
  and it takes JSON text 
 in form of a string, stream, or array of bytes, parses it and returns a 
 TJSONValue 
 reference 
 which points to the root of a graph of JSON objects in memory. If JSON passed to this 
 method is malformed then this method does not raise an exception, but just returns a 
 nil
  
 reference. Take a look at the following code snippet:
  
 uses
  
  System.JSON.Readers, System.JSON.Types;
  
 procedure
  TFormFavJSON.btnReadDOMClick(Sender: TObject); 
  
 var
  
  favs: TFavorites; valRoot: TJSONValue; objRoot: TJSONObject; valFavs: TJSONValue; 
 arrFavs: TJSONArray; i: integer; 
  
 begin
  
  favs := TFavorites.Create; 
  
  
 try
  
    
  valRoot := TJSONObject.ParseJSONValue(ReadJsonTextFromFile); 
  
  
  
 if
  valRoot <> 
 nil then 
  
    
 begin 
  
     
 if
  valRoot 
 is
  TJSONObject 
 then 
  
     
 begin
  
       
  objRoot := TJSONObject(valRoot); 
  
        
 if
  objRoot.Count > 0 
 then 
  
        
 begin
  
        
  valfavs := objRoot.Values['Favorites']; 
  
         
 if
  valFavs <> 
 nil then 
  
         
 begin 
  
           
 if
  valFavs 
 is
  TJSONArray 
 then",NA
XML,"Before JSON dominated the world, XML was the most popular format for data interchange. 
 With the addition of many new specifications, XML became very complex, but it is a 
 practical thing to understand how to process XML in case you need to.",NA
Summary,"In this chapter, we have learned some useful everyday skills that a Delphi developer can 
 benefit from.
  
 In the first part, we have looked into PPL. With constructs such as parallel 
 for
  loops, tasks, 
 and futures, we can really make our Delphi apps faster and more responsive.
  
 The second part of the chapter was related to working with text files. One can work with 
 just plain text, or take advantage of popular structured file formats such as JSON and XML.
  
 We have looked into working with both file formats through building their in-memory 
 representation. In the case of JSON, we have also looked into reading and writing data 
 using dedicated readers and writers. For completeness, it should be noted that we have not 
 covered the 
 TJson
  class from the 
 REST.Json
  unit that can be used for serializing Delphi objects 
 to their JSON representation and back.
  
 In the next chapter, we will be playing with FireMonkey through small, but funny demo 
 apps.",NA
Playing with FireMonkey ,NA,NA
,"Delphi development is, first of all, great fun. The best way to learn how to build mobile 
 apps is to start by creating a few small apps. In this chapter, we are going to build a simple 
 Game of Memory
  application using primitive components such as layouts, shapes, effects, 
 and animations. We are also going to learn how to deliver a great mobile user experience 
 with touch, multitouch, and gestures.
  
 This chapter will cover the following points:
  
 Using shapes, effects, and animations
  
 Using images and image lists
  
 Controlling the user interface with layouts, alignments, anchors, and margins
  
 Learning about touch, multitouch, and gestures
  
 Using timers
  
 The objective of this chapter is to learn the basics of FireMonkey programming.",NA
Drawing in code,"The key to FireMonkey cross-platform support is its rendering architecture. When you 
 create a new multidevice project with Delphi, on the first page of the wizard you can choose 
 an application type. This effectively just selects the type of the first form to add to a new 
 app. You can choose 
 Blank Application
 . This will add to the project a form inherited from 
 TForm
 , which is a basic two-dimensional form. The second choice is 
 3D Application
 . This 
 will add a form inherited from 
 TForm3D
 . All other choices give you a 
 TForm
  descendant 
 with some additional controls already added. Check the following screenshot:
  
  
 [ 107 ]",NA
Get moving with timers,"Let's take one further step, and, instead of having a static scene, let's add an animation. It is 
 a normal thing for the sun to ascend in the morning. In order to achieve the effect of sunrise 
 every time the form is repainted, we will change the 
 y
  coordinate that is used for painting 
 the sun's circle and rays. Let's add to our 
 TFormSun
  class a private member 
 FSunPosY: double
 , 
 which will store the current vertical sun position.
  
 The simplest way to change our scene over time is with the 
 TTimer
  component. Drop 
 TTimer
  on the form. It has only one event, 
 OnTimer
 . The frequency of these events is 
 controlled by the 
 Interval
  property, which specifies the number of milliseconds between 
 firing the 
 OnTimer
  event. The default value of the 
 Interval
  property is 
 1,000
 , which means 
 that the timer fires its event every second. For a smooth animation, this is too much.
  
 Change the 
 Interval
  property to 
 20
  and double-click on the 
 OnTimer
  event. Here, we want to 
 constantly increment the 
 FSunPosY
  member that we will be using in the 
 OnPaint 
 event. We 
 also want to force the form to repaint itself. This can be done through 
 invalidating 
 the form's 
 canvas. Here is the updated drawing code that uses a timer to achieve the animation effect, 
 and we also use the canvas helper to simplify the drawing code:
  
  type
  
  TFormSunCodeAnim = class(TForm)
  
   
  PaintBox1: TPaintBox;
  
   
  Timer1: TTimer;
  
   
  procedure PaintBox1Paint(Sender: TObject; Canvas: TCanvas);
   
  
 procedure Timer1Timer(Sender: TObject);
  
   
  procedure FormCreate(Sender: TObject);
  
  private
  
   
  FSunPosY: double;
  
  public
  
   
  { Public declarations }
  
  end;
  
 var
  
  FormSunCodeAnim: TFormSunCodeAnim;
  
 implementation
  
 {$R *.fmx}",NA
Precise timing,"Note that the 
 TTimer
  component cannot be used for very precise timings. If your animation 
 code is time-sensitive, for example, when you are using a physics engine, it needs the exact 
 amount of time that elapsed from the last 
 OnTimer
  event. In this case, you could use the 
 TStopwatch
  record type from the 
 System.Diagnostics
  unit, which makes it easy to read the 
 precise timer information from the underlying operating system clock in a cross-platform 
 way. 
 TStopwatch
  needs to be initialized, so somewhere, for example, in the 
 OnCreate
  event of 
 the form, you need to call its 
 StartNew
  method. The 
 GetTimeStamp 
 method returns the 
 current number of underlying operating system 
 ticks
 , which is the most precise available 
 timing information. Luckily, there is also a 
 Frequency
  property, which gives us the number 
 of ticks per second. By dividing these two values, we can get the raw reference time in 
 seconds.
  
 Let's create a simple test app. Declare the 
 FLastTime: double
  private field in the form's class. 
 Drop a timer component and implement the 
 OnTimer
  event. The default value for the 
 Interval
  property is one second but, as we will see, it is never exactly one second between 
 every two 
 OnTimer
  events:
  
 uses
  
  System.Diagnostics;
  
 // ...
  
 procedure
  TFormTiming.FormCreate(Sender: TObject); 
  
 begin
  
  TStopwatch.StartNew;
  
  Log('Stopwatch Frequency = ' + TStopwatch.Frequency.ToString); 
 end;
  
 function
  TFormTiming.GetRawReferenceTime: double; 
  
 begin
  
  Result := TStopwatch.GetTimeStamp / TStopwatch.Frequency; 
 end;
  
 procedure
  TFormTiming.Timer1Timer(Sender: TObject);",NA
The power of parenting,"One of the nicest things about the FireMonkey architecture is 
 parenting
 . Essentially, any 
 FireMonkey component can contain, or 
 be a parent
  to, other components. What is cool about 
 it is the fact that all the children inherit different properties of their parents, such as position, 
 scale, and rotation. This also gives a lot of possibilities in building user interfaces because 
 we can create 
 composite
  controls without having to declare completely new classes.",NA
Shapes,"A lot of low-level drawing code can be avoided by using different controls from the 
 Shape 
 category on the 
 Tool Palette
 . There are lines, circles, ellipses, rectangles, pies, paths, and 
 more. They just encapsulate drawing on the canvas, so you need not write so much code.
  
 Let's try to recreate our sun visualisation with shapes to better compare these two possible 
 approaches to drawing. Add a new 
 Form HD
  to the project. Drop the 
 TRectangle 
 component on the form and align it to 
 Client
 . Change its 
 Name
  property to 
 rectSky
 .
  
 Expand its 
 Fill
  property and change 
 Color
  to 
 Skyblue
 . Drop the 
 TCircle
  component on the 
 form and name it 
 circleSun
 . Change its 
 Width
  and 
 Height
  properties to 
 100
  to make it 
 bigger, and its 
 Position.X
  and 
 Position.Y
  properties to 
 100
  to move it towards the top-left 
 corner of the screen. Change its 
 Fill.Color
  and 
 Stroke.Color
  properties to 
 Yellow
 . So far, we 
 have been changing the color, position, and dimension of FireMonkey shapes, but we can 
 also scale them horizontally and vertically, rotate them using 
  
 RotationAngle
  and 
 RotationCenter
  properties, as well as change their 
 Opacity
 . This gives a lot 
 of possibilities to show off your artistic skills while designing user interfaces with 
 FireMonkey.
  
 It is time to add some sun rays now! Make sure that the sun circle is selected on the form; 
 drop the 
 TLine
  component on it, and rename it to 
 LineRay01
 . Change 
 LineType
  to 
 Top
 , so it 
 is horizontal and not diagonal. Change its 
 Width
  and 
 Height
  properties to 
 100
 , its 
 Stroke.Color
  to 
 Yellow
 , and 
 Thickness
  to 
 5
 .",NA
Animations,"No coding, just shapes. The next step is to recreate the animation of the rising sun in the 
 new app, which is made of components only. The easiest way to add an animation is to use 
 special 
 animation
  components. On the 
 Tool Palette
 , there is a separate category for 
 Animations
 . There are different animation components for animating the values of different 
 types over time. There is 
 TFloatAnimation
  for changing float values, 
  
 TColorAnimation
  for changing colors, and so on.
  
 Instead of dropping an animation component on the form, we can create it directly from 
 inside the Object Inspector. In our demo, we would like to change the 
 Position.Y 
 property 
 of the circle component. Just expand this property in the Object Inspector and select the 
 option to 
 Create New TFloatAnimation
 . See the following screenshot:",NA
Programmable effects,"We can make our graphical user interfaces really stunning by using programmable effects. 
 These are also components, such as shapes and animation, with properties and events that 
 can be used to add this extra artistic touch to the FireMonkey user interfaces. They are 
 implemented using shader programs that are executed in the 
 Graphical Processor Unit 
 (
 GPU
 ), so they are very fast. See the following Effects:",NA
Touch me,"Up to this point, we were focusing on generating great graphics but with no user 
 interaction. Great apps are all about great user experiences. In order to get some 
 feedback from apps, users are busy touching the screen in all possible ways.",NA
Touch,"FireMonkey forms are used for building both mobile and desktop applications. It is just a 
 matter of changing the selected 
 Target Platform
  and recompiling the project. Certain 
 concepts exist on the desktop and do not exist on mobile platforms and vice versa. For 
 example, on mobile devices, there is no concept of a mouse, which does exist on desktops. 
 FireMonkey forms provide different mouse events, which, on mobile platforms, are fired in 
 response to simple touch events. When the end user touches the screen, the 
 OnMouseDown 
 event is fired. There are also other events such as 
 OnMouseUp
  and 
 OnMouseMove
  that are 
 fired when the the end user stops touching the screen, or when the touch point changes. For 
 individual controls, the 
 OnMouseEnter
  and 
 OnMouseLeave
  events are additionally defined.
  
 If a scene is built in code, then we can just implement mouse events on the form itself. It is 
 more common in FireMonkey to create visualisations with shapes and complex controls. 
 Higher-level components, such as 
 TButton
 , offer events such as 
 OnClick
  that centralize 
 touch support. When building a scene just with shapes, we need to understand how touch 
 events work.
  
 Every shape component derives from the 
 TControl
  class. In this class, all user interactions, 
 including touch, are handled. If a control does not need to respond to touch events, we can 
 set its 
 HitTest
  property to 
 False
 . This can be important when we are combining different 
 primitive shapes into something more complex. Typically, we just want the parent shape to 
 receive touch events.
  
 Let's modify our 
 sun
  app, so the end user will be able to change the position of the sun. This 
 involves handling the 
 OnMouseDown
  and 
 OnMouseUp
  events. In the 
 OnMouseDown
  event, we 
 just set the Boolean flag that we are in the process of 
 moving
  and store the initial 
 x
  and 
 y 
 coordinates of the touch event. In the 
 OnMouseUp
  event, we do the actual 
 move
  operation 
 and reset the 
 Moving
  flag.
  
 There is also our initial 
 sun rising
  animation played when the app starts. We do not want the 
 end user to move the sun before it is in its target position on the form. That's why we also 
 add the 
 FReady: boolean
  private field to the form that is set to 
 False
  in the 
 OnCreate 
 event of 
 the form and set to 
 True
  in the animation's 
 OnFinish
  event.",NA
Gestures,"Another standard way to interact with a mobile app is to use more then one finger at a time. 
 FireMonkey supports handling standard and interactive gestures. Let's add to our sun demo 
 app support for interactive rotation.
  
 Make sure that the form is selected in the Object Inspector and expand its 
 Touch
  property. 
 Check the 
 Rotate
  gesture under the 
 Interactive Gestures
  subproperty. See the following 
 screenshot:
  
  
 Now we can respond to the selected gestures. Double-click on the 
 OnGesture
  event of the 
 form. In the generated event handler, there are two parameters. The first parameter is 
 EventInfo: TGestureEventInfo
 , which contains all the information about the gesture that was 
 detected. Inside the 
 FMX.Types
  unit, we can find the declaration of the 
  
 TGestureEventInfo
  record and the corresponding types:
  
 type
  
  TInteractiveGestureFlag = (gfBegin, gfInertia, gfEnd); TInteractiveGestureFlags = 
 set of
  TInteractiveGestureFlag;",NA
Multitouch,"Sometimes, users touch the app with multiple fingers at the same time. With multitouch, we 
 can provide a really nice user experience.
  
 Let's create a new multidevice Delphi project. Drop 
 TPaintBox
  on the form, and align it to 
 Client
 . Save the app as 
 TouchApp
  and the form as 
 uFormTouch
 . Instead of drawing directly 
 on the paint box canvas, we can also draw on the offline bitmap and draw the whole 
 bitmap in one operation. This setup can be useful to achieve more complex 
  
 animations.",NA
Game of Memory,"Let's put together the things that you have learnt about FireMonkey architecture so far, and 
 let's build a complete, but simple, game. In the process, we will look at how to handle 
 images with the 
 TImageList
  component and some basics of building FireMonkey 2D user 
 interfaces.",NA
Designing the game,"Game of Memory
  is a board game. Player is presented with a grid of tiles. Every tile has an 
 image, but all images are initially hidden. When the user touches a tile, its image is 
  
 revealed. When the next tile is touched, the image of the currently visible tile is made 
 hidden again, and the image of the new tile is shown. So, at every moment during the game, 
 only one image is shown. The number of tiles has to be even, because every image is used 
 twice. The objective of the game is to remove all the tiles in the minimum possible time, by 
 touching the tiles with the same image one after another. If a user touches another tile with 
 the same image as the currently visible tile, both tiles are removed from the grid. This 
 process continues until there are no more tiles in the grid and the game ends. The score is 
 the time that elapsed from the beginning of the game to the moment when the last two tiles 
 where removed. The shortest time is the best.
  
 In order to make our game more interesting, we are going to let the player choose the initial 
 size of the grid, from a really small one, which should only take a couple of seconds to 
 complete, to bigger ones, which will take longer. We are also going to keep track of the top 
 scores for each grid size.
  
 We have already started building this game in 
 Chapter 2
 , 
 Mind Your Language
 , there is a 
 main form called 
 FormMain
 , which we are going to use to display the game tiles. We will 
 also add buttons to control starting, pausing, and stopping the game. The second form is 
 FormSettings
 , which is displayed from within the main form. This form is created in a 
 lazy 
 fashion
 . Not at app startup but at the moment when the player clicks on the Settings 
 menu
  
 button for the first time. On this form, we are going to change the current difficulty level 
 and display the best times for each size of the grid.",NA
Working with images,"The key asset of our game are images to be used on the back of every tile. There will be at 
 least as many images as the number of pairs at the highest difficulty level, plus two 
 additional images. The first image in the list will be completely white and will be used for 
 removed tiles. The second special image will be used as a 
 cover
  for every hidden tile. Before 
 every new game is started, we are going to randomly assign image pairs to tiles, so the 
 board layout is different every time.",NA
Designing a user interface,"We now have a set of images ready to be used in the visual part of the app. Let's move to 
 building the main form of the 
 Game of Memory
 , where the end user will be spending most of 
 his time unhiding tiles and removing them from the grid.",NA
"Aligning, anchoring, and margins","We have been using the 
 Align
  property quite a lot already. Regardless of a given control 
 size, we can instruct it to align itself to a portion (or to the entire area) of its visual container. 
 This is where FireMonkey parenting comes in. When designing user interfaces, we have to 
 decide which visual components should act as containers for other components. The relative 
 position of the children components can be controlled with the 
 Alignment
 , 
 Anchors
 , and 
 Margins
  properties.
  
 TAlignment
  is an enumerated type with many values, but in practice we mostly just use 
 alignment to 
 Client
 , 
 Top
 , 
 Bottom
 , 
 Left
 , and 
 Right
 .
  
 The 
 TAnchors
  property is a set of 
 Top
 , 
 Bottom
 , 
 Left
 , and 
 Right
  Boolean values that can be used 
 to 
 snap
  a given side of the control to its visual container. By default, a control is anchored to 
 the top and left sides of its parent. Anchors control how a visual component reacts to the 
 resizing of its visual container. For example, if we set the 
 Right
  anchor to 
 True 
 and make the 
 container wider, the child control will get wider as well, preserving the original distance 
 between the right side of the control and its container. Setting just the 
 Bottom
  and 
 Right
  
 anchors to 
 True
  and the others to 
 False
  can be useful for buttons in dialog screens, where we 
 always want them to be in the bottom-right corner of the form, regardless of its size. 
 Examine the following screenshot:",NA
Layouts,"During the user interface design in FireMonkey, we typically group controls in visual 
 containers. FireMonkey comes with different components in the 
 Layouts
  category in the 
 Tool Palette
  that do not have a visual representation at runtime, but their sole purpose is to 
 act as containers for other visual and non-visual controls. Examine the following screenshot:
  
  
 The most generic component is the 
 TLayout
  component. It is just a simple container for 
 other controls and is most commonly used to organize FireMonkey user interfaces.",NA
Building the games main form,"In our game, we have a visual grid of tiles. The most natural component to use in this 
 context is the 
 TGridLayout
  component. Drop it on the main form of our app, change its 
 Name
  property to 
 GridLayoutTiles
 , and align it to 
 Client
  so that it occupies the whole 
 screen of the main form under the toolbar. Now, we can add other visual controls to the 
 grid layout. The size of each item in the grid layout can be controlled with its 
 ItemHeight 
 and 
 ItemWidth
  properties.",NA
Storing the game's configuration,"The last part is to implement the functionality to remember the currently selected difficulty 
 level and to keep track of top scores. We are going to add to the game's data module the 
 FIniFile: TIniFile
  private fields from the 
 System.IniFiles
  unit. In the 
 OnCreate 
 event of the data 
 module, we will instantiate this class and will free it in the 
 OnDestroy 
 event. The constructor 
 of the 
 INI
  file object requires us to specify the path and filename; in our case, this will be the 
 Documents
  folder on a given target platform.
  
 Storing the app configuration information in an 
 INI
  file is very convenient. The 
 TIniFile 
 class 
 has the 
 read
  and 
 write
  methods for getting and setting the values of different types, such as 
 strings, numbers, time, and so on. An 
 INI
  file is a plain text file with key-value pairs 
 organized into sections.
  
 We are going to declare two public methods on the data module class for reading and 
 writing the top times for different difficulty levels. If there is no top score, we will enter 
 -1 
 as a special value. There will also be the 
 ClearAllScores
  method to remove all the top scores.",NA
The game's settings form,"Our game is almost complete. We are storing the top scores for different levels, but there is 
 no place to see them. This is the purpose of the game's 
 settings
  form.
  
 Drop a label component on the 
 FormSettings
  toolbar and align it to 
 Client
 . Change its 
 Text
  
 property to 
 Top Scores
 .
  
 Drop the 
 TButton
  component on the tool bar and align it to 
 Right
 . Change its 
 Name 
 property to 
 btnClear
  and its 
 Text
  property to 
 Clear All
 .
  
 Drop 
 TComboBox
  on the form. Align it to 
 Client
 . Change its 
 Margins
  properties to 
 8
 , so there 
 is a nice border around it. Right-click on the list box and select the 
 Add TListBoxItem 
 option to add the first item to the list box. Change its 
 StyleLookup
  property to 
  
 listboxitemrightdetail
 . Expand the 
 ItemData
  property and enter into the 
 Text 
 property 
 4 Pairs
 . 
 The 
 Detail
  property is where we are going to display the best time for a given difficulty 
 level. Right-click on the list box item and select 
 Copy
  from the 
 Edit
  menu.
  
 Paste the list box item seven times into the list box and adjust the 
 Text
  property of every 
 item. Change their names so they correspond with the number of pairs: 
 lbi04
 , 
 lbi06
 , 
 lbi08
 , 
 and so on until 
 lbi18
 .
  
 List boxes are great for all kinds of static information. At design time, you can easily set 
 them up. For dynamic information, coming from a database, for example, it is much better 
 to use the 
 TListView
  components.",NA
Summary,"In this chapter, you learned the fundamentals of FireMonkey 2D programming. Starting 
 from writing low-level code for drawing on canvas, we have quickly got to the 
  
 fundamentals of rapid app development with reusable shapes, animations, effects, and 
 timers. This is where Delphi shines and you are well on the path to becoming a developer 
 superhero who writes less code to achieve better results.
  
 In the next chapter, we are going to add an additional dimension to what we have seen so 
 far. We will go into the realm of FireMonkey 3D.
  
 [ 149 ]",NA
FireMonkey in 3D ,NA,NA
,"3D programming is where the Delphi mobile development shines. With 
 FireMonkey
 , we 
 can create fully cross-platform GPU-powered graphical user interfaces using different 3D 
 APIs on different platforms. In this chapter, we are going to add the third dimension to our 
 FireMonkey projects.
  
 This chapter will cover the following points:
  
 Using the TViewport component
  
 Working with camera and lights
  
 Using the TDummy component as a convenient non-visual 3D container
  
 Simple 3D shapes
  
 3D controls and material components
  
 Using the TModel3D component for importing 3D data from third-party 3D 
  
 graphics modeling tools
  
 The objective of this chapter is to learn FireMonkey 3D programming and building of 
 interactive cross-platform 3D GUIs.",NA
Cross-platform 3D rendering,"Abstracting away the underlying 3D API from the programmer is the foundation of the 
 FireMonkey graphics architecture. On top of this basis there is the second pillar, rapid 
 application development with components. The FireMonkey framework comes with pre-
 built, reusable 3D components that make it easy to write complex 3D applications.",NA
Using Context3D,"Similarly to FireMonkey 2D architecture, there are two possible approaches to 3D 
  
 rendering. We can render in code or use reusable components. The first path is what is used 
 by many other programming languages and development environments. The more complex 
 and sophisticated our 3D visualization, the more complex our 3D rendering code becomes. 
 Using 
 Rapid Application Development
  (
 RAD
 ) with components very quickly pays off as 
 we typically do not need to write too much code to build a great user experience with 
 interactive 3D worlds.",NA
Custom Wireframe component ,"The source code of FireMonkey is very helpful in understanding how the library works, but 
 we can also use it as a template to build our own custom components. Rendering a cube is 
 not a lot of code but using a similar approach, we could create a custom wireframe 
 component that is similar to 
 TStrokeCube
 . We can just implement the 
 Render
  method 
 differently and paint arbitrary lines, the coordinates of which are stored internally within 
 our component.
  
 Create a new Delphi multi-device application and select 
 3D Application
  as the application 
 type. Save the main form unit as 
 uFormWireframe
  and the whole project as 
  
 WireframeTest
 . Rename the form as 
 FormWireframe
 . Save all.
  
 Add a new unit to the project and save it as 
 uWireframe
 . Here we are going to implement a 
 custom component called 
 TWireframe
  that, similarly to 
 TStrokeCube
 , inherits from the 
 TControl3D
  class and renders an arbitrary wireframe by drawing lines.
  
 Drawing a wireframe is based on just two data structures. We need a list of vertices that are 
 locations in 3D space and a list of edges, which represents lines to be drawn. Each edge 
 contains two indices in the list of vertices for the starting and ending point of a line. Let's 
 define these two data structures in the 
 uWireframe
  unit. Have a look at the following code 
 snippet: 
  
  
 unit
  uWireframe; 
  
  
 interface 
  
  
 uses
  
  
  System.Math.Vectors, // TPoint3D
  
  
  System.Generics.Collections; // TList<T> 
  
  
 type
  
  
  TPoints3D = class(TList<TPoint3D>);
  
  
  TEdge = record
  
  
    
  A, B: integer; 
  
  
  
 end;
  
  
  TEdges = class(TList<TEdge>) 
  
  
    
 procedure
  AddEdge(pStart, pEnd: integer); 
  
  
  
 end; 
  
  
 implementation 
  
  
 { TEdges }",NA
Objects 3D,"There are different 3D objects that we can use in our Delphi FireMonkey apps. From really 
 simple ones, such as 
 TStrokeCube
  or 
 TGrid3D
 , that just render a few lines in 3D space, to 
 more complex components that maintain their own vertex and index buffers for drawing 
 complex geometries with triangles. This is a typical approach for rendering arbitrary 
 geometries in 3D apps, for example mobile games, and it requires quite a lot of coding.",NA
Moving Earth,"We are going to start with something simple and create an interactive 3D visualization of 
 the rotating Earth in deep space. To make it interactive, we will implement a 3D touch event 
 to move Earth closer and further from the viewer. This first example will be as minimal as 
 possible to demonstrate how quickly you can build a 3D app with FireMonkey.
  
 Create a new Delphi multi-device project and select 
 3D Application
  as the application type. 
 Save the form unit as 
 uFormEarth
  and the project as 
 MovingEarth
 . Change the 
 Name 
 property 
 of the form to 
 FormEarth
  and its 
 Color
  to Black.
  
 The next step is to add a 
 TDummy
  component to the form. This component acts as a 
 container for other 3D components and is very useful for applying common transformations 
 to a group of 3D objects. It does not have any visual representation at runtime. In the 
  
 FireMonkey 2D world, the 
 TLayout
  component plays a similar role. In the world of 
 FireMonkey 3D, the concept of parenting is also very important. Most FireMonkey 
  
 components can own other components, and owned components inherit different 
  
 properties from their owners including geometrical transformation, such as moving, scaling, 
 and rotations. It is a common pattern to use one 
 TDummy
  component as a parent for all other 
 visual and non-visual 3D objects. In this way, we have one central point for manipulating 
 the 3D scene as a whole, changing its position, rotation, and so on.
  
 Drop the 
 TDummy
  component on the form. Change its 
 Name
  property to 
 DummyScene
 . 
 Drop the 
 TSphere
  component on the form and make sure that it belongs to the root dummy 
 control. Rename the sphere to 
 SphereEarth
 . Let's make Earth bigger. Select the root dummy 
 component in the 
 Object Inspector
 . Expand its 
 Scale
  property and change all three 
 X
 , 
 Y
 , 
 and 
 Z
  values to 
 5
 . Notice that the contained sphere changed its size. In this way we control 
 the scale, rotation, and position of all 3D objects that make up the scene.
  
 Drop 
 TTextureMaterialSource
  components on the form and connect it with the sphere using 
 the 
 SphereEarth.MaterialSource
  property. Click on the ellipsis button next to the 
 Texture
  
 property and click on 
 Edit
 .",NA
Building an interactive 3D scene,"In the first example, we wanted to keep things simple. This time, we are going to build an 
 interactive visualization of three 3D arrows marking the beginning and orientation of the 3D 
 coordinate system used in FireMonkey. For this we will just use some cylinder and cone 3D 
 objects, color materials, lights, and an explicit 
 TCamera
  component. We will also see how to 
 implement looking at the scene from different points of view and distances.
  
 Create a new Delphi multi-device project. This time, make sure to select 
 Blank Application 
 template and not 
 3D Application
 . Save the form unit as 
 uFormArrows3D
  and the project as 
 Arrows3D
 . Change the 
 Name
  property of the form to 
 FormArrows3D
 .",NA
Using 3D models,"Until now, we have been using different out-of-the-box 3D objects that come with built-in 
 geometries. The FireMonkey library provides the 
 TModel3D
  component that makes it 
 possible to use geometries defined outside of Delphi, typically using a 3D modeling 
 software and importing mesh data from one of the supported 3D file formats.
  
 FireMonkey supports importing 3D models from OBJ, DAE, and ASE file formats. These are 
 standard formats supported by many 3D modeling software packages.
  
 If you have 3D modeling artistic skills then you can create your own models. Many 
 programmers don't, so they need already existing models for their 3D apps. There are many 
 websites offering free and commercial 3D models. One of them is 
 www.turbosquid.com 
 where I 
 found a nice royalty-free OBJ model of a medieval helmet (
 https://www.turbosqui d.com/3d-
 models/free-3ds-model-medieval-helmet/681191
 ).",NA
Starfield simulation,"In this section, we will be looking into building efficient 3D visualizations that use multiple 
 geometries. We will create a starfield simulation using 
 TSphere
  and 
 TObjectProxy 
 components for sharing mesh data.
  
 If we look into the source code of 
 TSphere
 , 
 TCone
 , 
 TCylinder
  and other components in the 
 FMX.Objects3D
  unit, we will see that their vertices and indices are hardcoded. If we want to 
 build a 3D scene with many different objects, every object will occupy quite a lot of space in 
 memory.
  
 FireMonkey comes with a special 
 TProxyObject
  3D object. It does not hold its geometry, but 
 instead has the 
 SourceObject
  property that can be used to connect to any other 3D object 
 which is used for rendering. In this way, we have just one copy of geometry data in 
 memory and multiple objects rendered.
  
 To illustrate this concept, let's build a starfield simulation with many sphere objects moving 
 in space. That's similar to a classic Windows screensaver. We will just use one instance of a 
 TSphere
  component and all other spheres will be rendered with proxy objects.
  
 Create a new Delphi multi-device application and select 
 Blank Application
  from the 
 application templates gallery. Save the form's unit as 
 uFormStars
  and project as 
 Starfield
 . 
 Change the 
 Name
  property of the main form to 
 FormStars
 . Save all.
  
 Drop the 
 TViewport3D
  component on the form. Align it to 
 Client
  and change its color to 
 Black
 . This is the deep space. Drop the 
 TCamera
  component on the viewport and 
 TLight 
 component on the camera. Connect the 
 Camera
  property of the viewport to point to 
 Camera1
  
 and set its 
 UsingDesignCamera
  property to 
 False
 . Drop the 
 TDummy
  component on the 
 viewport and change its 
 Name
  to 
 DummyScene
 . Now drop 
 TSphere
  component on the 
 dummy scene component. Change its 
 Name
  to 
 SphereStar
 . It will serve as the main holder of 
 the sphere geometry. Change its 
 Position.Z
  property to 
 -10
 , so it is behind the camera. Drop 
 the 
 TLightMaterialSource
  component on the form and set the sphere's 
 MaterialSource
  property 
 to point to the material component. We should see the sphere turning from red to nice 
 shades of gray.",NA
Mixing 3D and 2D,"In FireMonkey, you can mix 2D with 3D. In a 3D form we can use 2-dimensional user 
 interface controls, or we can embed the special 
 TViewport3D
  component in a standard 
 FireMonkey 2D form to do some 3D rendering.
  
 In this example, we are going to add some special visual effects by building a 2D user 
 interface in 3D space. This will allow the user to interact with the app in a traditional way, 
 but we could do some extra things like rotating or moving the whole user interface in 3D 
 space for a surprising user experience.
  
 Create a new multi-device Delphi project and select 
 Blank Application
  as the application 
 type. Save the main form's unit as 
 uFormTwistMe
  and the whole app as 
 TwistMe
 . Change 
 the 
 Name
  property of the form to 
 FormTwistMe
 . Drop the 
 TViewport3D
  component on the 
 form and align it to 
 Client
 .
  
 On the Tool Palette, we can find the 
 3D Layers
  category with different 3D controls for using 
 normal 2D controls. In this demo we will use the 
 TLayer3D
  component to pretend that the 
 user interface is 2D, but at any moment in time we can do something in 3D to achieve an 
 interesting user experience. Have a look at the image below:",NA
Summary,"In this chapter, we have explored the world of FireMonkey 3D programming.
  
 With components, the FireMonkey parenting architecture, and cross-platform rendering it is 
 possible to build stunning 3D interactive visualizations with little or no code that can be 
 natively compiled for all major mobile and desktop platforms. That's a unique capability in 
 the market today!
  
 In the next chapter, we are going to see one of the most important aspects of FireMonkey 
 architecture: styling!
  
 [ 182 ]",NA
Building User Interfaces with ,NA,NA
,NA,NA
Style,"If you ever need to choose the single most important concept to understand in Delphi cross-
 platform programming that would probably be the concept of styles. Styling is the 
  
 cornerstone of the cross-platform FireMonkey architecture. Styles are used at different 
 levels. There are platform-specific, built-in styles that you use when you create a multi-
 device project and switch between styles in the form designer. FireMonkey controls on a 
 form have a 
 StyleLookup
  property, which can use a specific style for a given component.
  
 You can also apply a custom style using the 
 TStylebook
  component. Finally, with the built-
 in style editor you can visually customize a given style item in the stylebook as easily as 
 you would customize a component on the form. The goal of this chapter is to give you a 
 solid understanding of FireMonkey styles to build stunning graphical user interfaces.
  
 This chapter will cover the following points:
  
 Using built-in styles and style lookups
  
 Using custom styles with the stylebook component
  
 Customizing styles with Style Editor
  
 Using Frames
  
 Using inherited views for specific form factors
  
 Previewing forms on devices",NA
Working with built-in styles,"The look and feel of every FireMonkey control depends on a style. There is only one 
 codebase of your app, but when you compile it for a given platform, there is a different style 
 used to render any control. In this way the 
 magic
  is possible. The same app running on iOS 
 will look like a regular iOS app, and when compiled for Android, it will look like an 
 Android app. You can also compile the project for desktop targets and then an appropriate 
 Windows or Mac style will be used.
  
 Delphi comes with built-in styles. When you create a new multi-device application, during 
 the design-time, you can preview how a given form will look with a different style applied.
  
 Let's give it a try. Create a new multi-device blank application. Save the main form unit as 
 uFormStylesTest
  and the whole project as 
 StylesTest
 . Above the form designer area there is a 
 Style
  combo-box where you can change the style that is used to preview the form you are 
 working with. See the following screenshot:
  
  
 Style selection combo-box in FireMonkey Form Designer
  
 The selection of a style in the 
 Style
  combo applies different styles to the form we are 
 working with, so we can see how a given form will look when it is compiled for the selected 
 platform. Drop a 
 TToolbar
  component on the form and then a 
 TSpeedButton
  on the toolbar. 
 Align the speed button to 
 Left
  and make it slightly wider, so the whole caption is visible.
  
 When we change the style in the 
 Style
  combo from 
 Android
  to 
 iOS
 , we can see that the 
 look-and-feel of the speed button changes accordingly to match selected platform design 
 guidelines.",NA
Using custom styles,"If we do not want to use a built-in style, we can always use a custom style. The Delphi 
 installation comes with a number of custom styles. In Delphi 10.2 on Windows 10, 
 FireMonkey custom styles are installed into the 
  
 C:�sers\Public\Documents\Embarcadero\Studio\19.0\Styles
  directory. FireMonkey styles 
 are files with the 
 *.style
  extension. If we preview a FireMonkey style file with a text viewer, 
 we will see that its content looks very much like a form file that we design with 
 Form 
 Designer
  inside the IDE.
  
 It is good practice not to put non-visual components such as stylebooks directly on the 
 form, but on a dedicated data module instead. Select 
 File
  | 
 New
  | 
 Other
  from the main 
 menu. In the 
 New Items
  dialogs, select the 
 Delphi Files
  category and choose to add a new 
 Data Module
  to the project:
  
  
 New Data Module in New Items dialog",NA
Embedding styles as resources,"Let's have a look at the process of embedding custom styles into an app as a resource. Using 
 custom resources is not limited to embedding. We can embed arbitrary files, for example, 
 video, audio, custom graphics, data, or anything.
  
 Remove the data module with style book components, because now we are going to load a 
 custom style differently. In order to verify that the custom is loaded globally for all forms, 
 we are going to add an additional form to the 
 StyleTest
  app. Add an empty FireMonkey 
 HD form to the project. Save the form's unit as 
 uFormExtra
  and change the 
 Name
  property 
 of the new form to 
 FormExtra
 . Add the new form to the 
 uses
  clause of the main form. In the 
 OnClick
  event of the 
 menu
  speedbutton of the main form, add one line of code to display the 
 new form.
  
 The code will display 
 FormExtra
  when the end user clicks on the button:
  
 uses
  uFormExtra;
  
 procedure
  TFormStylesTest.SpeedButton1Click(Sender: TObject); 
 begin
  
  
  FormExtra.Show; 
  
 end;
  
 We will leave the form completely blank. A form itself will have a custom 
  
 backgroundstyle
  applied. If we preview the 
 transparent
  style definition from the previous 
 example, we will see that the 
 backgroundstyle
  definition is just a rectangle with a custom 
 gradient fill.",NA
Customizing styles,"FireMonkey styling gives us a lot of flexibility. We can use built-in styles. Within a built-in 
 style there could be multiple style definitions for a given control. There is also the 
  
 possibility of using a custom style. But what if we want to apply a really special look to our 
 styled control? We can go one step further and customize built-in or custom styles.
  
 Remove custom resources and a call to load the style from the project's source.",NA
Using frames,"Certain combinations of controls can be reused easily with frames.
  
 Developer productivity often relies on being able to reuse previous work. Delphi projects 
 consist of forms, data modules, and source code units. If you have an existing unit, it can 
 always be added to a new project. On a smaller scale there are occasions when it is desirable 
 to reuse certain combinations of components. This is where 
 frames
  come in. If you have a 
 few controls working together that you would like to reuse multiple times in the same or 
 multiple forms then you can use frames.
  
 Frames cannot exist on their own. They always need to be embedded in a form. They can 
 contain controls and code.
  
 Let's consider address information. Imagine we are designing a form with different controls 
 for storing contact data. Our 
 contact
  can have a home and office address. We can simplify 
 our form and make it more user-friendly by defining a custom frame for address 
  
 information and using it twice in the same form.",NA
Working with inherited views,"When we design the form, it is the same for all platforms, form factors, and orientations. We 
 can preview how the form is going to look on different platforms, but the design is the 
 same. FireMonkey Form Designer lets us define inherited views that are specific to a given 
 platform and the form factor. Next to the 
 Style
  combo box at the top of the Form Designer 
 there is another combo box, 
 View
 . Here we can add to our form additional form files that 
 are specific to a given platform and a form factor.
  
 Every form always has a built-in 
 Master
  view. From the list we can add additional views.
  
  
 Available inherited views in the FireMonkey Form Designer
  
 [ 212 ]",NA
Previewing forms on devices,"Delphi Form Designer gives us the 
 what you see is what you get
  functionality, but we can go 
 one step further and use Delphi built-in functionality to preview the form we are designing 
 live on a physical device. For this we will have to download a special mobile app published 
 by Embarcadero Technologies called 
 FireUI App Preview
 . It is available from both Apple 
 App Store and Google Play Store. Refer to the following screenshot:
  
  
 [ 218 ]",NA
Summary,"Building graphical user interfaces with Delphi and the FireMonkey library requires 
 understanding the concept of a style. Styles in FireMonkey user interface design play a 
 similar role to cascading style sheets in web development.
  
 Every FireMonkey app uses a style. This could be a built-in style or a custom style loaded 
 from the 
 TStylebook
  component or from an embedded resource. The integrated 
 FireMonkey Style Designer let us modify existing styles as easily as designing a form.
  
 We have learnt a lot about building user interfaces with FireMonkey. In the next chapter, 
 we will delve more deeply into the rich world of different frameworks available on the iOS 
 and Android operating systems, and how FireMonkey helps us write cross-platform code 
 that abstracts away the differences between different APIs.",NA
Working with Mobile Operating ,NA,NA
,NA,NA
System,"In this chapter, we are going to move from playing with FireMonkey to building useful 
 cross-platform apps that are accessing mobile hardware and operating systems with high-
 level components, abstracting away underlying mobile APIs.
  
 This chapter will cover the following points:
  
 Sensors
  
 Camera
  
 Share sheets
  
 Address book
  
 Embedding web browsers
  
 Using maps
  
 Creating and consuming Android services
  
 Using language bridges for accessing Java and Objective-C code
  
 The objective of this chapter is to learn how to create native cross-platform apps that are 
 using different frameworks and functionality provided by mobile operating systems.",NA
James Bond's toy,"Contemporary mobile hardware does not significantly differ in capabilities from agent 
 Bond's gadgets from just a few years ago. Your mobile phone is equipped with all kinds of 
 sensors that you can use in your mobile apps, including location, orientation, motion, 
 ambient light, microphones, speakers, cameras, and plenty of other hardware that you can 
 control.
  
 An app is immersed in the operating system, which is in charge of every aspect of an app 
 execution. In your code, you can respond to different app lifecycle events such as start up, 
 switching to background execution, moving back to the foreground, or app termination. In 
 the end, it is all about responding to different events sent by the operating system and 
 invoking operating system APIs. The FireMonkey library encapsulates access to common 
 mobile operating system functionality through specialized types, classes, and components, 
 but there is nothing that can stop you from invoking arbitrary APIs directly in your code.
  
 Sometimes this could be the only way to achieve certain things, like for example making 
 your phone vibrate. Luckily most of the time, you can use cross-platform components and 
 libraries that generalize common functionality such as accessing maps, contacts, embedding 
 web browsers, and sharing data with other apps and services.
  
 Different mobile operating systems provide functionality that might not exist on other 
 platforms or in older versions of the same system. In such cases, we might want to write 
 code against a specific feature on a specific platform. In this chapter, we are going to see 
 how to invoke mobile APIs through Delphi language bridges. We will also see how to deal 
 with features unique to iOS or Android, such as using and creating Android services.",NA
What I'm running on?,"Building apps for multiple operating systems from the very same source code imposes 
 unique challenges. Your code might be running on iOS or Android. It only takes two mouse 
 clicks to recompile your app for a different target. Certain features might exist on a given 
 platform and not be there on other platforms. Going further, new functionality is constantly 
 being added to platforms, so we may want to know on which platform and operating 
 system version your app is being executed.",NA
The life of an app,"An app is not a lonely island. It is always executed by the operating system, within bounds 
 that it imposes. Depending on the type of the app, we could be interested in responding to 
 different application lifecycle events that the operating system sends to it. Every operating 
 system has a slightly different app lifecycle model, but in the case of mobile the most tricky 
 part could be properly handling the situation when our apps move from foreground 
 execution to background, and back.
  
 FireMonkey provides common abstraction for handling an application lifecycle 
 through different types of application events defined in the 
 FMX.Platform
  unit:
  
 type
  
  TApplicationEvent = (FinishedLaunching, BecameActive, WillBecomeInactive, EnteredBackground, 
 WillBecomeForeground, WillTerminate, LowMemory, 
  
 TimeChange, OpenURL);",NA
Sensing the world,"Delphi comes with the 
 System.Sensors
  unit, where all kinds of possible sensors are defined. 
 Similarly to the 
 FMX.Platform
  unit, the 
 System.Sensors
  also has 
 ifdefs
  in its implementation 
 and a 
 uses
  clause for different platforms including Android and iOS.
  
 There is main 
 TSensorManager
  class that acts as a gateway to all sensor information. It has a 
 Current: TSensorManager
  class property that is used to reference all sensor 
  
 information. At the top of the 
 System.Sensors
  unit, you can find a 
 TSensorCategory 
 enumerated type that provides the top level categorization of all possible sensors:
  
 type
  
  TSensorCategory = (Location, Environmental, Motion, Orientation, Mechanical, Electrical, 
 Biometric, Light, Scanner);
  
 Within each category there are different sensor types, so each category has its own 
  
 enumerated type as well. All specialized sensor types derive from an abstract 
  
 TCustomSensor
  class that provides basic functionality that is common to all sensors, for 
 example, 
 Start
  and 
 Stop
  methods. In order to get access to individual sensors in code, you 
 need to call the 
 GetSensorsByCategory
  method of the 
 TSensorManager
  class that takes as a 
 parameter a sensor category and returns a dynamic array of available custom sensors.",NA
Taking photos,"On many occasions, it is useful to be able to take a photo from an app. The programming 
 model is very easy, but it is not the 
 TCamera
  component that you need to use. In 
  
 FireMonkey, taking photos is achieved by executing a special ""take a photo from a camera"" 
 action.
  
 Create a new multi-device FireMonkey blank application. Save the main form's unit as 
 uFormCam
 , the project as 
 CamApp
 , and change the 
 Name
  property of the form to 
 FormCam
 .
  
 Change the 
 Style
  in the combobox above the form to 
 iOS
  or 
 Android
 . Drop 
 TToolbar 
 and 
 TImage
  components on the form. Rename the image as 
 ImagePhoto
  and align it to 
 Client
  and 
 drop 
 TSpeedbutton
  onto the 
 Toolbar1
 . Change its 
 Name
  to 
  
 spdbtnTakePhoto
  and the button's 
 Stylelookup
  property to 
 cameratoolbutton
 ; align it to the 
 Left
  
 and adjust the width so it becomes a square. Save all.
  
 Drop the 
 TActionList
  component on the form and double-click on it to display the 
 Action List 
 Editor
 . Right-click on the editor and select the 
 New Standard Action... 
 option from the 
 context menu. Expand the 
 Media Library
  category and double-click on the 
 TakePhotoFromTheCamera
  action to add it to the list of actions.",NA
Using share sheets,"Our app is already very spectacular, but it is not very useful. The photo is displayed in the 
 form, but it goes away when we stop the app or take another photo. It is a typical 
  
 functionality in operating systems to be able to 
 share
  things with other installed apps. For 
 example, we might want to share a photo on social media or send it by email. This can be 
 easily achieved through share sheets that are also available through actions.
  
 Drop another 
 TSpeedButton
  on the toolbar. Rename it to 
 spdbtnSharePhoto
 , change its 
 StyleLookup
  property to 
 actiontoolbutton
 , adjust its width and align it to the 
 Right
 . Expand 
 its 
 Action
  property in the 
 Object Inspector
  and, through the context menu, add the 
 standard 
 TShowShareSheetAction
  from the 
 Media Library
  category.
  
  
 TShowShareSheetAction in the context menu in Object Inspector
  
 [ 238 ]",NA
"Camera, light, action!","We can take photos with special action components, so what is the purpose of the 
  
 TCameraComponent
  component that can be found in the 
 Additional
  category on the tool 
 palette? A quick answer could be that it is the way to switch on and off the bright torch light 
 that most phones are equipped with. A more elaborate answer would be that it can be used 
 to make videos.
  
 The source code for switching on and off the integrated camera light is simple. Create a new 
 multi-device, blank application. Save the form's unit as 
 uFormVideo
  and the whole project as 
 VideoApp
 . Drop 
 TToolbar
  on the form and then 
 TCheckBox
  onto it. Rename the checkbox as 
 chkbxTorchLight
 , change its 
 Text
  property to 
 Torch Light
 , and align it to the 
 Right
 .
  
 Drop 
 TCameraComponent
  on the form. Not every device has a torch light, so first we want 
 to check in the code if the torch light is present and enable or disable the checkbox. The 
 natural place for such a check is in the 
 OnCreate
  event of the form.
  
 Add the following one line of code in the body of the 
 OnCreate
  event handler:
  
 procedure
  TFormVideo.FormCreate(Sender: TObject); 
 begin
  
  chkbxTorch.Enabled := CameraComponent1.HasTorch; 
 end;
  
 In the 
 OnChange
  event of the checkbox add the following code to turn the light on and off:
  
 procedure
  TFormVideo.chkbxTorchChange(Sender: TObject); 
 begin 
  
 if
  chkbxTorch.IsChecked 
 then
  
   
  CameraComponent1.TorchMode := TTorchMode.ModeOn 
 else
  
   
  CameraComponent1.TorchMode := TTorchMode.ModeOff; 
 end;
  
 There are also very similar 
 FlashMode
  and 
 HasFlash
  properties. On my iPhone they seem to 
 have exactly the same functionality as 
 Torch
 .
  
 [ 241 ]",NA
Working with address book,"The most valuable information in our smartphone is arguably all our contact information. 
 Before backing up a phone to a cloud was so common, when you lost a phone or got a new 
 one, the first thing was to find a traditional paper address book and enter all your contacts 
 again and again.
  
 Luckily, this is not something that we need to worry about so much today. There is cloud 
 storage and backup, but also it is possible to write an app that could manage our address 
 book. FireMonkey comes with the 
 TAddressBook
  component that makes it easy to add, 
 modify, delete, or just list all contacts in our device.
  
  
 The TAddressBook component on the tool palette
  
 This component is declared in the 
 FMX.AddressBook
  unit and its architecture follows the 
 FireMonkey standard pattern for implementing a cross-platform service. Under the hood, 
 the 
 AddressBook
  component is just an easy to use wrapper on top of the 
  
 IFMXAddressBookService
  service that has different platform-specific implementations.
  
 Contact information is sensitive, so the app that is trying to access it must be granted proper 
 privileges from the underlying operating system.
  
 Let's play with the 
 TAddressBook
  component to find out how to use it. Create a new multi-
 device, blank Delphi application. Save the form file as 
 uFormContacts
  and the project as 
 ContactsMgr
 . Drop a 
 TAddressBook
  component on the form. You will need to change the 
 target platform in the 
 Project Manager
  to one of the mobile targets, because otherwise the 
 TAddressBook
  choice is disabled in the tool palette.",NA
Notify me!,"One of the most common ways of attracting a mobile device user to a particular app is to 
 display a notification. When a new email arrives or somebody posts something on social 
 media, we are typically presented with a notification. Clicking on it displays the app that 
 sends the notification.",NA
Navigating the web,"The debate about whether native or web mobile apps are better seems to be over. A native 
 mobile app, like the ones built with Delphi, C++Builder, or Xcode are the most common 
 choice. However, sometimes it would make a lot of sense to combine these two different 
 worlds and create a hybrid solution where an app is still native, but it embeds a web 
 browser.
  
 Luckily, in FireMonkey there is a special 
 TWebBrowser
  component that makes it easy to 
 embed web browsing functionality in your app.
  
 Create a blank, multi-device application. Save the form as 
 uFormWebBrowser
  and the 
 project as 
 WebBrowserApp
 . Drop a toolbar component on the form. Drop the 
 TEdit 
 component on the toolbar and rename it as 
 edtURL
 . It will contain a URL for the web 
 browser component to navigate to. For convenience, you can already put a valid URL into 
 the 
 Text
  property of the edit so it is faster at runtime to see if our app is working correctly.
  
 This could be, for example, the web address of the Embarcadero community site at 
 https://community.embarcadero.com/
 . Now, drop 
 TSpeedButton
  on the toolbar.
  
 Change its 
 Name
  property to 
 spdbtnGo
 , 
 Stylelookup
  to 
 refreshtoolbutton
 , and its 
 Align
  property 
 to the 
 Right
 . Drop another two speed buttons on the toolbar. Change their 
 Name
  properties 
 respectively to 
 spdbtnBack
  and 
 spdbtnForward
 . Change their 
  
 Stylelookup
  properties to 
 arrowlefttoolbutton
  and 
 arrowrighttoolbutton
 . Align them both to the 
 Left
 . Now change the 
 Align
  property of the URL edit to 
 Client
  and its 
 Margin.Top
  property to 
 8
 , so there is a distance between the edit and the top of the form. Drop the 
 TWebBrowser
  
 component on the form and align it to 
 Client
 . Now, double-click on each speed button and 
 enter the simple code for web browser navigation:
  
 procedure
  TFormWebBrowser.spdbtnBackClick(Sender: TObject); 
 begin
  
  WebBrowser1.GoBack; 
  
 end;
  
 procedure
  TFormWebBrowser.spdbtnForwardClick(Sender: TObject);",NA
Working with maps,"One of the most useful components in mobile apps is a map. Delphi comes with the cross-
 platform 
 TMapView
  component that makes it easy to embed a map in an app.
  
 On Android, it uses the Google Maps Android API and on iOS it uses the Map Kit 
 Framework. On Android, it is necessary to first obtain the Google Maps API key. There are 
 different possible view types on each platform. A map can be displayed as 
 Normal
 , 
 Satellite
 , or 
 Hybrid
 . On Android there is also an additional 
 Terrain
  view mode.
  
 Let's build a simple app to try out different 
 TMapView
  features. Create a new multi-device, 
 blank Delphi app. Save the main form as 
 uFormMap
  and the project as 
 MapApp
 . Change the 
 Name
  property of the form to 
 FormMap
 . Drop 
 TToolbar
  on the form and a 
 TMapView 
 component. Align to 
 Client
 .
  
 Drop the 
 TComboBox
  component onto the toolbar. Rename it as 
 cmbbxMapType
  and add 
 five items to its 
 Items
  property that corresponds to five possible map types.
  
  
 MapType choices in the items property of the cmbbxMapType",NA
Creating and consuming Android services,"The key benefit of Delphi and C++Builder is to be able to create your app once, and from the 
 very same source code, natively compile it for different operating systems. In this book, we 
 are focusing on mobile operating systems, namely Android and iOS. Every system is 
 different and has different concepts that might not exist elsewhere. A good example of 
 something unique to a particular platform are Android services. This notion exists on 
 Android only and as such it cannot be ported to iOS or other operating systems.
  
 Delphi has a special project type and the IDE wizard for creating an Android service. It is 
 also possible to use an Android service, created with Delphi or not, in a regular multi-
 device project, but only if it is targeting Android.
  
 [ 257 ]",NA
Delphi language bridges,"So far, we have seen how to access cross-platform implementations of services such as 
 sensors, address book, maps, and others. All of them come out of the box. Luckily, Delphi 
 comes with the source code, so it is possible to inspect how Delphi itself is accessing the 
 underlying mobile APIs on Android and iOS. All supported operating systems are different 
 and there are different ways of accessing their raw APIs.
  
 Let's consider a simple example of making your mobile device vibrate in code. That is not 
 something that Delphi provides, but we can use this case to analyze the process of accessing 
 any functionality that is not readily accessible in Android and iOS.",NA
Vibrating on Android,"Android is based on Linux and Java. Accessing Android APIs requires being able to call 
 from Object Pascal into Java code. This is the role of the Object Pascal to Java language 
 bridge and this is how FireMonkey gets access to Android functionality. Before we can 
 access certain functionality in Android, we need to find the documentation and know what 
 Java class we want to access and what the methods we want to call are. Vibrations on 
 Android are accessible through the 
 Vibrator
  class declared in the 
 Android.os
  namespace and 
 derived directly from the base 
 java.lang.object
 . The online documentation of this class can be 
 found at 
 https://developer.android.com/reference/android/os/Vibrator .html
 .
  
 In the 
 source\rtl\Android
  folder under the Delphi installation, we can find a number of 
 Object Pascal units with names that start from 
 Android.JNI
 . These are files already imported 
 to Object Pascal. In the 
 Android.Jni.Os
  unit, we can find Object Pascal interfaces for different 
 Java classes imported from the 
 Android.os
  namespace, including 
 JVibrator
 . That's what we 
 need, but how do we use it in code? Browsing through the source code we can find two 
 interface declarations, 
 JVibratorClass
  and 
 JVibrator
 . The first interface represents class 
 methods of the given Java type and the second is for instance methods. The 
 TJVibrator
  class 
 derived from the generic 
 TJavaGenericImport
  glues these interfaces together. The 
 TJavaGenericImport
  class is defined in the 
  
 Androidapi.JNIBridge
  unit and it provides base functionality for importing all kinds of Java 
 classes:
  
 TJVibrator = 
 class
 (TJavaGenericImport<JVibratorClass, JVibrator>) 
 end;
  
 We want to call the vibrate method declared in the 
 JVibrator
  interface, but how do we get 
 access to it? Different Java classes can be accessed through the 
 SharedActivityContext 
 function 
 defined in the 
 Androidapi.Helpers
  unit that returns Java application context.
  
 The documentation says that we need to call the 
 getSystemService
  method and pass 
 VIBRATOR_SERVICE
  as argument. The 
 TJavaGenericImport
  class declares a handy 
 Wrap 
 method that lets us typecast from a raw pointer into the proper interface type.",NA
Vibrations on iOS,"Making an iOS device vibrate requires completely different steps as compared to Android. 
 Vibrations on iOS are available as part of the 
 AudioToolbox
  framework. In order to make an 
 iOS device vibrate, one needs to call the AudioServicesPlaySystemSound API function, 
 which is documented at 
  
 https://developer.apple.com/reference/audiotoolbox/system_sound_services
 .
  
 Similarly to Android, there are already a number of pre-imported units with interfaces to 
 iOS APIs in the 
 source\rtl\ios
  directory. The model is similar. Different frameworks have 
 their own import units with names starting from 
 iOSapi
 . There is also a generic class for 
 importing arbitrary 
 ObjectiveC
  classes defined in the 
 Macapi.ObjectiveC
  unit called 
 TOCGenericImport
  that serves a similar role as 
 TJavaGenericImport
 , for Android.
  
 Delphi installation comes with a number of iOS frameworks already imported. Go to the 
 Tools
  dialog and find 
 SDK Manager
 . Scroll down in the listbox. Unfortunately the 
 AudioToolbox
  framework is not imported to Delphi out of the box, so it is not listed as an 
 available framework and there is no 
 iOSapi.AudioToolbox
  unit in the source directory.",NA
Summary,"In this chapter, we have learnt how to work with functionality provided by different mobile 
 operating systems. Every system is different, but we can use high-level components and 
 cross-platform abstractions that make it possible to just recompile your project to a different 
 system from the very same source code.",NA
Extending to the Internet of ,NA,NA
,NA,NA
Things,"The possibility to integrate apps running on mobile devices with the world of Internet of 
 Things gadgets and wearables opens new and exciting possibilities for mobile developers.
  
 In this chapter, we are going to see how easy it is to use Delphi to integrate with the IoT 
 using 
 Bluetooth Low Energy
  (
 BLE
 ) communication. We are going to use specialized 
 ThingConnect
  components available with the 
 GetIt Package Manager
  for working with 
 devices such as heart rate monitors. The special type of BLE devices are beacons that you 
 can use to add precise indoor and outdoor location awareness to your mobile app. At the 
 end of this chapter, we are going to learn how to use the 
 BeaconFence
  framework for 
 building complete mobile microlocation solutions. We are also going to play with 
 App 
 Tethering
  technology that makes it super easy for two arbitrary apps to communicate with 
 each other over Bluetooth or TCP/IP.
  
 This chapter will cover the following points:
  
 Bluetooth Low Energy
  
 ThingConnect components
  
 Beacons
  
 BeaconFence
  
 App Tethering",NA
Communication protocols,"The 
 Internet of Things
  (
 IoT
 ) is based on the fact that a computer program can interact with 
 all kinds of devices, gadgets, and sensors. At the lowest level, interacting with a remote 
 thing
  needs to be done through a communication protocol.
  
 The world of IoT is very interesting because it is a relatively new concept. When technology 
 is not yet mature, it evolves very quickly and there are many competing solutions and only 
 a few standards. There is still nobody to dominate the IoT market. If you try to look up IoT 
 on the internet, you will find a lot of different answers. Every hardware and software 
 vendor will have a different opinion about what IoT is and how to do it.
  
 It always starts from a problem at hand, and how it can be solved. At one side of the IoT 
 landscape, there are systems based on long-range protocols, such as LoRa, which provide 
 bi-directional communication with sensors located within a radius of many kilometers, 
 possibly covering the whole city. On the other side of the IoT spectrum, there are protocols 
 such as NFC, which enables wireless communication between devices located only a few 
 centimeters away.",NA
Understanding BLE,"One of the most important communication protocols for IoT is Bluetooth. In fact, there are 
 two different Bluetooth technologies. The 
 classic
  Bluetooth and the newer, BLE, sometimes 
 called 
 smart
  Bluetooth; Bluetooth LE, or just BLE for short. The classic Bluetooth is useful for 
 data streaming and provides data transfer rates up to 2 Mbps. It is commonly used in cars, 
 especially in hands-free headsets. It has much higher data transfer rates as compared to 
 BLE, but also much higher energy consumption.
  
 BLE protocol has been designed with very low power consumption in mind, and uses a 
 different set of radio techniques than classic Bluetooth. Data transfer rates in Bluetooth LE 
 are relatively low, less than 100 Kbps. A big advantage of smart Bluetooth is the very fast 
 connection time, typically just a few milliseconds, because there is no 
 pairing
  process 
 involved, like in classic variant. BLE communication is based on the 
 Generic Attribute 
 Profile
  (
 GATT
 ) model. The whole GATT specification can be found at 
  
 https://www.bluetooth.com/specifications/generic-attributes-overview
 . The GATT model defines how 
 two BLE devices send and receive standard messages. Each GATT profile describes a use 
 case, roles, and general behaviors based on the GATT functionality. At 
 https://www.bluetooth.com/specifications/adopted-specifications
  you can find a list of different 
 adopted GATT specifications for connecting to different types of devices.",NA
Connecting to things with ThingConnect,"We have seen the steps to connect to an arbitrary BLE device using the 
 TBluetoothLE 
 component. For certain popular services, this can be even easier. Delphi comes with a 
 number of components that simplify working with standard services such as, heart rate 
 monitors, blood pressure monitors, and proximity sensors. There are also components 
 available in GetIt for working with specific devices from specific vendors using not only 
 BLE, but also other IoT protocols, such as Z-Wave.
  
 Under the 
 Tools
  menu, you can find the 
 GetIt Package Manager
 . In order to use GetIt, you 
 will need to have an internet connection. Over time, more and more new and updated 
 software is available in GetIt. One of the available components in the IoT category is generic 
 Heart Rate Monitor
  as shown in the following screenshot:
  
  
 Heart Rate Monitor component available in the GetIt Package Manager
  
 [ 280 ]",NA
Getting close with beacons,"One of the most popular Bluetooth LE devices are beacons. With beacons it is possible to 
 add precision location awareness to mobile apps. They are becoming increasingly popular, 
 and more and more apps are using them. A 
 beacon
  is any device that provides a standard 
 Bluetooth LE 
 proximity
  service. Beacons are a very important IoT technology. Different 
 vendors offer beacons with different capabilities. Some of them are battery-powered, and 
 others are using a USB connection for charging. Beacons do not use a lot of energy, so a 
 small, watch-sized battery can last for more than a year or even longer.
  
 The support for Bluetooth beacons in Delphi is very similar to other supported cross-
 platform frameworks. The key beacons related types and classes are defined in the 
 System.Beacon
  unit. There is a non-visual 
 TBeaconManager
  class with many virtual abstract 
 methods that are implemented by its platform-specific descendants that are available 
 through the 
 GetBeaconManager
  class method. There is also the 
  
 System.Beacon.Components
  unit where 
 TBeacon
  and 
 TBeaconDevice
  components are 
 implemented.
  
 The key two things about beacons are their identification and the signal strength that is used 
 to judge how far a beacon is away from a mobile device. A beacon device, depending on its 
 configuration, sends out a couple of bytes of data a few times a second just to identify itself. 
 You can think about it as a kind of a radio QR code. The only thing that a beacon does is tell 
 the whole world--
 I'm here and my identification number is the following
 . A mobile app can 
 detect the presence of a beacon and, based on the strength of the signal, determine how far 
 the beacon is from the device. This is different as compared to GPS positioning. With GPS 
 the positioning accuracy is up to a few meters and the GPS does not work well indoors.
  
 Beacons are different. They are just tiny radio transmitters advertising their presence.
  
 Suddenly, the logic of your app has more input. I'm receiving signals from a beacon 
 XYZ
 , 
 so I must be at a specific location where this particular beacon is installed.",NA
Beacons in a museum,"The 
 System.Beacon
  unit defines key types and classes to work with beacons, using any of the 
 supported standards. In order to get some practical knowledge of building beacon-enabled 
 apps with Delphi, we are going to create a simple app for a museum. Imagine that behind 
 every piece of art there is a beacon installed. When we get closer to an item in the exhibition, 
 our app gets information from a particular beacon, looks up its identification, and displays a 
 web page in the embedded web browser window about a piece of art that we are next to.
  
 In this demo, we are going to use the iBeacon standard, so every beacon in a museum is 
 identified by its UUID, and major and minor numbers.",NA
Emulating beacons with TBeaconDevice,"Next to the 
 TBeacon
  component in the 
 Tool Palette
 , we can find 
 TBeaconDevice
 . With this 
 component, we can turn our mobile device into a programmable beacon that will be 
 advertising the proximity data.
  
 That's a very cool ability. Our device can pretend to be any of the supported beacon types, 
 including newer Eddystone beacons. If you do not have physical beacons for developing 
 and testing beacon projects, this component could be very useful. Just turn one or more of 
 your mobiles to act as test beacons, when you need beacons to develop your brand new 
 beacon app.
  
  
 TBeaconDevice component on the form
  
 The 
 BeaconType
  property controls what kind of beacon we want to emulate. Possible 
 choices are 
 Alternative
 , 
 EddystoneUID
 , 
 EddystoneURL
  and 
 Standard
 . Depending on 
 which beacon type we want to use, other properties are used, as shown in the following 
 screenshot:",NA
Proximity solutions with BeaconFence,"A simple beacon-based proximity system can just detect the presence of a beacon and 
 trigger some actions based on 
 seeing
  it. Another interesting use case is to build a positioning 
 system, where our app would know the precise location of the device on which it is 
 running.
  
 It is very similar to 
 Global Positioning System
  (
 GPS
 ), a system of satellites that can provide 
 the app with geographical coordinates where it is currently located. GPS is great, but it has 
 its limitations. First of all, the accuracy of GPS is only up to a few meters. The second 
 limitation is that it only works outdoors. With beacons it is possible to build much more 
 precise systems, with location accuracy below one meter, and which work both outdoors 
 and indoors. A good example of such a location tracking use case would be to find your 
 way in the underground parking garage, or inside a big office building.
  
 When an app receives proximity advertisements from a beacon, it only knows which beacon 
 it is and approximately how far away it is located. It cannot tell from which direction the 
 beacon radio signal is coming. In order to a build localization system, we need to have more 
 beacons and use similar trigonometry as sailors were using on the sea to calculate the 
 position of their ship using stars or light signals from traditional light beacons broadcasting 
 their location.
  
 Delphi comes with 
 BeaconFence
 , which is a developer proximity solution that builds on top 
 of the beacon support. BeaconFence is not installed out-of-the-box, but it needs to be 
 downloaded and installed through GetIt. It is also licensed separately from Delphi, so before 
 deploying a BeaconFence-based system into production, you need to get an 
  
 appropriate license from Embarcadero, or one of its partners.
  
 The first step is to download and install BeaconFence. Go to the 
 Tools
  menu and select 
 GetIt Package Manager
 . Find 
 BeaconFence
  and click on the 
 Install
  button:",NA
App tethering,"IoT is about apps talking to all kinds of devices, gadgets, and sensors. In this same vein, we 
 can fit 
 app tethering
  technology, where an app can easily communicate over Bluetooth or 
 just plain TCP/IP protocols with other apps.
  
 App tethering is a feature of Delphi, and also C++Builder. It can be used to set up 
  
 communication between different types of applications, mobile or desktop, running on any 
 of the supported platforms using FireMonkey, and also VCL. The original use case for app 
 tethering was to be able to 
 extend
  existing desktop apps to mobile devices and easily create 
 companion
  apps. Instead of trying to re-implement existing desktop apps on mobile devices, 
 the idea was to be able to either control a desktop app from a mobile app or to be able to 
 easily exchange data between the two. For example, we could have an existing desktop 
 application written in Delphi that helps doctors with keeping track of patients' data and 
 possibly control some medical instruments. There is nothing wrong with this desktop 
 application; it has stood the test of time and is very useful. But now, mobile approach brings 
 new possibilities. It would be cool to use a mobile device with a camera and send images to 
 the existing desktop app. With app tethering, such a use case is very easy to achieve. The 
 Delphi IDE itself is using app tethering for the 
 Live Preview
  feature. In this scenario, the 
 IDE, which is a good example of a Delphi desktop app, communicates with the Live 
 Preview app running on iOS or Android.
  
 Using app tethering in your apps is relatively straightforward. Both apps that need to 
 communicate with each other need to have two app tethering components on the form: 
 TTetheringManager
  and 
 TTetheringAppProfile
 :
  
  
 App tethering components available in the Tool Palette",NA
Summary,"The IoT is a brand new world to explore for mobile developers. There is still no clear market 
 leader, and different companies do the IoT their own way. One aspect of IoT that everybody 
 agrees on is the fact that it is all about communicating with 
 things
 , sometimes very far from 
 a traditional computer or a mobile device. Those devices, gadgets, and sensors sometimes 
 communicate using a traditional internet TCP/IP protocol, but in most cases they use 
 protocols optimized for low energy consumption and IoT use cases. One of the key 
  
 communication protocols that enables IoT today is Bluetooth Low Energy.
  
 Delphi comes with very good support for building both mobile and desktop apps that are 
 using Bluetooth LE. You can build Bluetooth LE clients, but it is also possible to implement 
 GATT servers that emulate Bluetooth LE devices.
  
 In this chapter, we have learned about interacting with the Internet of Things. We have 
 started from using plain Bluetooth LE protocol with the 
 TBluetoothLE
  component and then 
 moved to specialized support for standard Bluetooth devices, such as heart monitors and 
 beacons for building proximity apps. We have also looked into BeaconFence 
  
 technology for building complete GPS-free positioning solutions and the app tethering 
 framework for having two arbitrary Delphi apps exchange data over Bluetooth or TCP/IP 
 with almost no coding required.
  
 In the next chapter, we will learn how to embed a database on a mobile device and use it 
 from a Delphi FireMonkey app.",NA
Embedding Databases ,NA,NA
,"The majority of mobile apps work with data. Building database applications has always 
 been one of the strongest features of Delphi. In this chapter, we will learn how to build data-
 driven mobile user interfaces, use the FireDAC database access framework, and embed 
 databases on mobile devices. As an example, we are going to build a simple mobile app for 
 managing a To-Do list.
  
 This chapter will cover the following points:
  
 Embedding mobile databases
  
 Using the FireDAC framework for database access
  
 TListView designer
  
 Visual live bindings
  
 Using TPrototypeBindSource
  
 The objective of this chapter is to learn how to build data-driven GUI interfaces.",NA
Architecting data-driven apps,"On the following pages, we will go through the steps of building a simple mobile app with 
 an embedded database for managing a list of To-Do items. Before jumping into coding, let's 
 first look into the overall application architecture. The more complex the system we are 
 going to build is, the more important it is to properly structure it. The typical approach is to 
 divide and conquer
 . Break a big problem into smaller problems that are simpler to solve. The 
 most common approach in software development is to break the whole system into clearly 
 separated tiers. In a data-driven app, we should be able to identify at least two logical parts: 
 the user interface and the data access logic. Clear separation of these two tiers enables 
 pluggable architecture, where the user interface can connect to different data access 
 blocks
  in 
 a standard way.
  
 In the context of a Delphi app, we can split our project into three independent entities--a 
 visual form that will serve as the graphical user interface, a data module with non-visual 
 components for working with a database, and a standalone unit, with common types and 
 utility functions used by both tiers of the application. Take a look at the following diagram:
  
  
 Two-tier app architecture
  
 Create a new multi-device, blank Delphi project. Save the main form unit as 
 uFormToDo 
 and the whole app as 
 ToDoList
 . Change the 
 Name
  property of the form to 
 FormToDo
 . 
 Select 
 File
  | 
 New
  | 
 Other...
  from the Delphi main menu and add to the project a new data 
 module, which can be found in the 
 Delphi Files
  category. Change its 
 Name
  property to 
 DMToDo
  and save it as 
 uDMToDo
 . Now, from the same 
 Delphi Files
  category, add a 
 blank unit to the project. Save it as 
 uToDoTypes
 . This is how our project looks right now in 
 the Project Manager:",NA
Modeling data,"The 
 uToDoTypes
  unit is where we can add data types that are shared between the user 
 interface and the data access module. To achieve a proper level of separation between the 
 user interface and the data access logic, we should define the interface for communication 
 between the two tiers of the application. The data module will implement it and the main 
 form of the application should use this interface as the only way to communicate with the 
 data module. In this way, we have a truly pluggable architecture. The user interface can be 
 developed independently and we can provide different implementations of data access 
 logic without affecting the rest of the application. Our data-driven app could be using 
 different types of embedded databases, a different data access framework, or maybe we 
 would want later to switch to storing our data in a plain file or in cloud storage.
  
 The 
 ToDoList
  app will be dealing with To-Do items, so it makes perfect sense to declare in 
 the common types unit a type that will represent a single To-Do item. We need to decide if 
 this type should be a record or a class. With records we do not need to worry about memory 
 management and typically, records are more performant then objects. On the other hand, 
 defining our 
 data wrapper
  type as an object is also an option. Record types cannot be 
 inherited. In more complex scenarios, the flexibility that comes from using objects could 
 justify using them rather than records.",NA
Choosing a database,"The majority of mobile apps work with data. If you are not building a calculator app, or an 
 arcade game, the possibility to store the data that your app is using can be very valuable. 
 When designing your app, you need to make some architectural choices up front. Where 
 and how is my data stored? One obvious solution is to store your data in the cloud. This 
 approach is the most common, but what if you do not have network access? You still want 
 to be able to work with your app, and with the latest version of your data. This is the main 
 reason why you also want to store your data locally on the device.
  
 In many cases, storing data as plain files, text or binary, is sufficient. However, it is also 
 possible to embed a complete database system locally on the device. There are many 
 relational and non-relational embedded databases available. If we think about an arbitrary 
 database as just another mobile framework available from the mobile operating system, 
 then it should be possible to integrate your Delphi mobile app with pretty much any 
 database. However, that could require a deep understanding of the inner workings of your 
 particular database. In most cases, we just want to have the job done, and it is the most 
 productive approach to use databases that Delphi already provides support for. The key 
 database access framework for mobile Delphi apps is FireDAC. It provides connectivity to 
 all major databases, and also includes support for working with embedded databases.
  
 There are two main databases that you can embed:
  
 InterBase
  
 SQLite
  
 Depending on your app, you may want to choose one or the other.",NA
Accessing databases with FireDAC,"To keep the demo app simple, we are going to use SQLite as the database engine and our 
 To-Do List
  app will have just one database table, called 
 ToDos
 . SQLite has a simple type 
 system and effectively, a column can store null, integer, real, text, or blob values.
  
 In our design, we are going to use as a primary key an integer 
 Id
  value. We will also need 
 Title
  and 
 Category
  text fields. The key FireDAC component that we will need is the 
 FireDAC database connection. There will also be query components connected to the 
 database connection. Drop the 
 TFDConnection
  component onto the data module. Change its 
 Name
  property to 
 fdconnToDos
 . Now double-click on the connection component to display 
 the FireDAC database connection editor window. Select 
 SQLite
  in the 
 Driver ID 
 combo-
 box. This should display the list of different parameters specific to working with SQLite.
  
 First we will have to enter the name of the database file. It is important to realize that the 
 location of the database file on our development Windows machine, where we have Delphi 
 installed, will be different to the location on a mobile device where our app will be 
 deployed. During development of our application, we will be running it on Windows for 
 testing, and when the app is finished then we will deploy and run it on an Android or iOS 
 device. On your Windows machine, create a directory for the SQLite database file (for 
 example, 
 C:\Data
 ). The name of the database file will be 
 ToDos.db
 . The extension of the 
 database file can be anything and it is a matter of convention. There is no need to enter a 
 username and password and we can leave all the default parameter values. The default 
 OpenMode
  parameter is set to 
 CreateUTF8
 . This means that the database file will be 
 created automatically on the first attempt to connect to it. This simplifies the deployment to 
 a mobile device, because the database file can be created the first time the mobile app runs.",NA
Building data-driven user interface,"The data access logic has been implemented and it is available through the 
 IToDoData 
 interface. This should be the only way for the user interface logic to access the data. That is 
 why we are going to implement the 
 GetToDoData
  method in the main form's unit that will 
 return the reference to the data access interface. See the following code:
  
 uses
  uDMToDo;
  
 function
  TFormToDo.GetToDoData: IToDoData; 
 begin
  
  if
  DMToDo =
  nil then
  
   
  DMToDo := TDMToDo.Create(Application); Result := 
 DMToDo; 
  
 end;",NA
Using visual live bindings,"There are many tools for developers on the market. What makes Delphi one of the most 
 productive development environments is the 
 Rapid Application Development
  (
 RAD
 ) 
 paradigm, where you can use reusable components and very quickly assemble them 
 together to create a working application. In Delphi there is hardly any prototyping phase of 
 the project. When you are building an app, it very quickly starts to look like the final 
 product. Most applications work with data. Graphical user interfaces that we design 
 typically display information coming from a database or from a service in the cloud. In 
 Delphi you can preview the data at design time.
  
 There are two visual frameworks in Delphi for building graphical user interfaces. There is 
 the Visual Component Library, the VCL, which is arguably the best library for building 
 native applications for Windows. There is also the FireMonkey multi-device library for 
 building cross-platform graphical user interfaces for all supported mobile and desktop 
 operating systems. The VCL has a concept of data-aware control that can be connected with 
 the 
 TDataSource
  component to a non-visual dataset component representing a database 
 query, table, or a stored procedure. In FireMonkey there is no concept of data-aware 
 controls. If you want to quickly build data-driven graphical user interfaces in FireMonkey 
 you can use Visual Live Bindings. This technology is much more capable then just 
  
 connecting controls to data. It can be used in FireMonkey, VCL, or even a console project. 
 Visual Live Bindings are components themselves and can be used to connect properties of 
 two arbitrary objects.
  
 Let's start from a very simple example of connecting properties of visual controls on the 
 form. Create a new multi-device and a blank Delphi project. Save the main form's units as 
 uFormVLB
  and the whole project as 
 VLBTest
 . Change the 
 Name
  property of the form to 
 FormVLB
  and save all. Drop the 
 TEdit
  and 
 TLabel
  components on the form. Right-click on the 
 label component and select the 
 Bind Visually...
  option from the context menu. That will 
 display the 
 LiveBindings Designer
  window. Alternatively, we could have displayed this 
 window from the 
 Tool Windows
  menu in the 
 View
  main menu option.",NA
Fast user interface prototyping,"Live bindings are not limited to string properties. You can bind different simple and 
 complex data types. One of the really cool components that you can use to quickly design a 
 data-driven user interface is 
 TPrototypeBindSource
 . This component can emulate a data table 
 and generate test data for display. In this way, we can very quickly prototype graphical user 
 interfaces.",NA
Summary,"In this chapter, we have learned how to build data-driven apps and embed a database on 
 mobile devices.
  
 In the next chapter, we are going to reuse the visual part of our 
 To-Do List
  app and use 
 cloud data storage as the underlying implementation of the 
 IToDoData
  interface.
  
 [ 339 ]",NA
Integrating with Web Services ,NA,NA
,"No mobile app is a lonely island. You can create standalone mobile apps with Delphi, but 
 most of the time developers want to integrate with backend services to provide access to 
 data and add the whole social dimension to the mobile user experience. In this chapter, we 
 are going to have a tour of different technologies available in Delphi to integrate with 
 mobile backends running in the cloud, including the HTTP native client library, accessing 
 REST APIs, and using the Cloud API framework for integrating with cloud web services 
 available in Amazon and Azure clouds.
  
 This chapter will cover the following points:
  
 HTTP native client library
  
 SOAP clients
  
 REST clients
  
 BaaS clients
  
 Cloud API
  
 The objective of this chapter is to learn how to build mobile HTTP clients and connect to 
 web services and data in the cloud.",NA
Understanding web services,"Not so long time ago and not in a galaxy far, far away, Sir Timothy John Berners-Lee 
 invented the World Wide Web. In his vision for an information management system, 
 individual documents should be hyper-linked with each other through special 
 Uniform 
 Resource Locators
  (
 URL
 ) and anyone reading a document inside of a web browser program 
 would be able to jump directly to a referenced hyper-text document. He was also the one 
 who designed the 
 Hypertext Transfer Protocol
  (
 HTTP
 ) and implemented the first versions 
 of web server and web browser programs, that used the HTTP protocol for communication.
  
 The fact that his ideas were from the very beginning open, public and 
 for everyone 
 contributed to the enormous, global success of the World Wide Web and something that 
 nowadays we take for granted when opening our favorite web browser and searching for 
 information or reading news.
  
 The HTTP is a simple protocol for exchanging text documents over the underlying TCP/IP 
 protocol. It is very scalable, because from the very design, servers and clients do not need to 
 maintain the state of communication and every HTTP request is independent. The HTTP 
 specification defines different request types that a client can send to a server, sometimes 
 referred to as 
 verbs
 , that specify the type of action that a client wants to perform on a 
 referenced 
 resource
 . There are many HTTP methods, but the most common ones are 
 GET
 , 
 HEAD
 , 
 POST
 , 
 PUT
 , and 
 DELETE
 . An HTTP server performs requested actions and returns 
 response codes and optionally returns data. When the request is successful, the server 
 returns the OK status code 
 200
 . The other popular standard HTTP response code is 
 404
 , 
 which indicates an error 
 not found
 .
  
 In the original WWW design from 1989, Tim Berners Lee created the 
 Hypertext Markup 
 Language
  (
 HTML
 ). Documents in this format can be displayed by web browsers. A few 
 years later, the concept of web services was born from the realization that the HTTP 
 protocol does not need to be limited to exchanging HTML documents. Any other document 
 format can be returned from a web server and web client applications do not necessary need 
 to be web browsers. The first popular web services implementation was based on the 
 Extensible Markup Language
  (
 XML
 ) document format. The XML was the natural 
  
 evolution of HTML. In this new format, the types of markup 
 tags
  were not defined by a 
 specification, but anybody could define their own tags. The XML-based web services 
 defined a set of XML tags for encoding 
 Simple Object Access Protocol
  (
 SOAP
 ) messages 
 that were exchanged between XML SOAP web services clients and servers. The key tag was 
 envelope
  and web services request messages were sent by clients with information which 
 web service method needs to be invoked and what the parameters are. A web server would 
 return an XML 
 envelope
  with the results of a web method call.",NA
Native HTTP client,"Arguably the most important contemporary network communication protocol is HTTP and 
 its secure HTTPS version. Every operating system typically has its own HTTP client 
 functionality built-in. In the cross-platform world of Delphi programming, there is the 
 HTTP 
 native client
  library, which provides uniform access to HTTP client 
  
 implementations available on different platforms.
  
 Similar to other cross-platform libraries in Delphi, you can either work with HTTP entirely 
 in code using the types defined in 
 System.Net.HttpClient
  and 
  
 System.Net.URLClient
  units, or you can rely on reusable components declared in the 
 System.Net.HttpClientComponents
  unit that are available from the 
 Tool Palette
  in the 
 Net
  
 category:
  
  
 Native HTTP client components in the Tool Palette",NA
Consuming XML SOAP web services,"The starting point for implementing the SOAP web service client is the 
 Web Services 
 Description Language
  (
 WSDL
 ) document, which specifies what web methods a given web 
 service implements and what are the names and types of the expected parameters. Delphi 
 provides the 
 WSDL Importer
  wizard that takes as input a WSDL file and generates the 
 Object Pascal unit with types and methods that correspond with the functionality exposed 
 by a SOAP web service. The main application logic can use these generated classes in order 
 to issue web services requests and receive results returned from the remote web services 
 server app.
  
 Let's have a look at the process of integrating with a SOAP web service on the example of 
 the 
 WHOIS
  service. This is a test service hosted by 
 www.webservicesx.net
 . It provides the 
 interface to the 
 WhoIs
  internet service, where you can check who is the registered owner of 
 a given domain. This web service is very simple. It takes as a parameter a string value with 
 a hostname and returns a string with information about the domain owner.",NA
Integrating with REST services,"Technology does not like to stand still. It keeps evolving. Nowadays, SOAP web services 
 are not so frequently used compared to their newer REST-ful variant.
  
 Over time, the XML file format became harder and harder to process. Initially, the simple 
 XML specification went through many improvements and became more complex. The 
 addition of XML Namespaces, XSLT, XQuery, and a couple of other specifications made 
 XML processing much more demanding. In the meantime, much simpler 
 JavaScript Object 
 Notation
  (
 JSON
 ) became the most popular format for exchanging structured data.
  
 The new REST architecture for implementing web services is not as standardized as XML 
 SOAP web services. 
 Representation State Transfer
  (
 REST
 ), fully utilizes the underlying 
 HTTP protocol and makes use of its different request methods and response codes. On the 
 other hand, the SOAP specification was primarily focused on the content of the standard 
 XML envelope. In fact, you do not necessarily need to exchange a SOAP message using 
 HTTP. You could imagine sending it using other transport such as email or even a homing 
 pigeon.",NA
Backend as a service client,"Only the simplest mobile apps can operate on their own. In most scenarios, a typical mobile 
 app architecture can be divided into two pieces. A backend and a frontend. Both 
  
 architectural layers can be very complex and may require different programming skills. It is 
 becoming more common to see on a business card titles such as 
 backend developer
 , 
 frontend 
 developer
 , or 
 full stack developer
 . Specialization grows. As a Delphi super hero, you do not 
 need to limit yourself! You can develop from the same source code to different mobile 
 frontends and easily architect mobile backends.
  
 When building a complex app, you do not want to reinvent the wheel and spend your 
 precious time on implementing things that already exist. What if we could just use an 
 existing backend in our next mobile app, instead of building it from scratch? There are 
 number of typical functions that a mobile backend provides. Things such as user 
  
 management, data storage, mobile push notifications, analytics, and others are common to 
 any full-featured mobile backend. This is where 
 Backend as a Service
  (
 BaaS
 ) offerings 
 come into the picture. There is a growing number of services in the internet that provide 
 paid BaaS services that your app can integrate to.
  
 On top of the 
 REST Client
  component library, the whole set of BaaS components for 
 integrating with different BaasS providers has been built and is available from the 
 BAAS 
 Client
  category in the 
 Tool Palette
 :",NA
Integrating with the cloud,"Integrating with 
 cloud services
  can be understood in different ways. It could mean to 
 integrate with any remote service. It is a very broad term. There are different cloud web 
 service providers that offer all kinds of services. The main players in this arena are Amazon 
 Web Services, Google Cloud Services, and Microsoft with their Azure Cloud. There are also 
 other vendors, but not as big as the top ones. Cloud services are typically accessible using 
 the HTTPS protocol and as such they are just regular web services.
  
 Delphi comes with the 
 Cloud API
  framework for accessing different cloud services. On top of 
 abstract types and classes that are common for any cloud service defined in the 
  
 Data.Cloud.CloudAPI
  unit, there are two specialized units with types and classes specific for 
 working with selected services available from Amazon and Azure declared in 
  
 Data.Cloud.AmazonAPI
  and 
 Data.Cloud.AzureAPI
 :",NA
Moving ToDo List to Amazon S3,"In the previous chapter, we built a simple 
 ToDo List
  mobile app with a pluggable data 
 access architecture. Here we are going to replace the data access logic. Instead of storing To-
 Do data in the local database, we are going to store them in the Amazon Simple Storage 
 Service in the form of a JSON file. This is a very powerful and cost-effective solution. We 
 will be able to access the same To-Dos from apps running on different mobile devices 
 effectively implementing a serverless architecture.
  
 The first step is to make sure that we have an account in the Amazon Web Services. If you 
 do not have an AWS account, you can create one at 
 http://aws.amazon.com/free/
 . In the first 
 year, you can use certain services for free and try them out. In the case of the AWS Simple 
 Storage Service, this allows for 5 GB of free storage and 20,000 Get and 2,000 Put requests 
 to be used for 1 year from creating an AWS account.
  
 After signing up to the Amazon Web Services, you have now access to the AWS 
  
 Management Console web page where you can manage different services. The AWS Simple 
 Storage Service lets you store arbitrary amounts of data in a secure, reliable way. All data 
 objects are organized into buckets. A single user can have up to 100 buckets, but the amount 
 of objects stored in a bucket is unlimited. An individual object can have a size up to 5 TB. 
 Within a bucket, you can further organize files in a folder structure. Every AWS object may 
 be accessed via a HTTP URL or programmatically from an app using a special API. Bucket",NA
Summary,"In this chapter, we have learned how to integrate mobile Delphi apps with different types of 
 web services. In the next chapter, we will look into implementing mobile backends in 
 Delphi.",NA
Building Mobile Backends ,NA,NA
,"In the mobile development world, it is common to have dedicated developers and teams 
 responsible for just building mobile frontend and backends. This time we are going to wear 
 the backend developer hat and use Delphi to build modern scalable, secure, and fault-
 tolerant REST API web services with full database access. This chapter will cover the 
 following points:
  
 Why multi-tier architectures?
  
 Creating mobile backends with:
  
 WebBroker
  
 DataSnap
  
 RAD Server
  
 The objective of this chapter is to understand different choices for backend technologies in 
 Delphi and get practical knowledge on how to build scalable, fault-tolerant mobile 
 backends in the cloud.",NA
Delphi and multi-tier architectures,"In the previous chapter, we saw that you can use cloud web services to create an 
  
 information system where apps running on different devices can connect to the same data 
 store. Not only can you use Delphi to integrate with existing web services, but you can also 
 build your own!",NA
Getting low-level with WebBroker,"The most simple and generic web server development framework in Delphi is 
 WebBroker
 . 
 It is the underlying technology for many specialized web service types that you can build 
 with Delphi, such as SOAP XML Web Services and DataSnap. If you create a new web 
 server app with the 
 New WebBroker App
  wizard, you can implement arbitrary HTTP 
 server functionality. In our case, that will be a simple web service that will provide REST 
 API access to the 
 To-Do
  data.
  
 Click on the 
 File
  | 
 New
  | 
 Other...
  menu items in the IDE and double-click on the 
 New Web 
 Server Application
  wizard in the 
 WebBroker
  category, as shown in the following 
  
 screenshot:
  
  
 New Web Server Application wizard in New Items
  
 [ 384 ]",NA
Organizing your WebBroker projects,"Let's make sure to have a good folder structure to properly organize our two WebBroker 
 projects, 
 Standalone
  and 
 Apache
 . Create a new folder for both projects. Inside this folder, 
 create three sub-directories: 
 apache
 , 
 standalone
 , and 
 shared
 . Click on 
 Save All
 . Save the 
 ServerConst1
  unit into 
 standalone
  and 
 WebModuleUnit1
  into the 
 shared
  folder. Save the project 
 as 
 ToDoWebBrokerStandaloneHTTP
  and make sure it is saved in the 
  
 standalone
  folder.
  
 [ 387 ]",NA
Do it yourself with DataSnap,"WebBroker is good for really simple HTTP server functionality, but the more complex the 
 system you want to build, the more you look into complete Delphi multi-tier frameworks 
 such as DataSnap or RAD Server. They provide a lot more higher-level functionality than 
 you can find in WebBroker.
  
 The DataSnap framework has been part of Delphi since its early days and has been evolved 
 over time. Delphi 3 introduced MIDAS technology to make it easy to build client/server 
 database applications. In Delphi 6, this technology has been renamed to DataSnap and in 
 Delphi 2009 it has been completely rewritten. In this new architecture, remote methods 
 published by a DataSnap server look like database stored procedures that a typical SQL 
 relational database system exposes. The dbExpress database access framework has been 
 reused and a special DBX driver has been built to provide connectivity between DataSnap 
 clients and servers. The DBX model is still there in the current DataSnap implementation, 
 but a newer REST-based model has been added. In DBX you could have used TCP/IP or 
 HTTP for communication between the client and the server. In DataSnap REST-based 
 architecture, the only choice is to use HTTP or HTTPS.
  
 When you open the 
 New Items
  dialog in Delphi, there are three different wizards in the 
 DataSnap Server
  category to create new server projects:
  
  
 ""DataSnap WebBroker Application"" wizard in the Delphi ""New Items"" dialog",NA
Implementing DataSnap server functionality,"In DataSnap architecture, a programmer does not write code to instantiate a server methods 
 class inside the server app. The 
 LifeCycle
  property of 
 DSServerClass1
  component controls 
 the life cycle of the server class. By default, it is set to 
 Session
 , which means that for every 
 connected client there is one server methods class instance inside the server app. When the 
 client connects, it is created and when the client disconnects, it is destroyed. If this property 
 is set to 
 Server
  then there is only one, single server class instance for all the connected 
 clients. In this case, the server method implementation should be thread safe because its 
 methods could be called from different threads. The most scalable 
 LifeCycle 
 option is 
 Invocation
 . In this scenario, the server methods class is instantiated just for the duration of a 
 server method call. It does not maintain a state across server method calls.
  
 DataSnap servers are hosting agnostic. This means that DataSnap servers can be 
 implemented as WebBroker web servers, console apps, VCL or FireMonkey forms 
 applications, or as a Windows service.
  
 Similarly to building clients for XML SOAP web services, there must be a client access unit 
 generated that mimics the functionality available on the server. In the case of the SOAP web 
 services, the starting point for generating client proxies is the WSDL document that 
 typically is generated automatically from the running service. DataSnap client development 
 is similar. The DataSnap proxy generator needs to have access to a running server. It queries 
 the server and generates the DataSnap client class that exposes the same methods as are 
 available on the server. There are client proxy generators for multiple programming 
 languages, including Object Pascal, C++, PHP, JavaScript, C#, Java, and Objective C. On the 
 client, you just need to instantiate this DataSnap client class passing the DataSnap 
  
 connection component to the constructor.
  
 The DataSnap framework uses RTTI to provide serialization functionality for many simple 
 and complex Delphi data types. Consequently, we do not need to manually convert 
 parameter and result types from their native Delphi representation to strings and JSON. 
 This is done for us, but the choice of parameter types is important in DataSnap. If the proxy 
 generator does not support certain parameter types, it just ignores a given server method 
 and the proxy is not generated for it.",NA
Easy REST API publishing with RAD Server,"Probably the most feature-rich and powerful architecture for building mobile backends is 
 RAD Server. Unlike other types of Delphi server applications, RAD Server is pre-built and 
 out of the box offers functionality typical for other 
 Backend as a Service
  (
 BaaS
 ) products.",NA
RAD Server setup,"Make sure that InterBase is installed and running on your system. In the Windows 
 Start 
 menu, locate and run 
 InterBase Server Manager
 . If the server is not started, run it. In the 
 default installation, the InterBase instance name is 
 gds_db
 . The name of the database 
 instance will be needed during the RAD Server setup:
  
  
 ""InterBase instance name"" in the caption of the InterBase Server Manager",NA
Building resources,"RAD Server architecture has been elegantly designed. You can add custom REST API 
 resources through Delphi package library files that are loaded to RAD Server at startup. The 
 location of packages to be loaded is stored in the 
 .ini
  configuration file:
  
  
 RAD Server architecture
  
 Earlier in this chapter, we used WebBroker architecture to expose CRUDL operations on the 
 underlying To-Do data stored in the Amazon Simple Storage Service as custom REST APIs. 
 Here we are going to implement a similar solution, but this time we are going to expose the 
 same functionality using RAD Server.
  
 Let's start by creating a proper folder structure for our projects. Create a new folder for the 
 RAD Server To-Do resource and client projects. Inside this folder, create three sub-folders: 
 resource
 , 
 client
 , and 
 shared
 .",NA
Summary,"In this chapter, we have looked at different options for building mobile backends with 
 Delphi. There are many wizards to help you build all kinds of server apps from simple 
 WebBroker HTTP servers, through SOAP XML Web Services, to DataSnap and RAD Server 
 architectures providing a lot of reusable functionality to build great mobile backends for 
 your cross-platform, mobile Delphi apps.",NA
App Deployment ,NA,NA
,"Building and deploying your mobile app to an App Store is just the beginning. There is a lot 
 more to successful app deployment. In this chapter, we are going to focus on all the nitty-
 gritty details of app deployment. We are going to discuss adding artwork, app 
  
 monetization with ads, and in-app purchases. To be successful in mobile app development 
 you need to constantly improve your app. For this you need to have good understanding of 
 how users interact with your app. You also need to automate as many tasks as possible for 
 reduced development and deployment times. That is why at the end of this chapter best 
 practices for version control, testing, continuous integration, and deployment are discussed.
  
 This chapter will cover the following points:
  
 Deploying to App Stores
  
 Monetizing with ads and in-app purchases
  
 Effectively using version control
  
 Unit testing
  
 Automating everything with continuous integration and deployment
  
 The objective of this chapter is to teach how to successfully deploy mobile apps.",NA
Deploying to App Stores,"You have built your app, tested it on multiple different devices, with different versions of 
 supported mobile operating systems and now you feel that you are ready to make it 
 available in an App Store.",NA
Publishing your apps to Apple iOS App Store,"Before you can build your app for deployment to the App Store, you need to add to your 
 project required artwork. This is a collection of images in PNG files for formats that are 
 used as application icons, launch images, and spotlight search icons. When you create a 
 new multidevice app in Delphi it is using default 
 FireMonkey
  artwork that can be found in 
 the standard Delphi installation in the 
 bin\artwork
  directory. Delphi developers tend to 
 have lots of these icons on their devices. Here is an icon for the 
 Molecule Hero
  app:",NA
Publishing your Android apps to Google Play ,NA,NA
Store,"The first step to publishing your Delphi Android is to create a Google Play developer 
 account on the 
 developer.android.com
  website.
  
 Make sure that you have all required artwork properly configured in your 
 Project Options
 . 
 Select the 
 Application
  node and in the 
 Target
  combo choose 
 All configurations - Android 
 platform
 . Configure your graphical assets, pointing each type of artwork to the right file.
  
  
 Molecule Hero artwork for Android in Project Options",NA
Monetizing with adds and in-app purchases,"There are different business models for mobile apps. Rather than expecting users to pay for 
 an app, before they can use it, it is becoming more common to offer apps for free, but to 
 provide a way to make in-app purchases. Delphi comes with a cross-platform 
  
 TInAppPurchase
  component that is available on the 
 Services
  tab in the 
 Tool Palette
 .
  
  
 TInAppPurchase component in the Tool Palette
  
 With this component, you can sell virtual content within your app in a uniform way using 
 the Google Play In-app Billing service on Android and the Apple iOS in-app purchase 
 service on iOS. The source of this component can be found in the 
 FMX.InAppPurchase 
 unit. 
 The details of using in-app purchases are different on both platforms and are very well 
 documented on the Embarcadero docwiki.
  
 Another possible business model is to embed advertisements in your apps. 
 FireMonkey 
 comes with the 
 TBannerAd
  component that you can use to easily display ads in your app.
  
 You can find its source code in the 
 FMX.Advertising
  unit. Have a glance at the icon:
  
  
 TBannerAd component in the Tool Palette
  
 Some mobile app users do not like ads popping-up, so you have to use them with care. A 
 possible option is to have an in-app purchase to disable ads.",NA
Enhancing your apps,"You have made it! Your app is in the App Store and you know that at least your friends are 
 downloading and installing it on their device. But it is not the end of the life of your app. It 
 is just the beginning. It has just made it through the first cycle from a faint idea in your 
 mind, through development and testing to final deployment.
  
 Some time will pass and you will start realizing that there are things in your app that could 
 have been done better. There are some bugs to be fixed, ways to make it faster, and ideas 
 of how to improve user experience and add new functionality.
  
 One important saying fact that 
 better
  is the enemy of 
 good
 . Why change things that are 
 working? But the change is inevitable. The only thing that never changes is the change itself. 
 You might be a one person app development company or part of a bigger team. Regardless 
 of the number of people you cooperate with on your projects, it is always a good idea to 
 have a process in place to release new versions of your apps. It could be less or more formal, 
 but certain phases are probably always there.
  
 It is all about understanding and setting up your development workflow. There are many 
 methodologies for how you should organize your development work. One of the earliest 
 was the 
 waterfall
  model where building an information system was going through different 
 phases. It started from 
 requirements
  where the idea of system functionality was born. In the 
 design
  phase the desired software architecture was documented. In the next 
 implementation 
 phase the actual coding took place and it was followed by v
 erification
  where testing was 
 performed to validate that a system in place provided the expected functionality. In the last 
 maintenance
  phase the system was already in production and occasional bug fixes were 
 made. The 
 waterfall
  approach is no longer used, because it lacked flexibility. It did not adapt 
 to the real-world scenarios as requirements are constantly changing. A more pragmatic 
 approach to software development started from the 
 Agile Manifesto 
  
 http://agilemanifesto.org/
 , where a group of software practitioners challenged the existing 
 status quo
  and put together a list of postulates, how development of information systems 
 should look like.",NA
Practical version control,"The key asset that you create is code, so you really, really want to keep it safe and make 
 sure you do not waste your work and time.
  
 You have been very intensively working on a new app throughout the whole week. By 
 Friday your app is already in good shape and the basic functionality works. Over the 
 weekend you have got some 
 clever
  ideas, made some changes to the source code, and it is 
 Monday morning in the office and nothing is working. You wish you could move back in 
 time and put your app in a state when it was last working. This is what version control is all 
 about. Every time you make a change to a source code file, or any other asset that belongs to 
 your project, this change is saved and you can easily roll back changes and get back to the 
 last working version of your app.",NA
Planning a release,"A development cycle starts with planning. If it is the very first cycle, it also involves all 
 conceptual and creative activities of sketching user interface and trying to figure out what 
 the app should do. If it is one of the consecutive rounds in the life cycle of an app, it is this 
 moment, when you need to decide what the next version of your app will look like.",NA
Development and refactorings,"The next two phases in the life cycle of an app are very closely connected: writing code and 
 checking if it works. Initially, it is more about writing new code, but in the next cycles the 
 development effort goes primarily into refactoring. 
 Martin Fowler
 , one of the pioneers of 
 agile movement
 , defines refactoring as ""the process of changing a software system in such a 
 way that it does not alter the external behavior of the code yet improves its internal 
 structure"" (
 www.refactoring.com
 ). That is the essence of enhancing your app. If there is a 
 change in requirements you typically start from modifying the core of your app structure to 
 be able to incorporate new functionality in a way that will be consistent with the rest of your 
 app architecture. There will be more changes in the future to your system, so it is better to 
 be prepared for them. The architecture of your app has to be flexible enough to adapt to 
 future changes, but you should try not to make it too generic. Be pragmatic and defensive in 
 changing your existing code base. Remember: 
 better
  is the enemy of 
 good
 .
  
 Delphi IDE comes with a rich arsenal of refactoring tools. Probably the most commonly 
 used is the 
 rename
  refactoring tool. It is a very important one. Changes in your code start 
 from a different perception of how certain parts of it should work and what they are 
 responsible for. Naming is key to make sense of your existing code base and moving it 
 forward to next iterations.",NA
Sleeping well with unit testing,"Writing code is like solving a big puzzle. The more lines of code you have in your app, the 
 more difficult it is to maintain and evolve. It takes a lot of experience to be able to properly 
 structure your projects. When you add new features, they should not break the 
  
 functionality of the whole app. Unit testing can help with making sure that every piece of 
 code that you write works as expected. Some developers start writing their code from 
 implementing unit tests that will prove that the code they will write later works.
  
 Delphi IDE comes with two integrated unit test frameworks: DUnit and DUnitX. The first 
 one is older and is not actively maintained. The second one, DUnitX, is newer and is 
 leveraging modern language features such as custom attributes, which were not available in 
 older Delphi editions.
  
 Unit testing, refactoring, and version control are pillars of agile development. When you 
 have just completely changed the internal architecture of your app, you want to make sure 
 that it still works. Running a number of unit tests can help you have good sleep and not 
 worry about changes that you made to your code just before the deadline.",NA
Continuous integration and deployment,"The more we can automate our developer work, the better. Ideally, the whole release cycle 
 should be automated. In a typical scenario, every change committed to the source code 
 system should trigger running unit tests, and if they are successful, they should 
  
 automatically build a new version of our app.",NA
Summary,"Your app is in the App Store now and you have become a developer superhero that writes 
 code once and natively compiles it to all major mobile and desktop platforms from the very 
 same source code files. Nobody can beat your productivity!
  
 In this chapter, we have walked through steps necessary to prepare and publish your 
 Delphi apps to major App Stores. When your app is there in an App Store, it is not the end 
 of its life. We have also discussed here a typical life cycle iteration of an app from change 
 requests, planning, development and testing, and finally to automatic deployment.
  
 It is your move now!
  
 [ 466 ]",NA
The Road Ahead,"You have done it! You have become a developer superhero and now you have all the 
 necessary skills to rapidly create stunning mobile apps from one code base in record time!
  
 In this chapter, we are going to review some of the most important mobile development 
 trends and think about all kinds of innovative and successful mobile apps you can now 
 build!
  
 This chapter will cover the following points:
  
 Review of what we have learned
  
 Trends in mobile development
  
 Ideas for new and innovative apps for you to build
  
 The objective of this chapter is to show you the road ahead to be successful in the bright 
 new world of mobile app development!",NA
What we have learned,"Throughout this book, we have made the journey through different topics related to Delphi 
 programming from the perspective of building mobile apps.
  
 The main focus in the first chapter was to install and configure the Delphi 
 Integrated 
 Development Environment
  (
 IDE
 ) for cross-platform mobile development. That's the single, 
 biggest feature of Delphi cross-platform development: from one source code base, from one 
 project, just by switching target platforms in the project manager, you can natively compile",NA
Staying on top of everything,"Ideas about how you should structure your software architectures are changing at a faster 
 pace than ever. Clearly the technology is becoming more complex, and there are plenty of 
 things to look at. From the perspective of the mobile developer, there are mobile platforms 
 themselves, with new capabilities added with every new operating system version, there is 
 the exploding world of IoT with new standards popping up, and also the quickly changing 
 world of backend services that are no longer just about accessing a relational database 
 through a server code, but myriads of cloud services you can integrate with.",NA
Apps everywhere,"Mobile platforms keep evolving. With every new version of Android and iOS mobile 
 operating systems, existing frameworks are being constantly improved and new ones are 
 being added, such as speech recognition or mobile payments. The types of devices you can 
 deploy your apps on grows. Delphi already provides support for building apps to Google 
 Glass, but other targets, such as Android-based TV sets or cameras, can be used as 
 deployment targets today.
  
 Mobile devices and user experience will continue to evolve, and easier ways of interacting 
 with data and services will be emerging. 
 Virtual reality
  (
 VR
 ) is very different now than its 
 humble beginnings, and it will continue to grow. There are already many mobile apps that 
 provide an 
 augmented reality
  (
 AR
 ) experience where the virtual world is projected into a 
 view of the real world. Other mobile devices based on the metaphor of glasses will be built 
 to make AR the primary way of interacting with computer systems. Apple, Google, 
 Microsoft, Facebook, and other software giants are putting a lot of effort into making these 
 devices the next smartphones.",NA
Serverless backends and NoSQL,"Serverless
  architectures, 
 containers,
  and 
 microservices
  are some of the hot buzz words you can 
 hear here and there. With 
 container
  technology getting more mature, it is becoming practical 
 to start and stop a virtual machine just to execute one function. Cloud web services vendors, 
 such as Amazon, provide the underlying infrastructure for building new kinds of 
  
 architectures where you can just deploy the source code of a remote function 
  
 (
 https://aws.amazon.com/lambda/
 ) that you want to execute, and the whole complex aspect of 
 provisioning virtual machines, scaling, and load balancing becomes transparent to software 
 architects. With technologies such as 
 API Gateway 
  
 (
 https://aws.amazon.com/api-gateway/
 ), you can create, version, and manage your own REST 
 APIs at any scale with lots of flexibility and little hassle.
  
 Traditional SQL relational database management systems are no longer the only choice for 
 storing data. NoSQL and other types of data stores, such as graph databases, are gaining 
 more and more popularity. Some of the most interesting offerings in this space are the 
 MongoDB open source NoSQL database (
 https://www.mongodb.com/
 ), the Amazon 
 DynamoDB NoSQL database (
 https://aws.amazon.com/dynamodb/
 ), where you can configure 
 its desired response time, and the Neo4j graph database 
  
 (
 https://neo4j.com/product
 ), which offers a whole new way of modeling data, where relations 
 between the data are as important as the data itself.",NA
Internet of all kinds of things,"Software companies and analytics agree that IoT is the next big thing, but they have 
 different opinions on how the details will look. There are different IoT use cases and they 
 will be driving the adoption of particular technologies. Communication protocols are a 
 fundamental aspect of IoT, and there are many competing technologies, all with their 
 strengths and weaknesses. Beyond HTTP and Bluetooth's established and widely adopted 
 specifications, there are many more, such as MQTT, CoAP, LoRaWAN, NB-IoT, and others.",NA
Your next Delphi mobile app,"Your next Delphi app will obviously be very cool and successful. Think big and start small. 
 There are many sources of inspiration and places to learn about Delphi.
  
 Beyond the Delphi home page (
 http://www.embarcadero.com/products/delphi
 ) and Delphi rich 
 online documentation (
 http://docwiki.embarcadero.com/RADStudio/en/
 ), there is also a vibrant 
 community of developers (
 http://community.embarcadero.com
 ), where you can read news, 
 blogs, articles, and learn about online webinars and live Delphi events organized in your 
 neighborhood, and ask questions.
  
 Delphi community site app competitions for the coolest app are regularly organized. Check 
 out what other Delphi developers are building and you will be surprised about all the kinds 
 of interesting apps being built with Delphi, such as the Skype Windows client. I'm looking 
 forward to seeing your next great app winning at the Delphi community site!",NA
Summary,"I hope that you have enjoyed reading this book as much as I did writing it. That was a great 
 journey. Delphi is fun. I'm sure that the elegance of the Object Pascal language and the 
 technical excellence of Delphi Integrated Development Environments will continue to 
 enchant a growing number of software developers now and in many years to come.",NA
Index,NA,NA
3 ,"3D and 2D
  
  mixing  
 180 
  
 3D models
  
  URL  
 174
  
  using  
 174
 , 
 176
  
 anonymous code, Object Pascal phrase book  
 72
 , 
   
 73
 , 
 74 
  
 API Gateway
  
  URL  
 470 
  
 app stores
  
  Android apps, publishing to Google Play Store 
   
 447
 , 
 450",NA
A ,"abstract  
 154
  
  app, deploying  
 442
  
  Apple iOS App Store, apps publishing  
 442
 , 
 447
  
 monetizing, with ads  
 451
  
  
 action components
  
  used, for taking photos  
 241
 , 
 243
  
  monetizing, with in-app purchases  
 451 
 app tethering  
 298
 , 
 303
  
 address book 
  
 Apple iOS App Store
  
  working with  
 243
 , 
 251
  
  apps, publishing  
 442
 , 
 447
  
 Agile Manifesto
  
  URL  
 444
  
  URL  
 452 
  
 application enhancement
  
 Almond Blossoms
  
  about  
 452
  
  URL  
 287
  
  Continuous Integration  
 464
 , 
 465
  
 AltBeacon
  
  development  
 457
 , 
 459
  
  URL  
 285
  
  practical version control  
 453
 , 
 456
  
 Amazon Machine Image  
 382
  
  refactorings  
 457
 , 
 459
  
 Amazon S3
  
  release, planning  
 456
  
  ToDo List, moving to  
 364 
  
 Amazon Simple Storage Service (Amazon S3)  
 468
  
  unit testing  
 459
 , 
 461
 , 
 464 
  
 Application Programming Interface (API)  
 342
  
 Amazon Web Services Elastic Cloud 
  
 application
  
  URL  
 382
  
  lifecycle  
 226
 , 
 229
  
 Android application package (APK)  
 450 
  
 Architect version  
 9
  
 Android devices 
  
 arrays, Object Pascal Phrase Book  
 65
 , 
 66
  
  URL, for configuring system  
 32 
  
 AudioServicesPlaySystemSound API function
  
  URL, for executing apps  
 36
  
  URL  
 269
  
  URL, for USB driver installation  
 34
  
 URL, to enable USB debugging  
 32
  
 augmented reality (AR)  
 469 
  
 Automatic Reference Counting (ARC)  
 85
  
 Android services 
  
 AWS Lambda
  
  consuming  
 257
 , 
 267
  
  URL  
 470
  
  creating  
 257
 , 
 267 
  
 AWS Management Console
  
 Android
  
  URL  
 365
  
  vibrations  
 268",NA
B ,"Backend as a Service (BaaS)  
 362
 , 
 417 
 backend
  
  as service client  
 362 
  
 BeaconFence
  
  proximity solutions  
 294 
  
 beacons
  
  about  
 284
  
  app, creating in museum  
 285
  
  emulating, with TBeaconDevice  
 292 
 Bedroom in Arles
  
  URL  
 287 
  
 Bluetooth Low Energy (BLE)
  
  about  
 273
 , 
 274
 , 
 279
  
  reference link  
 276 
  
 Borland Turbo Pascal  
 17 
  
 Built-in Styles
  
  working with  
 184",NA
C ,"camera light
  
  switching off  
 241
 , 
 243
  
  switching on  
 241
 , 
 243 
  
 cloud services
  
  integrating with  
 363
  
  ToDo List, moving to Amazon S3  
 364
  
  Todo List, moving to Amazon S3  
 369
 , 
 371
 , 
 378
 , 
   
 380 
  
 communication protocols
  
  about  
 274 
  
 compilers  
 17 
  
 constants, Object Pascal Phrase Book  
 63 
  
 Constrained Application Protocol (CoAP)
  
  URL  
 471 
  
 Context3D
  
  using  
 152
 , 
 156 
  
 Create, Read, Update, Delete, and List (CRUDL) 
   
 308 
  
 cross-platform 3D app
  
  rendering  
 150 
  
 custom attributes, Object Pascal Phrase Book  
 75
 , 
   
 76 
  
 custom styles
  
  embedding, as resources  
 195
  
  using  
 191
  
 Custom Wireframe component  
 157
 , 
 161",NA
D ,"data-driven apps
  
  architecting  
 306 
  
 data-driven user interface
  
  building  
 322
 , 
 323
 , 
 324
 , 
 325
 , 
 326
 , 
 327
 , 
 328
 , 
  
  
 329
 , 
 330 
  
 Data.Cloud.AmazonAPI  
 363 
  
 Data.Cloud.AzureAPI  
 363 
  
 data
  
  modeling  
 307
 , 
 308
 , 
 309 
  
 database
  
  accessing, with FireDAC  
 311
 , 
 312
 , 
 313
 , 
 314
 , 
  
  
 315
 , 
 318
 , 
 319
 , 
 320
 , 
 322
  
  selecting  
 309
 , 
 310
 , 
 311 
  
 DataSnap
  
  about  
 405
  
  server functionality, implementing  
 410
 , 
 415
 , 
 417
  
 working with  
 405
 , 
 409 
  
 DB Power Studio Developer Edition  
 9 
  
 Delphi Project  
 30
 , 
 46 
  
 Delphi
  
  custom components, installing  
 14
  
  IDE options  
 16
  
  installer, executing  
 10
  
  installing  
 8
  
  Integrated Development Environment, riding  
 17
  
 mobile app, enhancing  
 472
  
  references  
 472
  
  URL  
 10
  
  URL, for installation  
 13
  
  versions  
 9 
  
 Deployment Manager  
 310 
  
 Document Type Definition (DTD)  
 100 
  
 DummyScene  
 169 
  
 DynamoDB NoSQL database
  
  URL  
 470",NA
E ,"Eddystone  
 285 
  
 Electronic Software Delivery (ESD)  
 10 
 Embarcadero  
 310 
  
 Embarcadero community
  
  URL  
 253
  
 [ 474 ]",NA
F ,"files
  
  working with  
 84
 , 
 87
 , 
 89 
  
 FireDAC",NA
H ,"Hello World app
  
  about  
 19
  
  deploying, to Android  
 32
  
 deploying, to iOS  
 36
  
  
  database, accessing  
 311
 , 
 312
 , 
 313
 , 
 314
 , 
 315
 , 
  
 318
 , 
 319
 , 
 320
 , 
 322
  
  deploying, to mobile devices  
 32 
  
 helpers, Object Pascal Phrase Book  
 67
 , 
 68
  
 FireMonkey 
  
 High Definition (HD)  
 108
  
  about  
 150 
  
 Hypertext Markup Language (HTML)  
 341
  
  code, for drawing  
 107
 , 
 114 
  
 FireUI App Preview  
 218 
  
 forms
  
  previewing, on devices  
 218
 , 
 219 
 frames
  
  using  
 203
 , 
 211 
  
 functions  
 44
  
 Hypertext Transfer Protocol (HTTP)  
 341",NA
I ,"IDE Insight  
 23 
  
 Identity and Access Management (IAM)  
 367 
 inherited views
  
  working with  
 212
 , 
 217",NA
G ,"Game of Memory
  
  about  
 131
  
  aligning  
 135
  
  anchoring  
 135
  
  configuration, storing  
 144
 , 
 147
  
 games, designing  
 132
  
  images, working with  
 132
  
  layouts  
 136
  
  main form, building  
 136
 , 
 144
  
 margins  
 135
  
  settings form  
 147
 , 
 149
  
  user interface, designing  
 134 
 GameOfMemory app  
 50 
  
 GATT client  
 275 
  
 GATT server  
 275
  
 INQStats service
  
  references  
 352 
  
 Integrated Development Environment (IDE) 
 about  
 8
 , 
 467
  
  riding  
 17 
  
 interactive 3D scene
  
  building  
 167
 , 
 174 
  
 InterBase
  
  URL  
 310 
  
 Internet of Things (IoT)
  
  about  
 274
  
  evolving  
 470
 , 
 471 
  
 iOS devices
  
  URL, for deploying apps from Delphi  
 41
  
 vibrations  
 269
 , 
 272 
  
 iTunes Connect
  
  URL  
 444
  
  
 Generic Attribute Profile (GATT)
  
  about  
 274
  
  references  
 274 
  
 generic type, Object Pascal Phrase Book  
 68
 , 
 70 
 GetIt Package Manager  
 273 
  
 Git
  
  URL  
 454",NA
J ,"JavaScript Object Notation (JSON) 
 about  
 90
 , 
 351
  
  reading  
 95
  
  URL  
 90
  
  writing  
 91
 , 
 95
  
 [ 475 ]",NA
K ,NA,NA
N,"Kinvey 
  
 NarrowBand IoT (NB-IoT)  
 471
  
  URL  
 363 
  
 native HTTP client  
 342
 , 
 345",NA
L ,"language bridges
  
  about  
 267
  
  vibrating, on Android  
 268
  
 Neo4j graph database
  
  URL  
 470 
  
 New WebBroker App  
 384 
  
 notification
  
  displaying  
 251
  
  vibrations, on iOS  
 269
 , 
 272 
  
 Live Preview feature  
 298 
  
 LoRa wide area networks
  
  URL  
 471 
  
 low power, wide-area networks (LPWAN)  
 471",NA
O ,"Object Pascal language  
 24 
 Object Pascal Phrase Book 
 about  
 62",NA
M ,"machine-to-machine (M2M)  
 471 
  
 maps
  
  working with  
 254
 , 
 256 
  
 mobile devices
  
  Hello World app, deploying  
 32 
  
 mobile operating system  
 222 
  
 mobile platforms
  
  apps popularity  
 469
  
  IoT, evolving  
 470
  
  NoSQL  
 470
  
  serverless backends  
 470
  
  setting off  
 469 
  
 Molecule Hero
  
  about  
 442
  
  URL  
 442 
  
 MongoDB open source NoSQL database
  
  URL  
 470 
  
 Monte Carlo Localization algorithm  
 296 
  
 Moving Earth project
  
  interactive 3D visualization, creating  
 163
 , 
 167
  
 reference link  
 164 
  
 MQ Telemetry Transport (MQTT)
  
  URL  
 471
  
  anonymous code  
 72
 , 
 73
 , 
 74
  
  arrays  
 65
 , 
 66
  
  constants  
 63
  
  custom attributes  
 75
 , 
 76
  
  generics  
 68
 , 
 70
  
  helpers  
 67
 , 
 68
  
  operator overloading  
 74
  
  runtime type information  
 76
  
  sets  
 65
 , 
 66
  
  tokens  
 62
  
  types  
 64 
  
 Object Pascal
  
  about  
 43
  
  console application  
 45
 , 
 46
 , 
 47
 , 
 48
 , 
 49
  
  forms applications  
 49
 , 
 50
 , 
 52
 , 
 54
 , 
 55
 , 
 56
 , 
 59
 , 
   
 60
 , 
 61
  
  program structure  
 44
 , 
 45 
  
 Objects 3D  
 161
 , 
 162 
  
 open APIs
  
  URL  
 352 
  
 OpenGL ES  
 151 
  
 operating system
  
  determining  
 222
 , 
 226 
  
 operator overloading, Object Pascal phrase book 
   
 74
  
 Multi-Generational Architecture  
 310 
 multi-tier architectures",NA
P,"about  
 381
 , 
 383
  
 parallel programming library (PPL)
  
  about  
 78
 , 
 468
  
  futures  
 82
  
  parallel loops  
 79
  
 [ 476 ]",NA
T ,"TBeaconDevice
  
  beacons, emulating  
 292 
  
 The Potato Eaters
  
  URL  
 287 
  
 ThingConnect",NA
R ,"RAD Server
  
  resources, building  
 426
 , 
 431
 , 
 434
 , 
 436
 , 
 439
 , 
   
 440
  
  REST API publishing  
 417
  
  setting up  
 418
 , 
 424 
  
 Rapid Application Development (RAD)  
 152
 , 
 331 
 refactoring
  
  about  
 457
  
  URL  
 457
  
  things, connecting  
 280
 , 
 284 
  
 Things Network
  
  URL  
 471 
  
 timer
  
  precise timing, using  
 116
  
  used, for animation  
 114 
  
 To-Do List app  
 374 
  
 todostorage  
 365 
  
 tokens, Object Pascal phrase book  
 62 
 Tokyo Enterprise edition  
 10 
  
 toolchains  
 17
  
  
 Representational State Transfer (REST)  
 342
 , 
 351 
 REST API
  
  publishing  
 418 
  
 REST Debugger  
 353 
  
 REST services
  
  integrating with  
 351
 , 
 358
 , 
 361 
  
 Runtime Type Information (RTTI)
  
  about  
 43
 , 
 76
  
  using  
 468
  
 types, Object Pascal phrase book  
 64",NA
U ,"Uniform Resource Locators (URL)  
 341 
 units  
 44 
  
 user interaction
  
  about  
 125
  
  gestures, handling  
 127
 , 
 129
  
  multitouch, handling  
 129
 , 
 131",NA
S ,"sensors
  
  touch, handling  
 125
 , 
 127 
  
 user interface
  
  prototyping  
 333
 , 
 334
 , 
 335
 , 
 336
 , 
 337
 , 
 338
  
  using  
 229
 , 
 235
  
 [ 477 ]",NA
V ,"versions, Delphi
  
  Architect  
 9
  
  Enterprise  
 9
  
  Professional  
 9
  
  Starter  
 9 
  
 Vibrator class
  
  URL  
 268 
  
 Virtual reality (VR)  
 469 
 visual live bindings
  
  using  
 331
 , 
 332
 , 
 333",NA
W ,"web services  
 341
 , 
 342
  
 Web Services Description Language (WSDL)  
 345 
 web
  
  navigating  
 253
 , 
 254 
  
 WebBroker
  
  about  
 384
  
  project, creating  
 384
 , 
 387
  
  projects, organizing  
 387
 , 
 390
 , 
 402
 , 
 404 
  
 WSDL Importer  
 345",NA
X ,"XML Schema  
 100 
  
 XML SOAP web services
  
  consuming  
 345
 , 
 351
  
  references  
 345",NA
