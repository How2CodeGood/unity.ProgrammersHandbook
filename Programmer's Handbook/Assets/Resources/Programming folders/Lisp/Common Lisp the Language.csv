Larger Text,Smaller Text,Symbol
Contents,"1
  
 Introduction
  
 1
  
 1.1
  
 Purpose . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 1
  
 1.2
  
 Notational Conventions . . . . . . . . . . . . . . . . . . . . . .
  
 4
  
 1.2.1
  
 Decimal Numbers . . . . . . . . . . . . . . . . . . . . .
  
 4
  
 1.2.2
  
 Nil, False, and the Empty List . . . . . . . . . . . . . .
  
 4
  
 1.2.3
  
 Evaluation, Expansion, and Equivalence
  
 . . . . . . . .
  
 5
  
 2
  
 1.2.4
  
 Errors . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 6
  
 1.2.5
  
 Descriptions of Functions and Other Entities . . . . . .
  
 7
  
 1.2.6
  
 The Lisp Reader
  
 . . . . . . . . . . . . . . . . . . . . .
  
 10
  
 1.2.7
  
 Overview of Syntax . . . . . . . . . . . . . . . . . . . .
  
 10
  
 Data Types
  
 13
  
 2.1
  
 Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 16
  
 2.1.1
  
 Integers
  
 . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 17
  
 2.1.2
  
 Ratios . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 18
  
 2.1.3
  
 Floating-Point Numbers . . . . . . . . . . . . . . . . .
  
 19
  
 2.1.4
  
 Complex Numbers
  
 . . . . . . . . . . . . . . . . . . . .
  
 23
  
 2.2
  
 Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 24
  
 2.2.1
  
 Standard Characters . . . . . . . . . . . . . . . . . . .
  
 25
  
 2.2.2
  
 Line Divisions . . . . . . . . . . . . . . . . . . . . . . .
  
 26
  
 2.2.3
  
 Non-standard Characters . . . . . . . . . . . . . . . . .
  
 27
  
 2.3
  
 Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 27
  
 2.4
  
 Lists and Conses
  
 . . . . . . . . . . . . . . . . . . . . . . . . .
  
 30
  
 2.5
  
 Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 32
  
 2.5.1
  
 Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 33
  
 2.5.2
  
 Strings . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 34
  
 2.5.3
  
 Bit-Vectors
  
 . . . . . . . . . . . . . . . . . . . . . . . .
  
 35
  
 2.6
  
 Hash Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  
 35
  
 v",NA
Preface SECOND EDITION,"Common Lisp has succeeded. Since publication of the first edition of this 
 book in 1984, many implementors have used it as a
  de facto
  standard for 
 Lisp implementation. As a result, it is now much easier to port large Lisp 
 programs from one implementation to another. Common Lisp has proved to 
 be a useful and stable platform for rapid prototyping and systems delivery 
 in artificial intelligence and other areas. With experience gained in using 
 Common Lisp for so many applications, implementors found no shortage of 
 opportunities for innovation. One of the important characteristics of Lisp is 
 its good support for experimental extension of the language; while Common 
 Lisp has been stable, it has not stagnated.
  
 The 1984 definition of Common Lisp was imperfect and incomplete. In 
 some cases this was inadvertent: some odd boundary situation was over-
 looked and its consequences not specified, or different passages were in 
 con-flict, or some property of Lisp was so well-known and traditionally 
 relied upon that I forgot to write it down. In other cases the informal 
 committee that was defining Common Lisp could not settle on a solution, 
 and therefore agreed to leave some important aspect of the language 
 unspecified rather than choose a less than satisfactory definition. An 
 example is error handling; 1984 Common Lisp had plenty of ways to signal 
 errors but no way for a program to trap or process them.
  
 Over the next year I collected reports of errors in the book and gaps in 
 the language. In December 1985, a group of implementors and users met in 
 Boston to discuss the state of Common Lisp. I prepared two lists for this 
 meeting, one of errata and clarifications that I thought would be relatively 
 uncontroversial (boy, was I wrong!) and one of more substantial changes I 
 thought should be considered and perhaps voted upon. Others also brought 
 proposals to discuss. It became clear to everyone that there was now 
 enough interest in Common Lisp, and dependence on its stability, that a 
 more formal
  
 xv",NA
Acknowledgments SECOND ,NA,NA
EDITION,"First and foremost, I must thank the many people in the Lisp community 
 who have worked so hard to specify, implement, and use Common Lisp. 
 Some of these have volunteered many hours of effort as members of ANSI 
 committee X3J13. Others have made presentations or proposals to X3J13, 
 and yet others have sent suggestions and corrections to the first edition 
 directly to me. This book builds on their efforts as well as mine.
  
 An early draft of this book was made available to all members of X3J13 
 for their criticism. I have also worked with the many public documents that 
 have been written during the course of the committee’s work (which is not 
 over yet). It is my hope that this book is an accurate reflection of the 
 committee’s actions as of October 1989. Nevertheless, any errors or 
 inconsistencies are my responsibility. The fact that I have made a draft 
 available to certain persons, received feedback from them, or thanked them 
 in these acknowledgments does not necessarily imply that any one of them 
 or any of the institutions with which they are affiliated endorse this book or 
 anything of its contents.
  
 Digital Press and I gave permission to X3J13 to use any or all parts of the 
 first edition in the production of an ANSI Common Lisp standard. Con-
 versely, in writing this book I have worked with publicly available 
 documents produced by X3J13 in the course of its work, and in some cases 
 as a courtesy have obtained the consent of the authors of those documents 
 to quote them extensively. This common ancestry will result in similarities 
 between this book and the emerging ANSI Common Lisp standard (that is 
 the purpose, after all). Nevertheless, this second edition has no official 
 connection what-soever with X3J13 or ANSI, nor is it endorsed by either of 
 those institutions.
  
 The following persons have been members of X3J13 or involved in its 
 activities at one time or another: Jim Allard, Dave Andre, Jim Antonisse,
  
 xxi",NA
Acknowledgments FIRST,NA,NA
EDITION (1984),"Common Lisp was designed by a diverse group of people affiliated with many
  
 institutions.
  
 Contributors to the design and implementation of Common Lisp and to
  
 the polishing of this book are hereby gratefully acknowledged:
  
 Paul Anagnostopoulos Digital Equipment Corporation
  
 Dan Aronson Carnegie-Mellon University
  
 Alan Bawden Massachusetts Institute of Technology
  
 Eric Benson University of Utah, Stanford University, and Symbolics,
  
 Incorporated
  
 Jon Bentley Carnegie-Mellon University and Bell Laboratories
  
 Jerry Boetje Digital Equipment Corporation
  
 Gary Brooks Texas Instruments
  
 Rodney A. Brooks Stanford University
  
 Gary L. Brown Digital Equipment Corporation
  
 Richard L. Bryan Symbolics, Incorporated
  
 Glenn S. Burke Massachusetts Institute of Technology
  
 Howard I. Cannon Symbolics, Incorporated
  
 George J. Carrette Massachusetts Institute of Technology
  
 Robert Cassels Symbolics, Incorporated
  
 Monica Cellio Carnegie-Mellon University
  
 David Dill Carnegie-Mellon University
  
 Scott E. Fahlman Carnegie-Mellon University
  
 Richard J. FatemanUniversity of California, Berkeley
  
 Neal Feinberg Carnegie-Mellon University
  
 Ron Fischer Rutgers University
  
 John Foderaro University of California, Berkeley
  
 xxvii",NA
Chapter 1,NA,NA
Introduction,"Common Lisp is a new dialect of Lisp, a successor to MacLisp [33, 37], 
 influenced strongly by Zetalisp [55, 34] and to some extent by Scheme [46] 
 and Interlisp [50].",NA
1.1 ,NA,NA
Purpose,"Common Lisp is intended to meet these goals:
  
 Commonality
  Common Lisp originated in an attempt to focus the work of 
 several implementation groups, each of which was constructing 
 succes-sor implementations of MacLisp for different computers. 
 These imple-mentations had begun to diverge because of the 
 differences in the im-plementation environments: microcoded 
 personal computers (Zetalisp, Spice Lisp), commercial timeshared 
 computers 
 (NIL—the 
 “New 
 Imple-mentation 
 of 
 Lisp”), 
 and 
 supercomputers (S-1 Lisp). While the differ-ences among the several 
 implementation environments of necessity will continue to force 
 certain incompatibilities among the implementations, Common Lisp 
 serves as a common dialect to which each implementa-tion makes any 
 necessary extensions.
  
 Portability
  Common Lisp intentionally excludes features that cannot be 
 implemented easily on a broad class of machines. On the one hand, 
 features that are difficult or expensive to implement on hardware 
 with-out special microcode are avoided or provided in a more 
 abstract and
  
 1",NA
1.2 Notational Conventions,"A number of special notational conventions are used throughout this book 
 for the sake of conciseness.",NA
1.2.1 Decimal Numbers,"All numbers in this book are in decimal notation unless there is an explicit 
 indication to the contrary. (Decimal notation is normally taken for granted, 
 of course. Unfortunately, for certain other dialects of Lisp, MacLisp in 
 partic-ular, the default notation for numbers is octal (base 8) rather than 
 decimal, and so the use of decimal notation for describing Common Lisp is, 
 taken in its historical context, a bit unusual!)",NA
"1.2.2 Nil, False, and the Empty List","In Common Lisp, as in most Lisp dialects, the symbol
  nil
  is used to represent 
 both the empty list and the “false” value for Boolean tests. An empty list 
 may, of course, also be written
  ()
 ; this normally denotes the same object as
  
 nil
 . (It is possible, by extremely perverse manipulation of the package 
 system, to cause the sequence of letters
  nil
  to be recognized not as the 
 symbol that represents the empty list but as another symbol with the same 
 name. This obscure possibility will be ignored in this book.) These two 
 notations may be used interchangeably as far as the Lisp system is 
 concerned. However, as a matter of style, this book uses the notation () 
 when it is desirable to emphasize the use of an empty list, and uses the 
 notation
  nil
  when it is desirable to emphasize the use of the Boolean “false”. 
 The notation
  ’nil",NA
"1.2.3 Evaluation, Expansion, and Equivalence","Execution of code in Lisp is called
  evaluation
  because executing a piece of 
 code normally results in a data object called the
  value
  produced by the code.
  
 The symbol
  ⟨
  is used in examples to indicate evaluation. For example, (+ 4 
 5)
  ⟨
  9 
  
 means “the result of evaluating the code
  (+ 4 5)
  is (or would be, or would 
 have been)
  9
 .”
  
 example, The symbol
  →
  is used in examples to indicate macro expansion. For
  
 (push x v)
  →
  (setf v (cons x v)) 
  
 means “the result of expanding the macro-call form
  (push x v)
  is
  (setf v 
 (cons x v))
 .” This implies that the two pieces of code do the same thing; the 
 second piece of code is the definition of what the first does.
  
 example, The symbol
  ≡
  is used in examples to indicate code equivalence. 
  
 For
  
 (gcd x (gcd y z))
  ≡
  (gcd (gcd x y) z) 
  
 means “the value and effects of evaluating the form
  (gcd x (gcd y z)) 
 are 
 always the same as the value and effects of
  (gcd (gcd x y) z)
  for any values 
 of the variables
  x
 ,
  y
 , and
  z
 .” This implies that the two pieces of code do the 
 same thing; however, neither directly defines the other in the way macro 
 expansion does.",NA
Errors,CHAPTER 1. INTRODUCTION,NA
1.2.4,"When this book specifies that it “is an error” for some situation to occur, this 
 means that:
  
 •
  No valid Common Lisp program should cause this situation to occur.
 •
  If 
 this situation occurs, the effects and results are completely undefined as 
 far as adherence to the Common Lisp specification is concerned.
  
 •
  No Common Lisp implementation is required to detect such an error. Of 
 course, implementors are encouraged to provide for detection of such 
  
 errors wherever reasonable.
  
 This is not to say that some particular implementation might not define the 
 effects and results for such a situation; the point is that no program 
 conforming to the Common Lisp specification may correctly depend on such 
 effects or results.
  
  
 On the other hand, if it is specified in this book that in some situation“an 
 error is
  signaled
 ,” this means that:
  
 •
  If this situation occurs, an error will be signaled (see
  error
  and
  
 cerror
 ).
 •
  Valid Common Lisp programs may rely on the fact that an error 
 will be signaled.
  
 •
  Every Common Lisp implementation is required to detect such an error.
  
 In places where it is stated that so-and-so “must” or “must not” or “may 
 not” be the case, then it “is an error” if the stated requirement is not met. 
 For example, if an argument “must be a symbol,” then it “is an error” if the 
 argument is not a symbol. In all cases where an error is to be
  signaled
 , the 
 word “signaled” is always used explicitly in this book.
  
 X3J13 has adopted a more elaborate terminology for errors, and has 
 made some effort to specify the type of error to be signaled in situations 
 where signaling is appropriate. This effort was not complete as of 
 September 1989, and I have made little attempt to incorporate the new 
 error terminology or error type specifications in this book. However, the 
 new terminology is described and used in the specification of the Common 
 Lisp Object System appearing in chapter 28; this gives the flavor of how",NA
1.2.5 Descriptions of Functions and Other Entities,"Functions, variables, named constants, special operators, and macros are 
 described using a distinctive typographical format. Table 1.1 illustrates the 
 manner in which Common Lisp functions are documented. The first line 
 specifies the name of the function, the manner in which it accepts 
 arguments, and the fact that it is a function. If the function takes many 
 arguments, then the names of the arguments may spill across two or three 
 lines. The paragraphs following this standard header explain the definition 
 and uses of the function and often present examples or related functions.
  
 Sometimes two or more related functions are explained in a single com-",NA
1.2.6 The Lisp Reader,"The term “Lisp reader” refers not to you, the reader of this book, nor to 
 some person reading Lisp code, but specifically to a Lisp procedure, namely 
 the function
  read
 , which reads characters from an input stream and 
 interprets them by parsing as representations of Lisp objects.",NA
1.2.7 Overview of Syntax,"Certain characters are used in special ways in the syntax of Common Lisp. 
 The complete syntax is explained in detail in chapter 22, but a quick 
 summary here may be useful:
  
 (
  A left parenthesis begins a list of items. 
  
 The list may contain any 
  
 number of items, including zero. Lists may be nested. For example, 
  
 (cons (car x) (cdr y))
  is a list of three things, of which the last two 
  
 are themselves lists.
  
 )
  A right parenthesis ends a list of items.",NA
Chapter 2,NA,NA
Data Types,"Common Lisp provides a variety of types of data objects. It is important to 
 note that in Lisp it is data objects that are typed, not variables. Any variable 
 can have any Lisp object as its value. (It is possible to make an explicit 
 declaration that a variable will in fact take on one of only a limited set of 
 values. However, such a declaration may always be omitted, and the 
 program will still run correctly. Such a declaration merely constitutes advice 
 from the user that may be useful in gaining efficiency. See
  declare
 .) In 
 Common Lisp, a data type is a (possibly infinite) set of Lisp objects. Many 
 Lisp objects belong to more than one such set, and so it doesn’t always make 
 sense to ask what is
  the
  type of an object; instead, one usually asks only 
 whether an object belongs to a given type. The predicate
  typep
  may be used 
 to ask whether an object belongs to a given type, and the function 
 type-of
  
 returns
  a
  type to which a given object belongs.
  
 The data types defined in Common Lisp are arranged into a hierarchy 
 (actually a partial order) defined by the subset relationship. Certain sets of 
 objects, such as the set of numbers or the set of strings, are interesting 
 enough to deserve labels. Symbols are used for most such labels (here, and 
 throughout this book, the word “symbol” refers to atomic symbols, one kind 
 of Lisp object, elsewhere known as literal atoms). See chapter 4 for a 
 complete description of type specifiers.
  
 The set of all objects is specified by the symbol
  t
 . The empty data type, which 
 contains no objects, is denoted by
  nil
 .
  
 The following categories of Common Lisp objects are of particular inter-
 est: numbers, characters, symbols, lists, arrays, structures, and functions. 
 There are others as well. Some of these categories have many subdivisions.
  
 13",NA
2.1 Numbers,"Several kinds of numbers are defined in Common Lisp. They are divided 
 into 
 integers
 ;
  ratios
 ;
  floating-point numbers
 , with names provided for up to 
 four different floating-point representations;
  reals
  and
  complex numbers
 .
  
 The
  number
  data type encompasses all kinds of numbers. For conve-
 nience, there are names for some subclasses of numbers as well. Integers 
 and ratios are of type
  rational
 . Rational numbers and floating-point 
 numbers are of type
  real
 . Real numbers and complex numbers are of type
  
 number
 .",NA
2.1.1 Integers,"The
  integer
  data type is intended to represent mathematical integers. 
 Unlike most programming languages, Common Lisp in principle imposes no 
 limit on the magnitude of an integer; storage is automatically allocated as 
 necessary to represent large integers.
  
 In every Common Lisp implementation there is a range of integers that are 
 represented more efficiently than others; each such integer is called a
  
 fixnum
 , and an integer that is not a fixnum is called a
  bignum
 . Common Lisp 
 is designed to hide this distinction as much as possible; the distinction 
 between fixnums and bignums is visible to the user in only a few places 
 where the efficiency of representation is important. Exactly which integers 
 are fixnums is implementation-dependent; typically they will be those 
 integers in the range
  −
 2
 n
 to 2
 n
 −
  1, inclusive, for some
  n
  not less than 15. 
 positive-fixnum
  and
  most-negative-fixnum
 . 
  
 See
  most-
  
 fixnum
  must be a supertype of the type
  (signed-byte 16)
 , and addition-
 ally that the value of
  array-dimension-limit
  must be a fixnum (implying 
 that the implementor should choose the range of fixnums to be large 
 enough to accommodate the largest size of array to be supported).
  
 Rationale:
  This specification allows programmers to declare variables in portable 
 code to be of type
  fixnum
  for efficiency. Fixnums are guaranteed to encompass 
 at least the set of 16-bit signed integers (compare this to the data type
  short
  
 int
  in the C programming language). In addition, any valid array index must be 
 a fixnum, and therefore variables used to hold array indices (such as a
  dotimes
  
 variable) may be declared
  fixnum
  in portable code. 
 Integers are ordinarily written in decimal notation, as a sequence of 
 deci-mal digits, optionally preceded by a sign and optionally followed by a 
 decimal point. For example:",NA
2.1.2,";Another way of writing
  213
  decimal 
 ;Ditto 
  
 ;Ditto 
  
 ;Ditto, in octal radix 
  
 ;Ditto, in hexadecimal radix 
  
 ;Ditto 
  
 ;Decimal -192, written in base 8 
  
 ;Same thing in base 3 
  
 ;Same thing in base 25 
  
 ;181202413, in hexadecimal radix",NA
Ratios,"A
  ratio
  is a number representing the mathematical ratio of two integers. 
 Integers and ratios collectively constitute the type
  rational
 . The canonical 
 representation of a rational number is as an integer if its value is integral,",NA
2.1.3 Floating-Point Numbers,"Common Lisp allows an implementation to provide one or more kinds of 
 floating-point number, which collectively make up the type
  float
 . Now a 
 floating-point number is a (mathematical) rational number of the form
  s ·f · 
 b
 e−p
 , where
  s
  is +1 or
  −
 1, the
  sign
 ;
  b
  is an integer greater than 1, the",NA
2.1.4,NA,NA
Complex Numbers,"Complex numbers (type
  complex
 ) are represented in Cartesian form, with 
 a real part and an imaginary part, each of which is a non-complex number 
 (integer, ratio, or floating-point number). It should be emphasized that the 
 parts of a complex number are not necessarily floating-point numbers; in 
 this, Common Lisp is like PL/I and differs from Fortran. However, both",NA
2.2 Characters,"Characters are represented as data objects of type
  character
 .
  
 A character object can be notated by writing
  #\
  followed by the char-
 acter itself. For example,
  #\g
  means the character object for a lowercase g. 
 This works well enough for printing characters. Non-printing characters 
 have names, and can be notated by writing
  #\
  and then the name; for exam-
 ple,
  #\Space
  (or
  #\SPACE
  or
  #\space
  or
  #\sPaCE
 ) means the space 
 character. The syntax for character names after
  #\
  is the same as that for 
 symbols. However, only character names that are known to the particular 
 implementation may be used.",NA
2.2.1 Standard Characters,"Common Lisp defines a standard character set (subtype
  standard-char
 ) for 
 two purposes. Common Lisp programs that are
  written
  in the standard 
 char-acter set can be read by any Common Lisp implementation; and 
 Common Lisp programs that
  use
  only standard characters as data objects 
 are most likely to be portable. The Common Lisp character set consists of a 
 space character
  #\Space
 , a newline character
  #\Newline
 , and the 
 following ninety-four non-blank printing characters or their equivalents:
  
 ! "" # $ % & ’ ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
  
 @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _‘ a b c d e f g h 
 i j k l m n o p q r s t u v w x y z { | } ~
  
 The Common Lisp standard character set is apparently equivalent to the 
 ninety-five standard ASCII printing characters plus a newline character. 
 Nevertheless, Common Lisp is designed to be relatively independent of the 
 ASCII character encoding. For example, the collating sequence is not speci-
 fied except to say that digits must be properly ordered, the uppercase 
 letters must be properly ordered, and the lowercase letters must be 
 properly ordered (see
  char<
  for a precise specification). Other character 
 encodings, particu-larly EBCDIC, should be easily accommodated (with a 
 suitable mapping of printing characters).
  
 Of the ninety-four non-blank printing characters, the following are used in 
 only limited ways in the syntax of Common Lisp programs:
  
 [ ] { } ? ! ^ _ ~ $ %
  
 The following characters are called
  semi-standard
 :
  
 #\Backspace #\Tab #\Linefeed #\Page #\Return #\Rubout
  
 Not all implementations of Common Lisp need to support them; but 
 those implementations that use the standard ASCII character set should 
 support them, treating them as corresponding respectively to the ASCII 
 characters BS (octal code 010), HT (011), LF (012), FF (014), CR (015), and 
 DEL (177). These characters are not members of the subtype
  standard-
 char 
 unless synonymous with one of the standard characters specified 
 above. For example, in a given implementation it might be sensible for the 
 implementor to define
  #\Linefeed
  or
  #\Return
  to be synonymous with
  
 #\Newline
 , or
  #\Tab
  to be synonymous with
  #\Space
 .",NA
2.2.2,NA,NA
Line Divisions,"The treatment of line divisions is one of the most difficult issues in 
 designing portable software, simply because there is so little agreement 
 among operat-ing systems. Some use a single character to delimit lines; the 
 recommended ASCII character for this purpose is the line feed character LF 
 (also called the new line character, NL), but some systems use the carriage 
 return char-acter CR. Much more common is the two-character sequence 
 CR followed by LF. Frequently line divisions have no representation as a 
 character but are implicit in the structuring of a file into records, each 
 record containing a line of text. A deck of punched cards has this structure, 
 for example.
  
 Common Lisp provides an abstract interface by requiring that there be a 
 single character,
  #\Newline
 , that within the language serves as a line
  
 delimiter
 .
  
 (The language C has a similar requirement.)
  
 An implementa-
  
 tion of Common Lisp must translate between this internal single-character 
 representation and whatever external representation(s) may be used.
  
 Implementation note:
  How the character called
  #\Newline
  is represented 
 internally is not specified here, but it is strongly suggested that the ASCII LF 
 character be used in Common Lisp implementations that use the ASCII character 
 encoding. The ASCII CR character is a workable, but in most cases inferior, 
 alternative. 
 The requirement that a line division be represented as a single character
  
 has certain consequences.
  
 A character string written in the middle of a
  
 program in such a way as to span more than one line must contain exactly 
 one character to represent each line division. Consider this code fragment:
  
 (setq a-string ""This string 
  
 contains 
  
 forty-two characters."")
  
 Between
  g
  and
  c
  there must be exactly one character,
  #\Newline
 ; a 
 two-character sequence, such as
  #\Return
  and then
  #\Newline
 , is not 
 acceptable, nor is the absence of a character. The same is true between
  s 
 and
  f
 .
  
 When the character
  #\Newline
  is written to an output file, the Com-
 mon Lisp implementation must take the appropriate action to produce a 
 line division. This might involve writing out a record or translating
  
 #\Newline 
 to a CR/LF sequence.",NA
2.2.3,NA,NA
Non-standard Characters,"Any implementation may provide additional characters, whether printing 
 characters or named characters. Some plausible examples:
  
 #\
 π
  #\
 α
  #\Break #\Home-Up #\Escape
  
 The use of such characters may render Common Lisp programs non-
 portable.",NA
2.3 ,NA,NA
Symbols,"Symbols are Lisp data objects that serve several purposes and have several 
 interesting characteristics. Every object of type
  symbol
  has a name, called 
 its
  print name
 . Given a symbol, one can obtain its name in the form of a 
 string. Conversely, given the name of a symbol as a string, one can obtain the 
 symbol itself. (More precisely, symbols are organized into
  packages
 , and all 
 the symbols in a package are uniquely identified by name. See chapter 11.) 
 Symbols have a component called the
  property list
 , or
  plist
 . By convention 
 this is always a list whose even-numbered components (calling the first com-
 ponent zero) are symbols, here functioning as property names, and whose 
 odd-numbered components are associated property values. 
  
 Functions are 
 provided for manipulating this property list; in effect, these allow a symbol 
 to be treated as an extensible record structure.",NA
2.4 Lists and Conses,"A
  cons
  is a record structure containing two components called the
  car
  and 
 the
  cdr
 . Conses are used primarily to represent lists.
  
 A
  list
  is recursively defined to be either the empty list or a cons whose 
 cdr
  component is a list. A list is therefore a chain of conses linked by their 
 cdr
  components and terminated by
  nil
 , the empty list. The
  car
  components 
 of the conses are called the
  elements
  of the list. For each element of the list 
 there is a cons. The empty list has no elements at all.
  
 A list is notated by writing the elements of the list in order, separated by 
 blank space (space, tab, or return characters) and surrounded by 
 parentheses.
  
 (a b c) 
  
  
 ;A list of three symbols 
  
 (2.0s0 (a 1) #\*) 
   
 ;A list of three things: a short floating-point ; 
 number, another list, and a character object
  
  
 The empty list
  nil
  therefore can be written as (), because it is a list with 
 no elements.
  
 A
  dotted list
  is one whose last cons does not have
  nil
  for its
  cdr
 , rather 
 some other data object (which is also not a cons, or the first-mentioned",NA
2.5 Arrays,"An
  array
  is an object with components arranged according to a Cartesian 
 coordinate system. 
  
 In general, these components may be any Lisp data 
 objects.
  
 The number of dimensions of an array is called its
  rank
  (this 
 terminology is borrowed from APL); the rank is a non-negative integer. 
 Likewise, each dimension is itself a non-negative integer. The total number 
 of elements in the array is the product of all the dimensions.
  
  
 An implementation of Common Lisp may impose a limit on the rank of an 
 array, but this limit may not be smaller than 7. Therefore, any Common Lisp 
 program may assume the use of arrays of rank 7 or less. (A program may 
 determine the actual limit on array ranks for a given implementation by 
 examining the constant
  array-rank-limit
 .) 
  
  
 It is permissible for a dimension to be zero. In this case, the array has no 
 elements, and any attempt to access an element is in error. However, other 
 properties of the array, such as the dimensions themselves, may be used. If 
 the rank is zero, then there are no dimensions, and the product of the 
 dimensions is then by definition 1. A zero-rank array therefore has a single 
 element.
  
 An array element is specified by a sequence of indices. The length of the 
 sequence must equal the rank of the array. Each index must be a non-
 negative integer strictly less than the corresponding array dimension. Array 
 indexing is therefore zero-origin, not one-origin as in (the default case of) 
 Fortran.
  
 As an example, suppose that the variable
  foo
  names a 3-by-5 array. 
 Then the first index may be 0, 1, or 2, and the second index may be 0, 1, 2, 3, 
 or 4. One may refer to array elements using the function
  aref
 ; for example, 
 (aref foo 2 1)
  refers to element (2, 1) of the array. Note that
  aref
  takes a 
 variable number of arguments: an array, and as many indices as the array 
 has dimensions. A zero-rank array has no dimensions, and therefore
  aref 
 would take such an array and no indices, and return the sole element of the 
 array.
  
 In general, arrays can be multidimensional, can share their contents 
 with other array objects, and can have their size altered dynamically (either 
 en-larging or shrinking) after creation. A one-dimensional array may also 
 have a
  fill pointer
 .
  
 Multidimensional arrays store their components in row-major order; that",NA
2.5.1 Vectors,"One-dimensional arrays are called
  vectors
  in Common Lisp and constitute 
 the type
  vector
  (which is therefore a subtype of
  array
 ). Vectors and lists 
 are collectively considered to be
  sequences
 . They differ in that any 
 component of a one-dimensional array can be accessed in constant time, 
 whereas the average component access time for a list is linear in the length 
 of the list; on the other hand, adding a new element to the front of a list 
 takes constant time, whereas the same operation on an array takes time 
 linear in the length of the array.
  
 A general vector (a one-dimensional array that can have any data object 
 as an element but that has no additional paraphernalia) can be notated by 
 notating the components in order, separated by whitespace and 
 surrounded by
  #(
  and
  )
 . For example:
  
 #(a b c) 
  
  
 ;A vector of length 3 
  
 #() 
  
  
 ;An empty vector 
  
 #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47) 
  
 ;A vector containing the primes below 50
  
 Note that when the function
  read
  parses this syntax, it always constructs a
  
 simple
  general vector.",NA
2.5.2 Strings,"base-string
  ≡
  (vector base-char) 
  
 simple-base-string
  ≡
  (simple-array base-char (*))
  
 An implementation may support other string subtypes as well. All Com-
 mon Lisp functions that operate on strings treat all strings uniformly; note, 
 however, that it is an error to attempt to insert an extended character into a 
 base string.
  
 The type
  string
  is therefore a subtype of the type
  vector
 .
  
 A string can be written as the sequence of characters contained in the 
 string, preceded and followed by a
  ""
  (double quote) character. Any
  ""
  or
  \ 
 character in the sequence must additionally have a
  \
  character before it.
  
 For example:
  
 ""Foo"" 
  
 ;A string with three characters in it """" 
 ;An empty string 
  
 ""\""APL\\360?\"" he cried."" 
  
 ;A string with twenty characters 
 ""|x| = |-x|"" 
  
  
 ;A ten-character string",NA
2.5.3 Bit-Vectors,"A bit-vector can be written as the sequence of bits contained in the string, 
 preceded by
  #*
 ; any delimiter character, such as whitespace, will terminate 
 the bit-vector syntax. For example:
  
 #*10110 
 #*
  
  
 ;A five-bit bit-vector; bit 0 is a 1 
 ;An empty bit-vector
  
 The bits notated following the
  #*
 , taken from left to right, occupy loca-
 tions within the bit-vector with increasing indices. The leftmost notated bit 
 is bit-vector element number 0, the next one is element number 1, and so 
 on.
  
 The function
  prin1
  will print any bit-vector (not just a simple one) using 
 this syntax, but the function
  read
  will always construct a simple bit-vector 
 when it reads this syntax.",NA
2.6 ,NA,NA
Hash Tables,"Hash tables provide an efficient way of mapping any Lisp object (a
  key
 ) to 
 an associated object. They are provided as primitives of Common Lisp 
 because some implementations may need to use internal storage 
 management strategies that would make it very difficult for the user to 
 implement hash tables in a portable fashion. Hash tables are described in 
 chapter 16.",NA
Readtables,CHAPTER 2. DATA TYPES,NA
2.7,"A readtable is a data structure that maps characters into syntax types for 
 the Lisp expression parser. In particular, a readtable indicates for each 
 char-acter with syntax
  macro character
  what its macro definition is. This is 
 a mechanism by which the user may reprogram the parser to a limited but 
 useful extent. See section 22.1.5.",NA
2.8 Packages,"Packages are collections of symbols that serve as name spaces. The parser 
 recognizes symbols by looking up character sequences in the current 
 package. Packages can be used to hide names internal to a module from 
 other code. Mechanisms are provided for exporting symbols from a given 
 package to the primary “user” package. See chapter 11.",NA
2.9 Pathnames,"Pathnames are the means by which a Common Lisp program can interface 
 to an external file system in a reasonably implementation-independent 
 manner. See section 23.1.1.",NA
2.10 Streams,"A stream is a source or sink of data, typically characters or bytes. Nearly all 
 functions that perform I/O do so with respect to a specified stream. The 
 function
  open
  takes a pathname and returns a stream connected to the file 
 specified by the pathname. There are a number of standard streams that are 
 used by default for various purposes. See chapter 21.
  
  
 There 
  
 are subtypes 
   
 of type 
 stream
 : 
 broadcast-stream
 , 
 concatenated-stream
 , 
  
  
  
 echo-stream
 , 
  
 synonym-stream
 , 
 string-stream
 , 
 file-stream
 , and
  
 two-way-stream
  are disjoint subtypes of 
 stream
 . Note particularly that a 
 synonym stream is always and only of type
  synonym-stream
 , regardless of 
 the type of the stream for which it is a synonym.",NA
2.11 Random-States,"An object of type
  random-state
  is used to encapsulate state information 
 used by the pseudo-random number generator. For more information about 
 random-state
  objects, see section 12.9.",NA
2.12 Structures,"Structures are instances of user-defined data types that have a fixed 
 number of named components. They are analogous to records in Pascal. 
 Structures are declared using the
  defstruct
  construct;
  defstruct
  
 automatically defines access and constructor functions for the new data 
 type.
  
 Different structures may print out in different ways; the definition of a 
 structure type may specify a print procedure to use for objects of that type 
 (see the
  :print-function
  option to
  defstruct
 ). The default notation for 
 structures is
  
 #S(
 structure-name 
  
 slot-name-1 slot-value-1 
  
 slot-name-2 slot-value-2 
  
  
  
 ...)
  
 where
  #S
  indicates structure syntax,
  structure-name
  is the name (a sym-
 bol) of the structure type, each
  slot-name
  is the name (also a symbol) of a 
 component, and each corresponding
  slot-value
  is the representation of the 
 Lisp object in that slot.",NA
2.13 Functions,"The type
  function
  is to be disjoint from
  cons
  and
  symbol
 , and so a list 
 whose
  car
  is
  lambda
  is not, properly speaking, of type
  function
 , nor is any 
 symbol. However, standard Common Lisp functions that accept func-tional 
 arguments will accept a symbol or a list whose
  car
  is
  lambda
  and 
 automatically coerce it to be a function; such standard functions include 
 funcall
 ,
  apply
 , and
  mapcar
 . Such functions do not, however, accept a 
 lambda-expression as a functional argument; therefore one may not write
  
 (mapcar ’(lambda (x y) (sqrt (* x y))) p q)",NA
2.14 Unreadable Data Objects,"Some objects may print in implementation-dependent ways. Such objects 
 cannot necessarily be reliably reconstructed from a printed representation, 
 and so they are usually printed in a format informative to the user but not 
 acceptable to the
  read
  function:
  #<
 useful information
 >
 . 
  
 The Lisp 
 reader will signal an error on encountering
  #<
 .
  
 As a hypothetical example, an implementation might print
  
 #<stack-pointer si:rename-within-new-definition-maybe #o311037552>
  
 for an implementation-specific “internal stack pointer” data type whose 
 printed representation includes the name of the type, some information 
 about the stack slot pointed to, and the machine address (in octal) of the 
 stack slot.
  
  
 See
  print-unreadable-object
 , a macro that prints an object using
  #< 
 syntax.",NA
"2.15 Overlap, Inclusion, and Disjointness of",NA,NA
Types,"The Common Lisp data type hierarchy is tangled and purposely left some-
 what open-ended so that implementors may experiment with new data 
 types as extensions to the language. This section explicitly states all the 
 defined 
 relationships 
 between 
 types, including 
 subtype/supertype 
 relationships, dis-jointness, and exhaustive partitioning. The user of 
 Common Lisp should not depend on any relationships not explicitly stated 
 here. For example, it is not valid to assume that because a number is not 
 complex and not rational that it must be a
  float
 , because implementations 
 are permitted to provide yet other kinds of numbers.",NA
Chapter 3,NA,NA
Scope and Extent,"In describing various features of the Common Lisp language, the notions of 
 scope
  and
  extent
  are frequently useful. These notion arise when some object 
 or construct must be referred to from some distant part of a program.
  Scope 
 refers to the spatial or textual region of the program within which 
 references may occur.
  Extent
  refers to the interval of time during which 
 references may occur.
  
 As a simple example, consider this program:
  
 (defun copy-cell (x) (cons (car x) (cdr x)))
  
 The scope of the parameter named
  x
  is the body of the
  defun
  form. There is 
 no way to refer to this parameter from any other place but within the body 
 of the
  defun
 . Similarly, the extent of the parameter
  x
  (for any particular call 
 to
  copy-cell
 ) is the interval from the time the function is invoked to the time 
 it is exited. (In the general case, the extent of a parameter may last beyond 
 the time of function exit, but that cannot occur in this simple case.) Within 
 Common Lisp, a referenceable entity is
  established
  by the exe-cution of some 
 language construct, and the scope and extent of the entity are described 
 relative to the construct and the time (during execution of the construct) at 
 which the entity is established. For the purposes of this discussion, the term 
 “entity” refers not only to Common Lisp data objects, such as symbols and 
 conses, but also to variable bindings (both ordinary and special), catchers, 
 and
  go
  targets. It is important to distinguish between an entity and a name 
 for the entity. In a function definition such as
  
 (defun foo (x y) (* x (+ y 1)))
  
 43",NA
Chapter 4,NA,NA
Type Specifiers,"In Common Lisp, types are named by Lisp objects, specifically symbols and 
 lists, called
  type specifiers
 . Symbols name predefined classes of objects, 
 whereas lists usually indicate combinations or specializations of simpler 
 types. Symbols or lists may also be abbreviations for types that could be 
 specified in other ways.",NA
4.1 ,NA,NA
Type Specifier Symbols,"The type symbols defined by the system include those shown in table 4.1. In 
 addition, when a structure type is defined using
  defstruct
 , the name of the 
 structure type becomes a valid type symbol.",NA
4.2 ,NA,NA
Type Specifier Lists,"If a type specifier is a list, the
  car
  of the list is a symbol, and the rest of the 
 list is subsidiary type information. In many cases a subsidiary item may be 
 unspecified
 . The unspecified subsidiary item is indicated by writing
  *
 . For 
 example, to completely specify a vector type, one must mention the type of 
 the elements and the length of the vector, as for example
  
 (vector double-float 100)
  
 To leave the length unspecified, one would write
  
 (vector double-float *)
  
 51",NA
4.3 Predicating Type Specifiers,"A type specifier list
  (satisfies
  predicate-name
 )
  denotes the set of all ob-
 jects that satisfy the predicate named by
  predicate-name
 , which must be",NA
4.4 ,NA,NA
Type Specifiers That Combine,"The following type specifier lists define a type in terms of other types or 
 objects.
  
 (member
  object1 object2
  ...)
  This denotes the set containing precisely 
 those objects named. An object is of this type if and only if it is
  eql 
 to 
 one of the specified objects.
  
 (eql
  object
 )
  It may be used as a parameter specializer for CLOS methods 
 (see section 28.1.6 and
  find-method
 ). It denotes the set of the one 
 object named; an object is of this type if and only if it is
  eql
  to
  object
 . 
 While
  (eql
  object
 )
  denotes the same type as
  (member
  object
 )
 , only 
 (eql
  object
 )
  may be used as a CLOS parameter specializer.
  
 (not
  type
 )
  This denotes the set of all those objects that are
  not
  of the 
 specified type.
  
 (and
  type1 type2
  ...)
  This denotes the intersection of the specified types.
  
 When
  typep
  processes an
  and
  type specifier, it always tests each of 
 the component types in order from left to right and stops processing 
 as soon as one component of the intersection has been found to which 
 the object in question does not belong. In this respect an
  and
  type 
 specifier is similar to an executable
  and
  form. The purpose of this 
 similarity is to allow a
  satisfies
  type specifier to depend on filtering 
 by previous type specifiers. For example, suppose there were a 
 function
  primep 
 that takes an integer and says whether it is prime. 
 Suppose also that it is an error to give any object other than an integer 
 to
  primep
 . Then the type specifier",NA
4.5 Type Specifiers That Specialize,"Some type specifier lists denote
  specializations
  of data types named by sym-
 bols. These specializations may be reflected by more efficient 
 representations in the underlying implementation. As an example, consider 
 the type
  (array short-float)
 . Implementation A may choose to provide a 
 specialized repre-sentation for arrays of short floating-point numbers, and 
 implementation B may choose not to.
  
 If you should want to create an array for the express purpose of hold-ing 
 only short-float objects, you may optionally specify to
  make-array
  the 
 element type
  short-float
 . This does not
  require
  make-array
  to create an 
 object of type
  (array short-float)
 ; it merely
  permits
  it. The request is con-
 strued to mean “Produce the most specialized array representation capable 
 of 
 holding 
 short-floats 
 that 
 the 
 implementation 
 can 
 provide.” 
 Implementation A will then produce a specialized array of type
  (array 
 short-float)
 , and implementation B will produce an ordinary array of type
  
 (array t)
 .
  
 If one were then to ask whether the array were actually of type
  (ar-ray 
 short-float)
 , implementation A would say “yes,” but implementation B 
 would say “no.” This is a property of
  make-array
  and similar functions: 
 what you ask for is not necessarily what you get.
  
 X3J13 voted in January 1989 to eliminate the differing treatment of types 
 when used “for discrimination” rather than “for declaration” on the grounds",NA
4.6 Type Specifiers That Abbreviate,"The following type specifiers are, for the most part, abbreviations for other 
 type specifiers that would be far too verbose to write out explicitly (using, 
 for example,
  member
 ).
  
 (integer
  low high
 )
  Denotes the integers between
  low
  and
  high
 . The limits 
 low
  and
  high
  must each be an integer, a list of an integer, or 
 unspecified. An integer is an inclusive limit, a list of an integer is an 
 exclusive limit, and
  *
  means that a limit does not exist and so 
 effectively denotes minus or plus infinity, respectively. The type
  
 fixnum
  is simply a name for 
 (integer
  smallest largest
 )
  for 
 implementation-dependent values of 
 smallest
  and
  largest
  (see
  most-
 negative-fixnum
  and
  most-positive-fixnum
 ). The type
  (integer 0 
 1)
  is so useful that it has the special name
  bit
 .
  
 (mod
  n
 )
  Denotes the set of non-negative integers less than
  n
 . This is equiv-
 alent to
  (integer 0
  n −
  1
 )
  or to
  (integer 0 (
 n
 ))
 .
  
 (signed-byte
  s
 )
  Denotes the set of integers that can be represented in 
 two’s-complement form in a byte of
  s
  bits. This is equivalent to
  (inte-
 ger
  −
 2
 s−
 1
 2
 s−
 1
 −
  1
 )
 . Simply
  signed-byte
  or
  (signed-byte *)
  is the same 
 as
  integer
 .
  
 (unsigned-byte
  s
 )
  Denotes the set of non-negative integers that can be 
 represented in a byte of
  s
  bits. This is equivalent to
  (mod
  2
 s
 )
 , that is, 
 (integer 0
  2
 s
 −
  1
 )
 . Simply
  unsigned-byte
  or
  (unsigned-byte *)
  is the 
 same as
  (integer 0 *)
 , the set of non-negative integers.
  
 (rational
  low high
 )
  Denotes the rationals between
  low
  and
  high
 . The lim-
 its
  low
  and
  high
  must each be a rational, a list of a rational, or unspec-
 ified. A rational is an inclusive limit, a list of a rational is an exclusive 
 limit, and
  *
  means that a limit does not exist and so effectively denotes 
 minus or plus infinity, respectively.
  
 (float
  low high
 )
  Denotes the set of floating-point numbers between
  low 
 and
  high
 . The limits
  low
  and
  high
  must each be a floating-point num-
 ber, a list of a floating-point number, or unspecified; a floating-point",NA
4.7 ,NA,NA
Defining New Type Specifiers,"New type specifiers can come into existence in two ways. First, defining a 
 new structure type with
  defstruct
  automatically causes the name of the 
 structure to be a new type specifier symbol. Second, the
  deftype
  special 
 operator can be used to define new type-specifier abbreviations.
  
 [Macro]
  deftype
  name lambda-list [[{declaration}* | doc-string]] {form}*
  
 This is very similar to a
  defmacro
  form:
  name
  is the symbol that iden-
 tifies the type specifier being defined,
  lambda-list
  is a lambda-list (and may",NA
4.8 ,NA,NA
Type Conversion Function,"The following function may be used to convert an object to an equivalent 
 object of another type.
  
 [Function]
  coerce
  object result-type
  
 The
  result-type
  must be a type specifier; the
  object
  is converted to 
 an“equivalent” object of the specified type. If the coercion cannot be 
 performed, then an error is signaled. In particular,
  (coerce x ’nil)
  always 
 signals an error. If
  object
  is already of the specified type, as determined by
  
 typep
 , then it is simply returned. It is not generally possible to convert any 
 object to be of any type whatsoever; only certain conversions are 
 permitted:
  
 •
  Any sequence type may be converted to any other sequence type, pro-
 vided the new sequence can contain all actual elements of the old se-
 quence (it is an error if it cannot). If the
  result-type
  is specified as simply
  
 array
 , for example, then
  (array t)
  is assumed. 
  
 A special-
 ized type such as
  string
  or
  (vector (complex short-float))
  may be 
 specified; of course, the result may be of either that type or some more 
 general type, as determined by the implementation. Elements",NA
4.9 ,NA,NA
Determining the Type of an Object,"The following function may be used to obtain a type specifier describing the
  
 type of a given object.
  
 [Function]
  type-of
  object
  
 There are the following constraints on
  type-of
 :
  
 •
  Let
  x
  be an object such that
  (typep
  x type
 )
  is true and
  type
  is one of the following:
  
 array 
  
 float 
  
 package 
  
 sequence
  
 bit-vector 
  
 function 
  
 pathname 
  
 short-float
  
 character 
  
 hash-table 
  
 random-state 
  
 single-float
  
 complex 
  
 integer 
  
 ratio 
  
 stream
  
 condition 
  
 long-float 
  
 rational 
  
 string
  
 cons 
  
 null 
  
 readtable 
  
 symbol
  
 double-float 
  
 number 
  
 restart 
  
 vector
  
 Then
  (subtypep (type-of
  x
 )
  type
 ))
  must return the values
  t
  and
  t
 ;
  
 that is,
  type-of
  applied to
  x
  must return either
  type
  itself or a subtype
  
 of
  type
  that
  subtypep
  can recognize in that implementation.",NA
4.10 Type Upgrading,"There are functions by which a program can determine, in a given Common 
 Lisp implementation, how that implementation will
  upgrade
  a type when 
 con-structing an array specialized to contain elements of that type, or a 
 complex number specialized to contain parts of that type.",NA
Chapter 5,NA,NA
Program Structure,"In chapter 2 the syntax was sketched for notating data objects in Common 
 Lisp. The same syntax is used for notating programs because all Common 
 Lisp programs have a representation as Common Lisp data objects.
  
 Lisp programs are organized as forms and functions. Forms are
  
 evaluated 
 (relative to some context) to produce values and side effects. 
 Functions are invoked by
  applying
  them to arguments. The most important 
 kind of form performs a function call; conversely, a function performs 
 computation by evaluating forms.
  
 In this chapter, forms are discussed first and then functions. 
  
 Finally, 
 certain “top level” special operators are discussed; the most important of 
 these is
  defun
 , whose purpose is to define a named function.",NA
5.1 ,NA,NA
Forms,"The standard unit of interaction with a Common Lisp implementation is the 
 form
 , which is simply a data object meant to be
  evaluated
  as a program to 
 produce one or more
  values
  (which are also data objects). One may request 
 evaluation of
  any
  data object, but only certain ones are meaningful. For 
 instance, symbols and lists are meaningful forms, while arrays normally are 
 not. Examples of meaningful forms are
  3
 , whose value is
  3
 , and
  (+ 3 4)
 , 
 whose value is
  7
 . We write
  3
  ⟨
  3
  and
  (+ 3 4)
  ⟨
  7
  to indicate these facts.
  
 Meaningful forms may be divided into three categories: self-evaluating (
 ⟨
  
 means “evaluates to.”) 
  
 forms, such as numbers; symbols, which stand for variables; and lists. The
  
 71",NA
5.1.1 Self-Evaluating Forms,"All numbers, characters, strings, and bit-vectors are
  self-evaluating
  forms. 
 When such an object is evaluated, that object (or possibly a copy in the case 
 of numbers or characters) is returned as the value of the form. The empty 
 list (), which is also the false value
  nil
 , is also a self-evaluating form: the 
 value of
  nil
  is
  nil
 . Keywords (symbols written with a leading colon) also 
 evaluate to themselves: the value of
  :start
  is
  :start
 .
  
 It is an error to destructively modify any object that appears as a 
 constant in executable code, whether as a self-evaluating form or within a
  
 quote 
 special operator.",NA
5.1.2 Variables,"Symbols are used as names of variables in Common Lisp programs. When a 
 symbol is evaluated as a form, the value of the variable it names is 
 produced. For example, after doing
  (setq items 3)
 , which assigns the value
  
 3
  to the variable named
  items
 , then
  items
  ⟨
  3
 . Variables can be
  assigned
  to, 
 as by
  setq
 , or
  bound
 , as by
  let
 . Any program construct that binds a variable 
 effectively saves the old value of the variable and causes it to have a new 
 value, and on exit from the construct the old value is reinstated.
  
 There are actually two kinds of variables in Common Lisp, called
  lexical 
 (or
  static
 ) variables and
  special
  (or
  dynamic
 ) variables. At any given time 
 either or both kinds of variable with the same name may have a current 
 value. Which of the two kinds of variable is referred to when a symbol is 
 evaluated depends on the context of the evaluation. The general rule is that 
 if the symbol occurs textually within a program construct that creates a
  
 binding 
 for a variable of the same name, then the reference is to the variable 
 specified by the binding; if no such program construct textually contains the 
 reference, then it is taken to refer to the special variable of that name.
  
 The distinction between the two kinds of variable is one of scope and ex-
 tent. A lexically bound variable can be referred to
  only
  by forms occurring at",NA
5.1.3 Special Operators,"If a list is to be evaluated as a form, the first step is to examine the first 
 element of the list. If the first element is one of the symbols appearing in 
 table 5.1, then the list is called a
  special operator
 . (This use of the 
 word“special” is unrelated to its use in the phrase “special variable.”)
  
 Special operators are generally environment and control constructs. Ev-
 ery special operator has its own idiosyncratic syntax. An example is the
  if 
 special operator:
  (if p (+ x 4) 5)
  in Common Lisp means what “
 if
  p
  then 
 x
 +4
  
 else
  5” means in Algol.
  
 The evaluation of a special operator normally produces a value or 
 values, but the evaluation may instead call for a non-local exit; see
  return-
 from
 , 
 go
 , and
  throw
 .
  
 The set of special operators is fixed in Common Lisp; no way is provided 
 for the user to define more. The user can create new syntactic constructs, 
 however, by defining macros.",NA
Macros,CHAPTER 5. PROGRAM STRUCTURE,NA
5.1.4,"If a form is a list and the first element is not the name of a special form, it 
 may be the name of a
  macro
 ; if so, the form is said to be a
  macro call
 . A 
 macro is essentially a function from forms to forms that will, given a call to 
 that macro, compute a new form to be evaluated in place of the macro call. 
 (This computation is sometimes referred to as
  macro expansion
 .) For 
 example, the macro named
  return
  will take a form such as
  (return x)
  and 
 from that form compute a new form
  (return-from nil x)
 . We say that the 
 old form
  expands
  into the new form. The new form is then evaluated in 
 place of the original form; the value of the new form is returned as the value 
 of the original form.
  
 Macro calls, and subforms of macro calls, need not be proper lists, but 
 that use of dotted forms requires the macro definition to use “
 .
  var
 ” 
 or“
 &rest
  var
 ” in order to match them properly. It is then the responsibility 
 of the macro definition to recognize and appropriately handle such dotted 
 forms or subforms.
  
  
 There are a number of standard macros in Common Lisp, and the user 
 can define more by using
  defmacro
 .
  
 Macros provided by a Common Lisp implementation as described herein 
 may 
 expand 
 into 
 code 
 that 
 is 
 not 
 portable 
 among 
 differing 
 implementations. That is, a macro call may be implementation-independent 
 because the macro is defined in this book, but the expansion need not be.
  
 Implementation note:
  Implementors are encouraged to implement the macros 
 defined in this book, as far as is possible, in such a way that the expansion will 
 not contain any implementation-dependent special operators, nor contain as forms 
 data objects that are not considered to be forms in Common Lisp. The purpose 
 of this restriction is to ensure that the expansion can be processed by a program- 
 analyzing program in an implementation-independent manner. There is no problem 
 with a macro expansion containing calls to implementation-dependent functions. 
 This restriction is not a requirement of Common Lisp; it is recognized that certain 
 complex macros may be able to expand into significantly more efficient code in 
 certain implementations by using implementation-dependent special operators in 
 the macro expansion.",NA
5.1.5 Function Calls,"If a list is to be evaluated as a form and the first element is not a symbol that 
 names a special operator or macro, then the list is assumed to be a 
 function 
 call
 . The first element of the list is taken to name a function. Any and all 
 remaining elements of the list are forms to be evaluated; one value is 
 obtained from each form, and these values become the
  arguments
  to the 
 function. The function is then
  applied
  to the arguments. The functional 
 computation normally produces a value, but it may instead call for a non-
 local exit; see
  throw
 . A function that does return may produce no value or 
 several values; see
  values
 . If and when the function returns, whatever 
 values it returns become the values of the function-call form.
  
 For example, consider the evaluation of the form
  (+ 3 (* 4 5))
 . The symbol
  +
  
 names the addition function, not a special operator or macro. Therefore the 
 two forms
  3
  and
  (* 4 5)
  are evaluated to produce arguments. The form
  3
  
 evaluates to
  3
 , and the form
  (* 4 5)
  is a function call (to the multiplication 
 function). 
  
 Therefore the forms
  4
  and
  5
  are evaluated, 
 producing arguments
  4
  and
  5
  for the multiplication. 
  
 The multiplication 
 function calculates the number
  20
  and returns it. 
  
 The values
  3
  and
  20 
 are then given as arguments to the addition function, which calculates and 
 returns the number
  23
 . Therefore we say
  (+ 3 (* 4 5))
  ⟨
  23
 .
  
 While the arguments in a function call are always evaluated in strict left-
 to-right order, whether the function to be called is determined before or 
 after argument evaluation is unspecified. Programs are in error that rely on 
 a particular order of evaluation of the first element of a function call relative 
 to the argument forms.",NA
5.2 ,NA,NA
Functions,"There are two ways to indicate a function to be used in a function-call form. 
 One is to use a symbol that names the function. This use of symbols to name 
 functions is completely independent of their use in naming special and 
 lexical variables. The other way is to use a
  lambda-expression
 , which is a list 
 whose first element is the symbol
  lambda
 . A lambda-expression is
  not
  a 
 form; it cannot be meaningfully evaluated. Lambda-expressions and 
 symbols, when used in programs as names of functions, can appear only as 
 the first element of a function-call form, or as the second element of the
  
 function
  special",NA
5.2.1 Named Functions,"A name can be given to a function in one of two ways. A
  global name
  can be 
 given to a function by using the
  defun
  construct. A
  local name
  can be given 
 to a function by using the
  flet
  or
  labels
  special operator. When a function is 
 named, a lambda-expression is effectively associated with that name along 
 with information about the entities that are lexically apparent at that point. 
 If a symbol appears as the first element of a function-call form, then it refers 
 to the definition established by the innermost
  flet
  or
  labels
  construct that 
 textually contains the reference, or to the global definition (if any) if there is 
 no such containing construct.",NA
5.2.2 Lambda-Expressions,"A
  lambda-expression
  is a list with the following syntax:
  
 (lambda
  lambda-list
  .
  body
 )
  
 The first element must be the symbol
  lambda
 . The second element must 
 be a list. It is called the
  lambda-list
 , and specifies names for the
  parameters
  
 of the function. When the function denoted by the lambda-expression is 
 applied to arguments, the arguments are matched with the parameters 
 specified by the lambda-list. The
  body
  may then refer to the arguments by 
 using the parameter names. The
  body
  consists of any number of forms 
 (possibly zero). These forms are evaluated in sequence, and the results of 
 the
  last
  form only are returned as the results of the application (the value
  
 nil
  is returned if there are zero forms in the body). The complete syntax of a 
 lambda-expression is:
  
 (lambda ( {var}* 
  
 [
 &optional
  {
 var
  |
  (
  var
  [
  initform
  [
  svar
 ] ]
  )
 }*
  ] 
  
 [
 &rest
  var] 
  
 [
 &key
  {
 var
  |
  (
  {
 var
  |
  (
  keyword var
 )
 } [
  initform
  [
  svar
 ] ]
  )
 }* 
 [
 &aux
  {
 var
  |
  (
  var
  [
  initform
 ]
  )
 }*
  ] )
  
 [
 &allow-oth",NA
5.3 Top-Level Forms,"The standard way for the user to interact with a Common Lisp implemen-
 tation is via a
  read-eval-print loop
 : the system repeatedly reads a form from 
 some input source (such as a keyboard or a disk file), evaluates it, and then 
 prints the value(s) to some output sink (such as a display screen or another 
 disk file). Any form (evaluable data object) is acceptable; however, certain 
 special operators are specifically designed to be convenient for use as
  top-
 level 
 forms, rather than as forms embedded within other forms in the way 
 that
  (+ 3 4)
  is embedded within
  (if p (+ 3 4) 6)
 . These top-level special 
 operators may be used to define globally named functions, to define 
 macros, to make declarations, and to define global values for special 
 variables.
  
 While defining forms normally appear at top level, it is meaningful to 
 place them in non-top-level contexts. All defining forms that create func-
 tional objects from code appearing as argument forms must ensure that 
 such",NA
5.3.1 Defining Named Functions,"The
  defun
  special operator is the usual means of defining named functions.
  
 [Macro]
  defun
  name lambda-list [[{declaration}* | doc-string]] {form}*
  
 Evaluating a
  defun
  form causes the symbol
  name
  to be a global name for the 
 function specified by the lambda-expression
  
 (lambda
  lambda-list
  {declaration
  |
  doc-string}* {form}* )
  
 defined in the lexical environment in which the
  defun
  form was 
 executed. Because
  defun
  forms normally appear at top level, this is 
 normally the null lexical environment.
  
 While defining forms normally appear at top level, it is meaningful to 
 place them in non-top-level contexts;
  defun
  must define the function within 
 the enclosing lexical environment, not within the null lexical environment.
  
 defun
  can accept any function-name (a symbol or a list whose
  car
  is 
 setf
 —
 see section 7.1) as a
  name
 . Thus one may write
  
 (defun (setf cadr) ...)
  
 to define a
  setf
  expansion function for
  cadr
  (although it may be much more 
 convenient to use
  defsetf
  or
  define-modify-macro
 ).
  
 If the optional documentation string
  doc-string
  is present, then it is at-
 tached to the
  name
  as a documentation string of type
  function
 ; see
  docu-
 mentation
 . If
  doc-string
  is not followed by a declaration, it may be present 
 only if at least one
  form
  is also specified, as it is otherwise taken to be a 
 form
 . It is an error if more than one
  doc-string
  is present.
  
 The
  forms
  constitute the body of the defined function; they are executed as 
 an implicit
  progn
 .
  
 The body of the defined function is implicitly enclosed in a
  block
  con-struct 
 whose name is the same as the
  name
  of the function. 
  
 Therefore 
 return-from
  may be used to exit from the function.",NA
5.3.2 Declaring Global Variables and Named Constants,"The
  defvar
  and
  defparameter
  special operators are the usual means of 
 specifying globally defined variables. The
  defconstant
  special operator is 
 used for defining named constants.
  
 [Macro]
  defvar
  name [initial-value [documentation]]
  
 [Macro]
  defparameter
  name initial-value [documentation]
  
 [Macro]
  defconstant
  name initial-value [documentation]
  
  
 defvar
  is the recommended way to declare the use of a special variable 
 in a program.
  
 (defvar
  variable
 )
  
  
 proclaims
  variable
  to be
  special
  (see
  proclaim
 ), and may perform other 
 system-dependent bookkeeping actions.
  
 If no
  initial-value
  form is provided,
  defvar
  does not change the value of 
 the
  variable
 ; if no
  initial-value
  form is provided and the variable has no 
 value,
  defvar
  does not give it a value.
  
 If a second argument form is supplied,",NA
5.3.3 Control of Time of Evaluation,"[Special operator]
  eval-when
  ({situation}*) {form}*
  
 The body of an
  eval-when
  form is processed as an implicit
  progn
 , but 
 only in the situations listed. Each
  situation
  must be a symbol, either 
 :compile-toplevel
 ,
  :load-toplevel
 , or
  :execute
 .
  
 The use of
  :compile-toplevel
  and
  :load-toplevel
  controls whether and 
 when processing occurs for top-level forms. The use of
  :execute
  controls 
 whether processing occurs for non-top-level forms.
  
 The
  eval-when
  construct may be more precisely understood in terms of 
 a model of how the file compiler,
  compile-file
 , processes forms in a file to 
 be compiled.
  
 Successive forms are read from the file by the file compiler using
  read
 . 
 These top-level forms are normally processed in what we call “not-compile-
 time” mode. There is one other mode, called “compile-time-too” mode, 
 which can come into play for top-level forms. The
  eval-when
  special 
 operator is used to annotate a program in a way that allows the program 
 doing the processing to select the appropriate mode.
  
 Processing of top-level forms in the file compiler works as follows:
  
 •
  If the form is a macro call, it is expanded and the result is processed as a 
 top-level form in the same processing mode (compile-time-too or not-
 compile-time).
  
 •
  If the form is a
  progn
  (or
  locally
  ) form, each of its body forms is sequentially 
 processed as top-level forms in the same processing mode.
  
 •
  If the form is a
  compiler-let
 ,
  macrolet
 , or
  symbol-macrolet
 , the file 
 compiler makes the appropriate bindings and recursively processes 
 the body forms as an implicit top-level
  progn
  with those bindings in 
 effect, in the same processing mode.
  
 •
  If the form is an
  eval-when
  form, it is handled according to the fol-lowing table:",NA
Chapter 6,NA,NA
Predicates,"A
  predicate
  is a function that tests for some condition involving its 
 arguments and returns
  nil
  if the condition is false, or some non-
 nil
  value if 
 the condition is true. One may think of a predicate as producing a Boolean 
 value, where 
 nil
  stands for
  false
  and anything else stands for
  true
 . 
 Conditional control structures such as
  cond
 ,
  if
 ,
  when
 , and
  unless
  test such 
 Boolean values. We say that a predicate
  is true
  when it returns a non-
 nil
  
 value, and
  is false
  when it returns
  nil
 ; that is, it is true or false according to 
 whether the condition being tested is true or false.
  
 By convention, the names of predicates usually end in the letter
  p
  
 (which stands for “predicate”). Common Lisp uses a uniform convention in 
 hyphen-ating names of predicates. If the name of the predicate is formed by 
 adding a
  p
  to an existing name, such as the name of a data type, a hyphen is 
 placed before the final
  p
  if and only if there is a hyphen in the existing 
 name. For example,
  number
  begets
  numberp
  but
  standard-char
  begets
  
 standard-char-p
 . On the other hand, if the name of a predicate is formed 
 by adding a prefixing qualifier to the front of an existing predicate name, 
 the two names are joined with a hyphen and the presence or absence of a 
 hyphen before the final
  p
  is not changed. For example, the predicate
  string-
 lessp
  has no hyphen before the
  p
  because it is the string version of
  lessp
  (a 
 MacLisp func-tion that has been renamed
  <
  in Common Lisp). The name
  
 string-less-p 
 would incorrectly imply that it is a predicate that tests for a 
 kind of object called a
  string-less
 , and the name
  stringlessp
  would connote 
 a predicate that tests whether something has no strings (is “stringless”)!
  
 The control structures that test Boolean values only test for whether or not 
 the value is
  nil
 , which is considered to be false. 
  
 Any other value is
  
 97",NA
6.1 Logical Values,"The names
  nil
  and
  t
  are constants in Common Lisp. Although they are 
 symbols like any other symbols, and appear to be treated as variables when 
 evaluated, it is not permitted to modify their values. See
  defconstant
 .
  
 [Constant]
  nil
  
  
 The value of
  nil
  is always
  nil
 . This object represents the logical
  false 
 value and also the empty list. It can also be written
  ()
 .
  
 [Constant]
  t
  
 The value of
  t
  is always
  t
 .",NA
6.2 Data Type Predicates,"Perhaps the most important predicates in Lisp are those that deal with data 
 types; that is, given a data object one can determine whether or not it 
 belongs to a given type, or one can compare two type specifiers.",NA
6.2.1 General Type Predicates,"If a data type is viewed as the set of all objects belonging to the type, then 
 the
  typep
  function is a set membership test, while
  subtypep
  is a subset 
 test.
  
 [Function]
  typep
  object type
  
 typep
  is a predicate that is true if
  object
  is of type
  type
 , and is false 
 otherwise. Note that an object can be “of” more than one type, since one 
 type can include another. The
  type
  may be any of the type specifiers 
 mentioned",NA
6.2.2 Specific Data Type Predicates,The following predicates test for individual data types.,NA
Equality Predicates,CHAPTER 6. PREDICATES,NA
6.3,"Common Lisp provides a spectrum of predicates for testing for equality of 
 two objects:
  eq
  (the most specific),
  eql
 ,
  equal
 , and
  equalp
  (the most 
 general). 
 eq
  and
  equal
  have the meanings traditional in Lisp.
  eql
  was 
 added because it is frequently needed, and
  equalp
  was added primarily in 
 order to have a version of
  equal
  that would ignore type differences when 
 comparing numbers and case differences when comparing characters. If 
 two objects satisfy any one of these equality predicates, then they also 
 satisfy all those that are more general.
  
 [Function]
  eq
  x y
  
  
 (eq
  x y
 )
  is true if and only if
  x
  and
  y
  are the same identical object. 
 (Implementationally,
  x
  and
  y
  are usually
  eq
  if and only if they address the 
 same identical memory location.) 
  
  
 It should be noted that things that print the same are not necessarily
  eq 
 to each other. Symbols with the same print name usually are
  eq
  to each 
 other because of the use of the
  intern
  function. However, numbers with the 
 same value need not be
  eq
 , and two similar lists are usually not
  eq
 . For 
 example:
  
 (eq ’a ’b) is false.
  
 (eq ’a ’a) is true.
  
 (eq 3 3) might be true or false, depending on the implementation. 
 (eq 3 3.0) is false.
  
 (eq 3.0 3.0) might be true or false, depending on the implementation.
  
 (eq #c(3 -4) #c(3 -4)) 
  
 might be true or false, depending on the implementation.
  
 (eq #c(3 -4.0) #c(3 -4)) is false.
  
 (eq (cons ’a ’b) (cons ’a ’c)) is false.
  
 (eq (cons ’a ’b) (cons ’a ’b)) is false.
  
 (eq ’(a . b) ’(a . b)) might be true or false.
  
 (progn (setq x (cons ’a ’b)) (eq x x)) is true.
  
 (progn (setq x ’(a . b)) (eq x x)) is true.
  
 (eq #\A #\A) might be true or false, depending on the implementation. 
 (eq ""Foo"" ""Foo"") might be true or false.
  
 (eq ""Foo"" (copy-seq ""Foo"")) is false.
  
 (eq ""FOO"" ""foo"") is false.",NA
6.4 ,NA,NA
Logical operators,"Common Lisp provides three operators on Boolean values:
  and
 ,
  or
 , and
  not
 . 
 Of these,
  and
  and
  or
  are also control structures because their arguments are 
 evaluated conditionally. 
  
 The function
  not
  necessarily examines its single 
 argument, and so is a simple function.
  
 [Function]
  not
  x
  
 not
  returns
  t
  if
  x
  is
  nil
 , and otherwise returns
  nil
 . It therefore inverts its 
 argument considered as a Boolean value.
  
 null
  is the same as
  not
 ; both functions are included for the sake of 
 clarity. As a matter of style, it is customary to use
  null
  to check whether 
 something is the empty list and to use
  not
  to invert the sense of a logical 
 value.
  
 [Macro]
  and
  {form}*
  
 (and
  form1 form2
  ... )
  evaluates each
  form
 , one at a time, from left to 
 right. If any
  form
  evaluates to
  nil
 , the value
  nil
  is immediately returned 
 without evaluating the remaining
  form
 s. If every
  form
  but the last evaluates 
 to a non-
 nil
  value,
  and
  returns whatever the last
  form
  returns. Therefore in 
 general
  and
  can be used both for logical operations, where
  nil
  stands for 
 false
  and non-
 nil
  values stand for
  true
 , and as a conditional expression. An 
 example follows.
  
 (if (and (>= n 0) 
  
  
 (< n (length a-simple-vector)) 
  
  
 (eq (elt a-simple-vector n) ’foo)) 
  
 (princ ""Foo!""))
  
 The above expression prints
  Foo!
  if element
  n
  of
  a-simple-vector
  is the 
 symbol
  foo
 , provided also that
  n
  is indeed a valid index for
  a-simple-
 vector
 . Because
  and
  guarantees left-to-right testing of its parts,
  elt
  is not 
 called if
  n
  is out of range.
  
 To put it another way, the
  and
  special operator does
  short-circuit
  
 Boolean evaluation, like the
  and then
  operator in Ada and what in some 
 Pascal-like languages is called
  cand
  (for “conditional and”); the Lisp
  and
  
 special operator is unlike the Pascal or Ada
  and
  operator, which always 
 evaluates both arguments.
  
 In the previous example writing",NA
Chapter 7,NA,NA
Control Structure,"Common Lisp provides a variety of special structures for organizing pro-
 grams. 
  
 Some have to do with flow of control (control structures), while 
 others control access to variables (environment structures). Some of these 
 features are implemented as special operators; others are implemented as 
 macros, which typically expand into complex program fragments expressed 
 in terms of special operators or other macros.
  
 Function application is the primary method for construction of Lisp pro-
 grams. Operations are written as the application of a function to its ar-
 guments. Usually, Lisp programs are written as a large collection of small 
 functions, each of which implements a simple operation. These functions 
 operate by calling one another, and so larger operations are defined in 
 terms of smaller ones. Lisp functions may call upon themselves recursively, 
 either directly or indirectly.
  
 Locally defined functions (
 flet
 ,
  labels
 ) and macros (
 macrolet
 ) are quite 
 versatile. The new symbol macro facility allows even more syntactic 
 flexibil-ity.
  
 While the Lisp language is more applicative in style than statement-
 oriented, it nevertheless provides many operations that produce side 
 effects and consequently requires constructs for controlling the sequencing 
 of side effects. The construct
  progn
 , which is roughly equivalent to an Algol
  
 begin
 -
 end
  block with all its semicolons, executes a number of forms 
 sequentially, discarding the values of all but the last. Many Lisp control 
 constructs include sequencing implicitly, in which case they are said to 
 provide an “implicit 
 progn
 .” Other sequencing constructs include
  prog1
  
 and
  prog2
 .
  
 For looping, Common Lisp provides the general iteration facility
  do
  as
  
 117",NA
7.1 Constants and Variables,"Because some Lisp data objects are used to represent programs, one cannot 
 always notate a constant data object in a program simply by writing the 
 notation for the object unadorned; it would be ambiguous whether a 
 constant object or a program fragment was intended. The
  quote
  special 
 operator resolves this ambiguity.
  
 There are two kinds of variables in Common Lisp, in effect: ordinary 
 variables and function names. There are some similarities between the two 
 kinds, and in a few cases there are similar functions for dealing with them, 
 for example
  boundp
  and
  fboundp
 . However, for the most part the two 
 kinds of variables are used for very different purposes: one to name defined 
 functions, macros, and special operators, and the other to name data 
 objects.
  
 X3J13 voted in March 1989 to introduce the concept of a
  function-name
 , 
 which may be either a symbol or a two-element list whose first element is 
 the symbol
  setf
  and whose second element is a symbol. The primary 
 purpose of this is to allow
  setf
  expander functions to be CLOS generic 
 functions with user-defined methods. Many places in Common Lisp that 
 used to require a symbol for a function name are changed to allow 2-lists as 
 well; for example, 
 defun
  is changed so that one may write
  (defun (setf foo) 
 ...)
 , and the 
 function
  special operator is changed to accept any function-
 name. See also 
 fdefinition
 .
  
 By convention, any function named
  (setf
  f
  )
  should return its first argu-
 ment as its only value, in order to preserve the specification that
  setf
  
 returns its
  newvalue
 . See
  setf
 .",NA
7.1.1 Reference,"The value of an ordinary variable may be obtained simply by writing the 
 name of the variable as a form to be executed. Whether this is treated as the 
 name of a special variable or a lexical variable is determined by the 
 presence or absence of an applicable
  special
  declaration; see chapter 9.
  
 The following functions and special operators allow reference to the values 
 of constants and variables in other ways.
  
 [Special operator]
  quote
  object
  
 (quote
  x
 )
  simply returns
  x
 . The
  object
  is not evaluated and may be any 
 Lisp object whatsoever. This construct allows any Lisp object to be written 
 as a constant value in a program. For example:
  
 (setq a 43) 
  
 (list a (cons a 3))
  ⟨
  (43 (43 . 3)) 
  
 (list (quote a) (quote (cons a 3))
  ⟨
  (a (cons a 3))
  
 Since
  quote
  forms are so frequently useful but somewhat cumbersome 
 to type, a standard abbreviation is defined for them: any form
  f
  preceded by 
 a single quote (
  ’
  ) character is assumed to have
  (quote )
  wrapped around it 
 to make
  (quote
  f
  )
 . For example:
  
 (setq x ’(the magic quote hack))
  
 is normally interpreted by
  read
  to mean
  
 (setq x (quote (the magic quote hack)))
  
 See section 22.1.3.
  
 It is an error to destructively modify any object that appears as a 
 constant in executable code, whether within a
  quote
  special operator or as 
 a self-evaluating form.
  
 See section 24.1 for a discussion of how quoted constants are treated by the 
 compiler.
  
 X3J13 voted in March 1989 to clarify that
  eval
  and
  compile
  are not per-
 mitted either to copy or to coalesce (“collapse”) constants (see
  eq
 ) 
 appearing in the code they process; the resulting program behavior must 
 refer to objects",NA
7.1.2 Assignment,"The following facilities allow the value of a variable (more specifically, the 
 value associated with the current binding of the variable) to be altered. Such",NA
7.2 Generalized Variables,"In Lisp, a variable can remember one piece of data, that is, one Lisp object. 
 The main operations on a variable are to recover that object and to alter the 
 variable to remember a new object; these operations are often called
  access 
 and
  update
  operations. The concept of variables named by symbols can be 
 generalized to any storage location that can remember one piece of data, no 
 matter how that location is named. Examples of such storage locations are 
 the
  car
  and
  cdr
  of a cons, elements of an array, and components of a 
 structure.
  
 For each kind of generalized variable, typically there are two functions 
 that implement the conceptual
  access
  and
  update
  operations. For a variable, 
 merely mentioning the name of the variable accesses it, while the
  setq
  
 special operator can be used to update it. The function
  car
  accesses the
  car
  
 of a cons, and the function
  rplaca
  updates it. The function
  symbol-value
  
 accesses the dynamic value of a variable named by a given symbol, and the 
 function 
 set
  updates it.
  
 Rather than thinking about two distinct functions that respectively 
 access and update a storage location somehow deduced from their 
 arguments, we can instead simply think of a call to the access function with 
 given arguments as a
  name
  for the storage location. Thus, just as
  x
  may be 
 considered a name for a storage location (a variable), so
  (car x)
  is a name 
 for the
  car
  of some cons (which is in turn named by
  x
 ). Now, rather than 
 having to remember two functions for each kind of generalized variable 
 (having to remember, for example, that
  rplaca
  corresponds to
  car
 ), we 
 adopt a uniform syntax for updating storage locations named in this way, 
 using the
  setf
  macro. This is analogous to the way we use the
  setq
  special 
 operator to convert the name",NA
7.3 ,NA,NA
Function Invocation,"The most primitive form for function invocation in Lisp of course has no 
 name; any list that has no other interpretation as a macro call or special 
 operator is taken to be a function call. Other constructs are provided for 
 less common but nevertheless frequently useful situations.
  
 [Function]
  apply
  function arg
  &rest
  more-args
  
 This applies
  function
  to a list of arguments. X3J13 voted in June 1988 to 
 allow the
  function
  to be only of type
  symbol
  or
  function
 ; a lambda-
 expression is no longer acceptable as a functional argument. One must use 
 the 
 function
  special operator or the abbreviation
  #’
  before a lambda-
 expression that appears as an explicit argument form. The arguments for the
  
 function 
 consist of the last argument to
  apply
  appended to the end of a list of 
 all the other arguments to
  apply
  but the
  function
  itself; it is as if all the 
 arguments to
  apply
  except the
  function
  were given to
  list*
  to create the 
 argument list.
  
 For example:
  
 (setq f ’+) (apply f ’(1 2))
  ⟨
  3 
  
 (setq f #’-) (apply f ’(1 2))
  ⟨
  -1 
  
 (apply #’max 3 5 ’(2 7 3))
  ⟨
  7 
  
 (apply ’cons ’((+ 2 3) 4))
  ⟨",NA
7.4 ,NA,NA
Simple Sequencing,"Each of the constructs in this section simply evaluates all the argument 
 forms in order. They differ only in what results are returned.
  
 [Special operator]
  progn
  {form}*
  
 The
  progn
  construct takes a number of forms and evaluates them se-
 quentially, in order, from left to right. The values of all the forms but the last 
 are discarded; whatever the last form returns is returned by the
  progn 
 form. One says that all the forms but the last are evaluated for
  effect
 , be-
 cause their execution is useful only for the side effects caused, but the last 
 form is executed for
  value
 .
  
 progn
  is the primitive control structure construct for “compound state-
 ments,” such as
  begin
 -
 end
  blocks in Algol-like languages. Many Lisp con-
 structs are “implicit
  progn
 ” forms: as part of their syntax each allows many 
 forms to be written that are to be evaluated sequentially, discarding the 
 results of all forms but the last and returning the results of the last form.
  
 If the last form of the
  progn
  returns multiple values, then those multiple 
 values are returned by the
  progn
  form. If there are no forms for the
  progn
 , 
 then the result is
  nil
 . These rules generally hold for implicit
  progn
  forms as 
 well.
  
 [Macro]
  prog1
  first {form}*
  
 prog1
  is similar to
  progn
 , but it returns the value of its
  first
  form. All the 
 argument forms are executed sequentially; the value of the first form is 
 saved while all the others are executed and is then returned.
  
 prog1
  is most commonly used to evaluate an expression with side effects 
 and to return a value that must be computed
  before
  the side effects happen.
  
 For example:
  
 (prog1 (car x) (rplaca x ’foo))
  
 alters the
  car
  of
  x
  to be
  foo
  and returns the old
  car
  of
  x
 .",NA
7.5 Establishing New Variable Bindings,"During the invocation of a function represented by a lambda-expression (or 
 a closure of a lambda-expression, as produced by
  function
 ), new bindings 
 are established for the variables that are the parameters of the lambda-
 expression. These bindings initially have values determined by the 
 parameter-binding protocol discussed in section 5.2.2.
  
  
 The following constructs may also be used to establish bindings of vari-
 ables, both ordinary and functional.
  
 [Special operator]
  let
  ({var | (var [value])}*) {declaration}* {form}*
  
  
 A
  let
  form can be used to execute a series of forms with specified 
 variables bound to specified values. 
  
  
 More precisely, the form",NA
7.6 Conditionals,"The traditional conditional construct in Lisp is
  cond
 . However,
  if
  is much 
 simpler and is directly comparable to conditional constructs in other pro-
 gramming languages, so it is considered to be primitive in Common Lisp and 
 is described first. Common Lisp also provides the dispatching constructs 
 case
  and
  typecase
 , which are often more convenient than
  cond
 .
  
 [Special operator]
  if
  test then [else]
  
 The
  if
  special operator corresponds to the
  if
 -
 then
 -
 else
  construct found 
 in most algebraic programming languages. First the form
  test
  is evaluated. If 
 the result is not
  nil
 , then the form
  then
  is selected; otherwise the form 
 else
  
 is selected. Whichever form is selected is then evaluated, and
  if
  returns 
 whatever is returned by evaluation of the selected form.
  
 (if
  test then else
 )
  ≡
  (cond (
 test then
 ) (
 t
  else
 )) 
  
  
 but
  if
  is considered more readable in some situations.
  
 The
  else
  form may be omitted, in which case if the value of
  test
  is
  nil
  
 then nothing is done and the value of the
  if
  form is
  nil
 . If the value of the
  if
  
 form is important in this situation, then the
  and
  construct may be 
 stylistically preferable, depending on the context. If the value is not 
 important, but only the effect, then the
  when
  construct may be stylistically 
 preferable.
  
 [Macro]
  when
  test {form}*
  
  
 (when
  test form1 form2
  ... 
  
 ) 
 first evaluates
  test
 . 
  
 If the result 
 is
  nil
 , then no
  form
  is evaluated, and
  nil
  is returned. Otherwise the
  form
 s 
 constitute an implicit
  progn
  and are evaluated sequentially from left to 
 right, and the value of the last one is returned.
  
 (when
  p a b c
 )
  ≡
  (and
  p
  (progn
  a b c
 )) 
  
 (when
  p a b c
 )
  ≡
  (cond (
 p a b c
 )) 
  
 (when
  p a b c
 )
  ≡
  (if
  p
  (progn
  a b c
 )
  nil
 ) 
  
 (when
  p a b c
 )
  ≡
  (unless (not
  p
 )
  a b c
 ) 
  
  
 As a matter of style,
  when
  is normally used to conditionally produce 
 some side effects, and the value of the
  when
  form is normally not used. If 
 the value is relevant, then it may be stylistically more appropriate to use 
 and
  or
  if
 .
  
 [Macro]
  unless
  test {form}*
  
 (unless
  test form1 form2
  ... )
  first evaluates
  test
 . If the result is
  not 
 nil
 , 
 then the
  form
 s are not evaluated, and
  nil
  is returned. Otherwise the",NA
7.7 Blocks and Exits,"The
  block
  and
  return-from
  constructs provide a structured lexical non-
 local exit facility. At any point lexically within a
  block
  construct, a
  return-
 from
  with the same name may be used to perform an immediate transfer of 
 control that exits from the
  block
 . In the most common cases this 
 mechanism is more efficient than the dynamic non-local exit facility 
 provided by
  catch 
 and
  throw
 , described in section 7.11.
  
 [Special operator]
  block
  name {form}*
  
 The
  block
  construct executes each
  form
  from left to right, returning 
 whatever is returned by the last
  form
 . If, however, a
  return
  or
  return-from
  
 form that specifies the same
  name
  is executed during the execution of some
  
 form
 , then the results specified by the
  return
  or
  return-from
  are 
 immediately returned as the value of the
  block
  construct, and execution 
 proceeds as if the
  block
  had terminated normally. In this,
  block
  differs 
 from
  progn
 ; the
  progn
  construct has nothing to do with
  return
 .",NA
7.8 Iteration,"Common Lisp provides a number of iteration constructs. The
  loop
  con-
 struct provides a trivial iteration facility; it is little more than a
  progn
  with a 
 branch from the bottom back to the top. The
  do
  and
  do*
  constructs provide 
 a general iteration facility for controlling the variation of several variables 
 on each cycle. For specialized iterations over the elements of a list or
  n
  
 consecutive integers,
  dolist
  and
  dotimes
  are provided. The
  tagbody 
 construct is the most general, permitting arbitrary
  go
  statements within it. 
 (The traditional
  prog
  construct is a synthesis of
  tagbody
 ,
  block
 , and
  let
 .) 
 Most of the iteration constructs permit statically defined non-local exits (see 
 return-from
  and
  return
 ).",NA
7.8.1 Indefinite Iteration,"The
  loop
  construct is the simplest iteration facility. It controls no variables, 
 and simply executes its body repeatedly.
  
 [Macro]
  loop
  {form}*
  
 Each
  form
  is evaluated in turn from left to right. When the last
  form 
 has 
 been evaluated, then the first
  form
  is evaluated again, and so on, in a never-
 ending cycle. The
  loop
  construct never returns a value. Its execution must 
 be terminated explicitly, using
  return
  or
  throw
 , for example.
  
  
 loop
 , like most iteration constructs, establishes an implicit block named 
 nil
 . Thus
  return
  may be used to exit from a
  loop
  with specified results.
  
 There is an extension of
  loop
 . See chapter 26.",NA
7.8.2 General Iteration,"In contrast to
  loop
 ,
  do
  and
  do*
  provide a powerful and general mechanism 
 for repetitively recalculating many variables.
  
 [Macro]
  do
  ({(var [init [step]])}*) 
  
 (end-test {result}*) 
  
 {declaration}* {tag | statement}*
  
 [Macro]
  do*
  ({(var [init [step]])}*) 
  
 (end-test {result}*) 
  
 {declaration}* {tag | statement}*
  
 The
  do
  special operator provides a generalized iteration facility, with an 
 arbitrary number of “index variables.” These variables are bound within the 
 iteration and stepped in parallel in specified ways. They may be used both 
 to generate successive values of interest (such as successive integers) or to 
 accumulate results. When an end condition is met, the iteration terminates 
 with a specified value.
  
 In general, a
  do
  loop looks like this:
  
 (do ((
 var1 init1 step1
 ) 
  
 (
 var2 init2 step2
 ) 
  
 ...
  
    
 (
 varn initn stepn
 )) 
  
  
 (
 end-test
  .
  result
 ) 
  
 {declaration}* 
  
 .
  tagbody
 )
  
 A
  do*
  loop looks exactly the same except that the name
  do
  is replaced by
  
 do*
 .
  
 The first item in the form is a list of zero or more index-variable 
 specifiers. Each index-variable specifier is a list of the name of a variable
  
 var
 , an initial value
  init
 , and a stepping form
  step
 . If
  init
  is omitted, it 
 defaults to
  nil
 . If 
 step
  is omitted, the
  var
  is not changed by the
  do
  construct 
 between repeti-tions (though code within the
  do
  is free to alter the value of 
 the variable by using
  setq
 ).
  
 An index-variable specifier can also be just the name of a variable. In this 
 case, the variable has an initial value of
  nil
  and is not changed between 
 repetitions. 
  
 As a matter of style, it is recommended that an unadorned 
 variable name be written only when that variable will be stored into (such",NA
7.8.3 Simple Iteration Constructs,"The constructs
  dolist
  and
  dotimes
  execute a body of code once for each 
 value taken by a single variable. They are expressible in terms of
  do
 , but 
 capture very common patterns of use.",NA
7.8.4 Mapping,"Mapping is a type of iteration in which a function is successively applied to 
 pieces of one or more sequences. The result of the iteration is a sequence 
 con-taining the respective results of the function applications. There are 
 several options for the way in which the pieces of the list are chosen and for 
 what is done with the results returned by the applications of the function.
  
  
 The function
  map
  may be used to map over any kind of sequence. The 
 following functions operate only on lists.
  
 [Function]
  mapcar
  function list
  &rest
  more-lists 
 [Function]
  maplist
  function list
  &rest
  more-lists 
 [Function]
  mapc
  function list
  &rest
  more-lists 
 [Function]
  mapl
  function list
  &rest
  more-lists 
 [Function]
  mapcan
  function list
  &rest
  more-lists 
 [Function]
  mapcon
  function list
  &rest
  more-lists
  
 For each of these mapping functions, the first argument is a function and 
 the rest must be lists. The function must take as many arguments as there 
 are lists.
  
 mapcar
  operates on successive elements of the lists. First the function is 
 applied to the
  car
  of each list, then to the
  cadr
  of each list, and so on. 
 (Ideally all the lists are the same length; if not, the iteration terminates 
 when",NA
7.8.5 The “Program Feature”,"Lisp implementations since Lisp 1.5 have had what was originally called“the 
 program feature,” as if it were impossible to write programs without it! The
  
 prog
  construct allows one to write in an Algol-like or Fortran-like 
 statement-oriented style, using
  go
  statements that can refer to tags in the 
 body of the
  prog
 . Modern Lisp programming style tends to use
  prog
  rather 
 infrequently. The various iteration constructs, such as
  do
 , have bodies with 
 the characteristics of a
  prog
 . (However, the ability to use
  go
  statements 
 within iteration constructs is very seldom called upon in practice.) 
  
  
 Three distinct operations are performed by
  prog
 : it binds local variables, 
 it permits use of the
  return
  statement, and it permits use of the
  go
  state-
 ment. In Common Lisp, these three operations have been separated into 
 three distinct constructs:
  let
 ,
  block
 , and
  tagbody
 . These three constructs 
 may be used independently as building blocks for other types of constructs.
  
 [Special operator]
  tagbody
  {tag | statement}*
  
 The part of a
  tagbody
  after the variable list is called the
  body
 . An item in 
 the body may be a symbol or an integer, in which case it is called a
  tag
 , or 
 an item in the body may be a list, in which case it is called a
  statement
 .",NA
7.9 ,NA,NA
Structure Traversal and Side Effects,"X3J13 voted in January 1989 to restrict side effects during the course of a 
 built-in operation that can execute user-supplied code while traversing a 
 data structure.
  
 Consider the following example:
  
 (let ((x ’(apples peaches pumpkin pie))) 
  
 (dolist (z x) 
  
  
 (when (eq z ’peaches) 
  
   
 (setf (cddr x) ’(mango kumquat))) 
  
  
 (format t "" S "" (car z))))
  
 Depending on the details of the implementation of
  dolist
 , this bit of code 
 could easily print
  
 apples peaches mango kumquat
  
 (which is perhaps what was intended), but it might as easily print
  
 apples peaches pumpkin pie
  
 Here is a plausible implementation of
  dolist
  that produces the first result:
  
 (defmacro dolist ((var listform &optional (resultform ”nil)) 
  
    
 &body body) 
  
 (let ((tailvar (gensym ""DOLIST"")))
  
  
 ‘(do ((,tailvar ,listform (cdr ,tailvar))) 
  
    
 ((null ,tailvar) ,resultform) 
  
   
 (let ((,var (car ,tailvar))) ,@body))",NA
7.10 Multiple Values,"Ordinarily the result of calling a Lisp function is a single Lisp object. Some-
 times, however, it is convenient for a function to compute several objects 
 and return them. Common Lisp provides a mechanism for handling multi-
 ple values directly. This mechanism is cleaner and more efficient than the 
 usual tricks involving returning a list of results or stashing results in global 
 variables.",NA
7.10.1 Constructs for Handling Multiple Values,"Normally multiple values are not used. Special operators are required both 
 to
  produce
  multiple values and to
  receive
  them. If the caller of a function 
 does not request multiple values, but the called function produces multiple 
 values, then the first value is given to the caller and all others are discarded; 
 if the called function produces zero values, then the caller gets
  nil
  as a 
 value.
  
 The primary primitive for producing multiple values is
  values
 , which 
 takes any number of arguments and returns that many values. If the last 
 form in the body of a function is a
  values
  with three arguments, then a call 
 to that function will return three values. Other special forms also produce 
 multiple values, but they can be described in terms of
  values
 . Some built-in 
 Common Lisp functions, such as
  floor
 , return multiple values; those that do 
 are so documented.
  
 The special operators and macros for receiving multiple values are as 
 follows:
  
 multiple-value-list 
  
 multiple-value-call",NA
7.10.2 Rules Governing the Passing of Multiple Values,"It is often the case that the value of a special operator or macro call is 
 defined to be the value of one of its subforms. For example, the value of a
  
 cond
  is the value of the last form in the selected clause.
  
 In most such cases, if the subform produces multiple values, then the 
 original form will also produce all of those values. 
  
 This
  passing back
  of 
 multiple values of course has no effect unless eventually one of the special 
 operators for receiving multiple values is reached.
  
 To be explicit, multiple values can result from a special operator under 
 precisely these circumstances:
  
 Evaluation and application
  
 •
  eval
  returns multiple values if the form given it to evaluate pro-duces multiple values.
  
 •
  apply
 ,
  funcall
 , and
  multiple-value-call
  pass back multiple val-ues from the function 
 applied or called.
  
 Implicit progn contexts
  
 •
  The special operator
  progn
  passes back multiple values resulting 
 from evaluation of the last subform. Other situations referred to 
 as “implicit
  progn
 ,” where several forms are evaluated and the 
 results of all but the last form are discarded, also pass back mul-
 tiple values from the last form. These situations include the body",NA
7.11 Dynamic Non-Local Exits,"Common Lisp provides a facility for exiting from a complex process in a 
 non-local, dynamically scoped manner. There are two classes of special 
 operators for this purpose, called
  catch
  forms and
  throw
  forms, or simply
  
 catches
  and 
 throws
 . A catch form evaluates some subforms in such a way 
 that, if a throw form is executed during such evaluation, the evaluation is 
 aborted at that point and the catch form immediately returns a value 
 specified by the throw. Unlike
  block
  and
  return
  (section 7.7), which allow 
 for exiting a
  block 
 form from any point lexically within the body of the
  
 block
 , the catch/throw mechanism works even if the throw form is not 
 textually within the body of the catch form. The throw need only occur 
 within the extent (time span) of the evaluation of the body of the catch. This 
 is analogous to the distinction between dynamically bound (special) 
 variables and lexically bound (local) variables.
  
 [Special operator]
  catch
  tag {form}*
  
 The
  catch
  special operator serves as a target for transfer of control by 
 throw
 . The form
  tag
  is evaluated first to produce an object that names the 
 catch; it may be any Lisp object. A catcher is then established with the 
 object as the tag. The
  form
 s are evaluated as an implicit
  progn
 , and the 
 results of the last form are returned, except that if during the evaluation of 
 the
  form
 s a throw should be executed such that the tag of the throw 
 matches (is
  eq
  to) the tag of the
  catch
  and the catcher is the most recent 
 outstanding catcher with that tag, then the evaluation of the
  form
 s is 
 aborted and the results specified by the throw are immediately returned 
 from the
  catch
  expression. The catcher established by the
  catch
  expression 
 is disestablished just before the results are returned.
  
 The tag is used to match throws with catches.
  (catch ’foo
  form
 )
  will 
 catch a
  (throw ’foo
  form
 )
  but not a
  (throw ’bar
  form
 )
 . It is an error if 
 throw
  is done when there is no suitable
  catch
  ready to catch it.
  
  
 Catch tags are compared using
  eq
 , not
  eql
 ; therefore numbers and char-
 acters should not be used as catch tags.
  
 [Special operator]
  unwind-protect
  protected-form {cleanup-form}*
  
  
 Sometimes it is necessary to evaluate a form and make sure that certain 
 side effects take place after the form is evaluated; a typical example is",NA
Chapter 8,NA,NA
Macros,"The Common Lisp macro facility allows the user to define arbitrary func-
 tions that convert certain Lisp forms into different forms before evaluating 
 or compiling them. This is done at the expression level, not at the character-
 string level as in most other languages. Macros are important in the writing 
 of good code: they make it possible to write code that is clear and elegant at 
 the user level but that is converted to a more complex or more efficient 
 internal form for execution.
  
 When
  eval
  is given a list whose
  car
  is a symbol, it looks for local defini-
 tions of that symbol (by
  flet
 ,
  labels
 , and
  macrolet
 ); if that fails, it looks for 
 a global definition. If the definition is a macro definition, then the orig-inal 
 list is said to be a
  macro call
 . Associated with the definition will be a 
 function of two arguments, called the
  expansion function
 . This function is 
 called with the entire macro call as its first argument (the second argument 
 is a lexical environment); it must return some new Lisp form, called the
  
 expan-sion
  of the macro call. (Actually, a more general mechanism is 
 involved; see 
 macroexpand
 .) This expansion is then evaluated in place of 
 the original form.
  
 When a function is being compiled, any macros it contains are expanded 
 at compilation time. This means that a macro definition must be seen by the 
 compiler before the first use of the macro.
  
 More generally, an implementation of Common Lisp has great latitude in 
 deciding exactly when to expand macro calls within a program. For exam-
 ple, it is acceptable for the
  defun
  special operator to expand all macro calls 
 within its body at the time the
  defun
  form is executed and record the fully 
 expanded body as the body of the function being defined. (An implementa-
  
 201",NA
8.1 Macro Definition,"The function
  macro-function
  determines whether a given symbol is the 
 name of a macro. The
  defmacro
  construct provides a convenient way to 
 define new macros.
  
 [Function]
  macro-function
  symbol
  &optional
  env
  
 The first argument must be a symbol. If the symbol has a function defi-
 nition that is a macro definition, whether a local one established in the en-
 vironment
  env
  by
  macrolet
  or a global one established as if by
  defmacro
 , 
 then the expansion function (a function of two arguments, the macro-call 
 form and an environment) is returned. If the symbol has no function defi-
 nition, or has a definition as an ordinary function or as a special operator 
 but not as a macro, then
  nil
  is returned. The function
  macroexpand
  or 
 macroexpand-1
  is the best way to invoke the expansion function.
  
 It is possible for
  both
  macro-function
  and
  special-operator-p
  to be 
 true of a symbol. This is possible because an implementation is permitted to 
 implement any macro also as a special operator for speed. On the other 
 hand, the macro definition must be available for use by programs that 
 understand only the standard special operators listed in table 5.1.
  
  
 setf
  may be used with
  macro-function
  to install a macro as a symbol’s 
 global function definition:
  
 (setf (macro-function
  symbol
 )
  fn
 )",NA
8.2 Macro Expansion,"The
  macroexpand
  function is the conventional means for expanding a 
 macro call. A hook is provided for a user function to gain control during the 
 expansion process.",NA
8.3 Destructuring,"[Macro]
  destructuring-bind
  lambda-list expression {declaration}* {form}*
  
 This macro binds the variables specified in
  lambda-list
  to the 
 correspond-ing values in the tree structure resulting from evaluating the
  
 expression
 , then",NA
8.4 ,NA,NA
Compiler Macros,"X3J13 voted in June 1989 to add a facility for defining
  compiler macros
  that 
 take effect only when compiling code, not when interpreting it.
  
 The purpose of this facility is to permit selective source-code 
 transforma-tions only when the compiler is processing the code. When the 
 compiler is about to compile a non-atomic form, it first calls
  compiler-
 macroexpand-1
  repeatedly until there is no more expansion (there might 
 not be any to begin with). Then it continues its remaining processing, which 
 may include calling
  macroexpand-1
  and so on.
  
 The compiler is required to expand compiler macros. It is unspecified 
 whether the interpreter does so. The intention is that only the compiler will 
 do so, but the range of possible “compiled-only” implementation strategies 
 precludes any firm specification.
  
 [Macro]
  define-compiler-macro
  name lambda-list 
 {declaration | doc-string}* {form}*
  
 This is just like
  defmacro
  except the definition is not stored in the symbol 
 function cell of
  name
  and is not seen by
  macroexpand-1
 . It is, however, seen 
 by
  compiler-macroexpand-1
 . 
  
 As with
  defmacro
 , the
  lambda-list 
 may include
  &environment
  and
  &whole
  and may include destructuring. 
 The definition is global. (There is no provision for defining local compiler 
 macros in the way that
  macrolet
  defines local macros.) 
  
 A top-level call to
  define-compiler-macro
  in a file being compiled by 
 compile-file
  has an effect on the compilation environment similar to that of 
 a call to
  defmacro
 , except it is noticed as a compiler macro (see section 
 24.1).
  
 Note that compiler macro definitions do not appear in information re-
 turned by
  function-information
 ; they are global, and their interaction",NA
8.5 ,NA,NA
Environments,"X3J13 voted in June 1989 to add some facilities for obtaining informa-tion 
 from environment objects of the kind received as arguments by macro 
 expansion functions,
  *macroexpand-hook*
  functions, and
  *evalhook* 
 functions. 
  
 There is a minimal set of accessors (
 variable-information
 , 
 function-information
 , and
  declaration-information
 ) and a constructor 
 (
 augment-environment
 ) for environments.
  
 All of the standard declaration specifiers, with the exception of
  special
 , 
 can be defined fairly easily using
  define-declaration
 . It also seems to be 
 able to handle most extended declarations.
  
 The function
  parse-macro
  is provided so that users don’t have to write 
 their own code to destructure macro arguments. This function is not 
 entirely necessary since X3J13 voted in March 1989 to add
  destructuring-
 bind
  to the language. However,
  parse-macro
  is worth having anyway, 
 since any program-analyzing program is going to need to define it, and the 
 implemen-tation isn’t completely trivial even with
  destructuring-bind
  to 
 build upon.",NA
Chapter 9,NA,NA
Declarations,"Declarations allow you to specify extra information about your program to 
 the Lisp system. With one exception, declarations are completely optional 
 and correct declarations do not affect the meaning of a correct program. 
 The exception is that
  special
  declarations
  do
  affect the interpretation of 
 variable bindings and references and so
  must
  be specified where 
 appropriate. All other declarations are of an advisory nature, and may be 
 used by the Lisp system to aid the programmer by performing extra error 
 checking or producing more efficient compiled code. Declarations are also a 
 good way to add documentation to a program.
  
 Note that it is considered an error for a program to violate a declaration 
 (such as a
  type
  declaration), but an implementation is not required to 
 detect such errors (though such detection, where feasible, is to be 
 encouraged).",NA
9.1 ,NA,NA
Declaration Syntax,"The
  declare
  construct is used for embedding declarations within 
 executable code. Global declarations and declarations that are computed by 
 a program are established by the
  proclaim
  construct.
  
 Macro
  declaim
 , which is guaranteed to be recognized appropriately by 
 the compiler, is often more convenient than
  proclaim
  for establishing 
 global declarations.
  
 [Special operator]
  declare
  {decl-spec}*
  
 A
  declare
  form is known as a
  declaration
 . Declarations may occur only at 
 the beginning of the bodies of certain special operators; that is, a declaration
  
 225",NA
9.2 Declaration Specifiers,"Here is a list of valid declaration specifiers for use in
  declare
 . A construct is 
 said to be “affected” by a declaration if it occurs within the scope of a 
 declaration.
  
 special (special
  var1 var2
  ...)
  specifies that all of the variables named are 
 to be considered
  special
 . This specifier affects variable bindings but 
 also pervasively affects references. All variable bindings affected are 
 made to be dynamic bindings, and affected variable references refer 
 to the current dynamic binding rather than to the current local 
 binding.
  
 For example:
  
 (defun hack (thing *mod*) 
 (declare (special *mod*)) 
 (hack1 (car thing)))
  
  
 ;The binding of the parameter 
  
 ;
  *mod*
  is visible to
  hack1
 , ; but 
 not that of
  thing
  
 (defun hack1 (arg) 
  
  
 (declare (special *mod*)) 
  
 ;Declare references to
  *mod* 
   
 ; within
  hack1
  to be special 
  
  
 (if (atom arg) *mod* 
  
   
 (cons (hack1 (car arg)) (hack1 (cdr arg)))))",NA
9.3 Type Declaration for Forms,"Frequently it is useful to declare that the value produced by the evaluation 
 of some form will be of a particular type. Using
  declare
  one can declare the 
 type of the value held by a bound variable, but there is no easy way to 
 declare the type of the value of an unnamed form. For this purpose the
  the 
 special operator is defined;
  (the
  type form
 )
  means that the value of
  form 
 is 
 declared to be of type
  type
 .
  
 [Special operator]
  the
  value-type form
  
 The
  form
  is evaluated; whatever it produces is returned by the
  the
  form.",NA
Chapter 10,NA,NA
Symbols,"A Lisp symbol is a data object that has three user-visible components:
  
 •
  The
  property list
  is a list that effectively provides each symbol with many 
 modifiable named components.
  
 •
  The
  print name
  must be a string, which is the sequence of characters 
 used to identify the symbol. Symbols are of great use because a 
 symbol can be located once its name is given (typed, say, on a 
 keyboard). One may ordinarily not alter a symbol’s print name.
  
 It is an error to alter a print name.
  
 •
  The
  package cell
  must refer to a package object. A package is a data 
 structure used to locate a symbol once given the symbol’s name. A 
 symbol is uniquely identified by its name only when considered 
 relative to a package. A symbol may appear in many packages, but it 
 can be 
 owned
  by at most one package. The package cell points to the 
 owner, if any. Package cells are discussed along with packages in 
 chapter 11.
  
 A symbol may actually have other components for use by the imple-
 mentation. 
  
 One of the more important uses of symbols is as names for 
 program variables; it is frequently desirable for the implementor to use cer-
 tain components of a symbol to implement the semantics of variables. See 
 symbol-value
  and
  symbol-function
 . However, there are several possible 
 implementation strategies, and so such possible components are not 
 described here.",NA
The Property List,CHAPTER 10. SYMBOLS,NA
10.1,"Since its inception, Lisp has associated with each symbol a kind of tabular 
 data structure called a
  property list
  (
 plist
  for short). A property list contains 
 zero or more entries; each entry associates with a key (called the
  indicator
 ), 
 which is typically a symbol, an arbitrary Lisp object (called the
  value
  or, 
 sometimes, the
  property
 ). There are no duplications among the indicators; a 
 property list may only have one property at a time with a given name. In 
 this way, given a symbol and an indicator (another symbol), an associated 
 value can be retrieved.
  
 A property list is very similar in purpose to an association list. The 
 differ-ence is that a property list is an object with a unique identity; the 
 operations for adding and removing property-list entries are destructive 
 operations that alter the property list rather than making a new one. 
 Association lists, on the other hand, are normally augmented non-
 destructively (without side effects) by adding new entries to the front (see
  
 acons
  and
  pairlis
 ).
  
 A property list is implemented as a memory cell containing a list with an 
 even number (possibly zero) of elements. (Usually this memory cell is the 
 property-list cell of a symbol, but any memory cell acceptable to
  setf 
 can be 
 used if
  getf
  and
  remf
  are used.) Each pair of elements in the list constitutes 
 an entry; the first item is the indicator, and the second is the value. Because 
 property-list functions are given the symbol and not the list itself, 
 modifications to the property list can be recorded by storing back into the 
 property-list cell of the symbol.
  
  
 When a symbol is created, its property list is initially empty. Properties 
 are created by using
  get
  within a
  setf
  form.
  
 Common Lisp does not use a symbol’s property list as extensively as 
 ear-lier Lisp implementations did. Less-used data, such as compiler, 
 debugging, and documentation information, is kept on property lists in 
 Common Lisp.
  
 [Function]
  get
  symbol indicator
  &optional
  default
  
 get
  searches the property list of
  symbol
  for an indicator
  eq
  to
  indicator
 . 
 The first argument must be a symbol. If one is found, then the 
 corresponding value is returned; otherwise
  default
  is returned.
  
 If
  default
  is not specified, then
  nil
  is used for
  default
 .
  
  
 Note that there is no way to distinguish an absent property from one 
 whose value is
  default
 .",NA
The Print Name,CHAPTER 10. SYMBOLS,NA
10.2,"Every symbol has an associated string called the
  print name
 . This string is 
 used as the external representation of the symbol: if the characters in the 
 string are typed in to
  read
  (with suitable escape conventions for certain 
 char-acters), it is interpreted as a reference to that symbol (if it is interned); 
 and if the symbol is printed,
  print
  types out the print name. For more 
 information, see the sections on the
  reader
  (section 22.1.1) and
  printer
  
 (section 22.1.6).
  
 [Function]
  symbol-name
  sym
  
 This returns the print name of the symbol
  sym
 . For example:
  
 (symbol-name ’xyz)
  ⟨
  ""XYZ""
  
 It is an extremely bad idea to modify a string being used as the print 
 name of a symbol. Such a modification may tremendously confuse the 
 function 
 read
  and the package system.
  
 It is an error to modify a string being used as the print name of a symbol.",NA
10.3 Creating Symbols,"Symbols can be used in two rather different ways. An
  interned
  symbol is 
 one that is indexed by its print name in a catalogue called a
  package
 . A 
 request to locate a symbol with that print name results in the same (
 eq
 ) 
 symbol. Every time input is read with the function
  read
 , and that print 
 name appears, it is read as the same symbol. This property of symbols 
 makes them appropriate to use as names for things and as hooks on which 
 to hang permanent data objects (using the property list, for example).
  
 Interned symbols are normally created automatically; the first time 
 some-thing (such as the function
  read
 ) asks the package system for a 
 symbol with a given print name, that symbol is automatically created. The 
 function used to ask for an interned symbol is
  intern
 , or one of the 
 functions related to 
 intern
 .
  
  
 Although interned symbols are the most commonly used, they will not be 
 discussed further here. For more information, see chapter 11.
  
 An
  uninterned
  symbol is a symbol used simply as a data object, with no 
 special cataloguing (it belongs to no particular package). An uninterned",NA
Chapter 11,NA,NA
Packages,"One problem with earlier Lisp systems is the use of a single name space for 
 all symbols. In large Lisp systems, with modules written by many different 
 programmers, accidental name collisions become a serious problem. 
 Common Lisp addresses this problem through the
  package system
 , derived 
 from an earlier package system developed for Lisp Machine Lisp [55]. In 
 addition to preventing name-space conflicts, the package system makes the 
 modular structure of large Lisp systems more explicit.
  
 A
  package
  is a data structure that establishes a mapping from print names 
 (strings) to symbols. 
  
 The package thus replaces the “oblist” or 
 “obarray”machinery of earlier Lisp systems. At any given time one package is 
 current, and this package is used by the Lisp reader in translating strings 
 into symbols. The current package is, by definition, the one that is the value 
 of the global variable
  *package*
 . 
  
 It is possible to 
 refer to symbols in packages other than the current one through the use of
  
 package qualifiers
  in the printed representation of the symbol. For example,
  
 foo:bar
 , when seen by the reader, refers to the symbol whose name is
  bar
  in 
 the package whose name is
  foo
 . (Actually, this is true only if
  bar
  is an 
 external symbol of
  foo
 , that is, a symbol that is supposed to be visible 
 outside of
  foo
 . 
  
 A reference to an internal symbol requires the 
 intentionally clumsier syntax
  foo::bar
 .) The string-to-symbol mappings 
 available in a given package are divided into two classes,
  external
  and
  
 internal
 . We refer to the symbols accessible via these mappings as being
  
 external
  and
  internal
  symbols of the package in question, though really it is 
 the mappings that are different and not the symbols themselves. Within a 
 given package, a name refers to one symbol or to none; if it does refer to a 
 symbol, then it is either external or internal
  
 259",NA
11.1 Consistency Rules,"Package-related bugs can be very subtle and confusing: things are not what 
 they appear to be. The Common Lisp package system is designed with a 
 number of safety features to prevent most of the common bugs that would 
 otherwise occur in normal use. This may seem over-protective, but 
 experience with earlier package systems has shown that such safety 
 features are needed.
  
 In dealing with the package system, it is useful to keep in mind the 
 following consistency rules, which remain in force as long as the value of 
 *package*
  is not changed by the user:
  
 • Read-read consistency:
  Reading the same print name always results in the same 
 (
 eq
 ) symbol.
  
 • Print-read consistency:
  An interned symbol always prints as a sequence of 
 characters that, when read back in, yields the same (
 eq
 ) symbol.
  
 • Print-print consistency:
  If two interned symbols are not
  eq
 , then their printed 
 representations will be different sequences of characters.
  
 These consistency rules remain true in spite of any amount of implicit 
 interning caused by typing in Lisp forms, loading files, etc. This has the 
 important implication that, as long as the current package is not changed, 
 results are reproducible regardless of the order of loading files or the exact 
 history of what symbols were typed in when. The rules can only be violated 
 by explicit action: changing the value of
  *package*
 , forcing some action by",NA
11.2 Package Names,"Each package has a name (a string) and perhaps some nicknames. These are 
 assigned when the package is created, though they can be changed later. A 
 package’s name should be something long and self-explanatory, like
  editor
 ; 
 there might be a nickname that is shorter and easier to type, such as
  ed
 .
  
 There is a single name space for packages. The function
  find-package 
 translates a package name or nickname into the associated package. The 
 func-tion
  package-name
  returns the name of a package. The function
  
 package-
 The function 
 nicknames
  returns a list of all nicknames for a 
 package.
  
 rename-package
  removes a package’s current name and nicknames and 
 replaces them with new ones specified by the user. 
  
 Package renaming is 
 occasionally useful when, for development purposes, it is desirable to load 
 two versions of a package into the same Lisp. One can load the first version, 
 rename it, and then load the other version, without getting a lot of name 
 conflicts.
  
  
 When the Lisp reader sees a qualified symbol, it handles the package-
 name part in the same way as the symbol part with respect to capitalization. 
 Lowercase characters in the package name are converted to corresponding 
 uppercase characters unless preceded by the escape character
  \
  or 
 surrounded by
  |
  characters. 
  
 The lookup done by the
  find-
 package
  function is case-sensitive, like that done for symbols. Note that
  
 |Foo|:|Bar|
  refers to a symbol whose name is
  Bar
  in a package whose name 
 is
  Foo
 . By contrast, 
 |Foo:Bar|
  refers to a seven-character symbol that has a 
 colon in its name (as well as two uppercase letters and four lowercase 
 letters) and is interned in the current package. Following the convention 
 used in this book for symbols, we show ordinary package names using 
 lowercase letters, even though the name string is internally represented 
 with uppercase letters.
  
 Most of the functions that require a package-name argument from the 
 user accept either a symbol or a string. If a symbol is supplied, its print 
 name will be used; the print name will already have undergone case-
 conversion by the usual rules. If a string is supplied, it must be so 
 capitalized as to match exactly the string that names the package.
  
 X3J13 voted in January 1989 to clarify that one may use either a package 
 object or a package name (symbol or string) in any of the following 
 situations:
  
 •
  the
  :use
  argument to
  make-package
  
 •
  the first argument to
  package-use-list
 , 
  
 package-used-by-list
 ,",NA
11.3 Translating Strings to Symbols,"The value of the special variable
  *package*
  must always be a package 
 object (not a name). Whatever package object is currently the value of
  
 *package* 
 is referred to as the
  current package
 .
  
 When the Lisp reader has, by parsing, obtained a string of characters 
 thought to name a symbol, that name is looked up in the current package. 
 This lookup may involve looking in other packages whose external symbols 
 are inherited by the current package. If the name is found, the 
 corresponding symbol is returned. If the name is not found (that is, there is 
 no symbol of that name accessible in the current package), a new symbol is 
 created for it and is placed in the current package as an internal symbol. 
 Moreover, the current package becomes the owner (home package) of the 
 symbol, and so the symbol becomes interned in the current package. If the 
 name is later read again while this same package is current, the same 
 symbol will then be found and returned.
  
 Often it is desirable to refer to an external symbol in some package other 
  
 This is done through the use of a
  qualified name
 , than the current one.",NA
11.4 Exporting and Importing Symbols,"Symbols from one package may be made accessible in another package in 
 two ways.
  
 First, any individual symbol may be added to a package by use of the 
 function
  import
 . 
  
 The form
  (import ’editor:buffer)
  takes the external 
 symbol named
  buffer
  in the
  editor
  package (this symbol was located when 
 the form was read by the Lisp reader) and adds it to the current package as 
 an internal symbol. The symbol is then present in the current package. The",NA
Name Conflicts,CHAPTER 11. PACKAGES,NA
11.5,"A fundamental invariant of the package system is that within one package 
 any particular name can refer to at most one symbol. A
  name conflict
  is said 
 to occur when there is more than one candidate symbol and it is not 
 obvious which one to choose. If the system does not always choose the 
 same way, the read-read consistency rule would be violated. For example, 
 some programs or data might have been read in under a certain mapping of 
 the name to a symbol. If the mapping changes to a different symbol, and 
 subsequently additional programs or data are read, then the two programs 
 will not access the same symbol even though they use the same name. Even 
 if the system did always choose the same way, a name conflict is likely to 
 result in a mapping from names to symbols different from what was 
 expected by the user, causing programs to execute incorrectly. Therefore, 
 any time a name conflict is about to occur, an error is signaled. The user 
 may continue from the error and tell the package system how to resolve the 
 conflict.
  
 It may be that the same symbol is accessible to a package through more 
 than one path. For example, the symbol might be an external symbol of 
 more than one used package, or the symbol might be directly present in a 
 package and also inherited from another package. In such cases there is no 
 name conflict. The same identical symbol cannot conflict with itself. Name 
 conflicts occur only between distinct symbols with the same name.
  
 The creator of a package can tell the system in advance how to resolve a 
 name conflict through the use of
  shadowing
 . Every package has a list of 
 shadowing symbols. A shadowing symbol takes precedence over any other 
 symbol of the same name that would otherwise be accessible to the 
 package. A name conflict involving a shadowing symbol is always resolved 
 in favor of the shadowing symbol, without signaling an error (except for 
 one instance involving
  import
  described below). The functions
  shadow
  
 and
  shadowing-import
  may be used to declare shadowing symbols.
  
 Name conflicts are detected when they become possible, that is, when 
 the package structure is altered. There is no need to check for name 
 conflicts during every name lookup.
  
 The functions
  use-package
 ,
  import
 , and
  export
  check for name con-
 flicts.
  use-package
  makes the external symbols of the package being used 
 accessible to the using package; each of these symbols is checked for name 
 conflicts with the symbols already accessible.
  import
  adds a single symbol 
 to the internals of a package, checking for a name conflict with an exist-",NA
11.6 Built-in Packages,"common-lisp
  The package named
  common-lisp
  contains the primitives of 
 the ANSI Common Lisp system (as opposed to a Common Lisp system 
 based on the 1984 specification). Its external symbols include all of 
 the user-visible functions and global variables that are present in the 
 ANSI Common Lisp system, such as
  car
 ,
  cdr
 , and
  *package*
 . Note, 
 however, that the home package of such symbols is not necessarily 
 the 
 common-lisp
  package (this makes it easier for symbols such as
  t
  
 and 
 lambda
  to be shared between the
  common-lisp
  package and 
 another package, possibly one named
  lisp
 ). Almost all other packages 
 ought to use
  common-lisp
  so that these symbols will be accessible 
 without qualification. This package has the nickname
  cl
 .
  
 common-lisp-user
  The
  common-lisp-user
  package is, by default, the 
 current package at the time an ANSI Common Lisp system starts up. 
 This package uses the
  common-lisp
  package and has the nickname",NA
11.7,NA,NA
Package System Functions and Variables,"Implementation note:
  In the past, some Lisp compilers have read the entire file 
 into Lisp before processing any of the forms. Other compilers have arranged for 
 the loader to do all of its intern operations before evaluating any of the top-level 
 forms. Neither of these techniques will work in a straightforward way in Common 
 Lisp because of the presence of multiple packages. 
 For the functions described here, all optional arguments named
  package 
 default to the current value of
  *package*
 . Where a function takes an argu-
 ment that is either a symbol or a list of symbols, an argument of
  nil
  is 
 treated as an empty list of symbols. Any argument described as a package 
 name may",NA
Chapter 12,NA,NA
Numbers,"Common Lisp provides several different representations for numbers. 
 These representations may be divided into four categories: integers, ratios, 
 floating-point numbers, and complex numbers. Many numeric functions will 
 accept any kind of number; they are
  generic
 . Other functions accept only 
 certain kinds of numbers.
  
 Note that this remark, predating the design of the Common Lisp Object 
 System, uses the term “generic” in a generic sense and not necessarily in the 
 technical sense used by CLOS (see chapter 2).
  
 In general, numbers in Common Lisp are not true objects;
  eq
  cannot be 
 counted upon to operate on them reliably. In particular, it is possible that 
 the expression
  
 (let ((x z) (y z)) (eq x y))
  
 may be false rather than true if the value of
  z
  is a number.
  
 Rationale:
  This odd breakdown of
  eq
  in the case of numbers allows the imple- 
 mentor enough design freedom to produce exceptionally efficient numerical code 
 on conventional architectures. MacLisp requires this freedom, for example, in or- 
 der to produce compiled numerical code equal in speed to Fortran. Common Lisp 
 makes this same restriction, if not for this freedom, then at least for the sake of 
 compatibility. 
 If two objects are to be compared for “identity,” but either might be a 
 number, then the predicate
  eql
  is probably appropriate; if both objects are 
 known to be numbers, then
  =
  may be preferable.
  
 291",NA
"12.1 Precision, Contagion, and Coercion","In general, computations with floating-point numbers are only approximate. 
 The
  precision
  of a floating-point number is not necessarily correlated at all 
 with the
  accuracy
  of that number. For instance, 3.142857142857142857 is a 
 more precise approximation to
  π
  than 3.14159, but the latter is more accu-
 rate. The precision refers to the number of bits retained in the 
 representation. When an operation combines a short floating-point number 
 with a long one, the result will be a long floating-point number. This rule is 
 made to ensure that as much accuracy as possible is preserved; however, it 
 is by no means a guarantee. Common Lisp numerical routines do assume, 
 however, that the accuracy of an argument does not exceed its precision. 
 Therefore when two small floating-point numbers are combined, the result 
 will always be a small floating-point number. This assumption can be 
 overridden by first ex-plicitly converting a small floating-point number to a 
 larger representation. (Common Lisp never converts automatically from a 
 larger size to a smaller one.) 
  
  
 Rational computations cannot overflow in the usual sense (though of 
 course there may not be enough storage to represent one), as integers and 
 ratios may in principle be of any magnitude. Floating-point computations 
 may get exponent overflow or underflow; this is an error.
  
 X3J13 voted in June 1989 to address certain problems relating to 
 floating-point overflow and underflow, but certain parts of the proposed 
 solution were not adopted, namely to add the macro
  without-floating-
 underflow-traps 
 to the language and to require certain behavior of 
 floating-point overflow and underflow. The committee agreed that this area 
 of the language requires more discussion before a solution is standardized.
  
  
 For the record, the proposal that was considered and rejected (for the 
 nonce) introduced a macro
  without-floating-underflow-traps
  that would 
 execute its body in such a way that, within its dynamic extent, a floating-
 point underflow must not signal an error but instead must produce either a 
 denormalized number or zero as the result. The rejected proposal also 
 specified the following treatment of overflow and underflow:
  
 •
  A floating-point computation that overflows should signal an error of type
  
 floating-point-overflow
 .
  
 •
  Unless the dynamic extent of a use of
  without-floating-underflow-traps
 , 
 a floating-point computation that underflows should signal an",NA
12.2 Predicates on Numbers,"Each of the following functions tests a single number for a specific property. 
 Each function requires that its argument be a number; to call one with a 
 non-number is an error.
  
 [Function]
  zerop
  number
  
 This predicate is true if
  number
  is zero (the integer zero, a floating-point 
 zero, or a complex zero), and is false otherwise. Regardless of whether an 
 implementation provides distinct representations for positive and negative 
 floating-point zeros,
  (zerop -0.0)
  is always true. It is an error if the argu-
 ment
  number
  is not a number.
  
 [Function]
  plusp
  number
  
 This predicate is true if
  number
  is strictly greater than zero, and is false 
 otherwise. It is an error if the argument
  number
  is not a non-complex num-
 ber.",NA
12.3 Comparisons on Numbers,"Each of the functions in this section requires that its arguments all be num-
 bers; to call one with a non-number is an error. Unless otherwise specified, 
 each works on all types of numbers, automatically performing any required 
 coercions when arguments are of different types.
  
 [Function]
  =
  number
  &rest
  more-numbers 
 [Function]
  /=
  number
  &rest
  more-numbers 
 [Function]
  <
  number
  &rest
  more-numbers 
 [Function]
  >
  number
  &rest
  more-numbers 
 [Function]
  <=
  number
  &rest
  more-numbers 
 [Function]
  >=
  number
  &rest
  more-numbers
  
  
 These functions each take one or more arguments. If the sequence of 
 arguments satisfies a certain condition:
  
 = 
  
 /=
  
 all the same 
  
 all different",NA
12.4 Arithmetic Operations,"Each of the functions in this section requires that its arguments all be num-
 bers; to call one with a non-number is an error. Unless otherwise specified, 
 each works on all types of numbers, automatically performing any required 
 coercions when arguments are of different types.
  
 [Function]
  +
  &rest
  numbers
  
 This returns the sum of the arguments. If there are no arguments, the result 
 is
  0
 , which is an identity for this operation.
  
 [Function]
  -
  number
  &rest
  more-numbers
  
 The function
  -
 , when given one argument, returns the negative of that 
 argument.
  
 The function
  -
 , when given more than one argument, successively sub-
 tracts from the first argument all the others, and returns the result. For 
 example,
  (- 3 4 5)
  ⟨
  -6
 .
  
 [Function]
  *
  &rest
  numbers
  
 This returns the product of the arguments. If there are no arguments, the 
 result is
  1
 , which is an identity for this operation.
  
 [Function]
  /
  number
  &rest
  more-numbers
  
 The function
  /
 , when given more than one argument, successively divides 
 the first argument by all the others and returns the result.
  
 It is generally accepted that it is an error for any argument other than the 
 first to be zero.
  
 With one argument,
  /
  reciprocates the argument.
  
 It is generally accepted that it is an error in this case for the argument to be 
 zero.
  
 /
  will produce a ratio if the mathematical quotient of two integers is not an 
 exact integer. For example:",NA
12.5 Irrational and Transcendental Functions,"Common Lisp provides no data type that can accurately represent irrational 
 numerical values. The functions in this section are described as if the 
 results were mathematically accurate, but actually they all produce floating-
 point approximations to the true mathematical result in the general case. In 
 some places mathematical identities are set forth that are intended to 
 elucidate the meanings of the functions; however, two mathematically 
 identical expressions may be computationally different because of errors 
 inherent in the floating-point approximation process.
  
 When the arguments to a function in this section are all rational and the 
 true mathematical result is also (mathematically) rational, then unless 
 otherwise noted an implementation is free to return either an accurate re-
 sult of type
  rational
  or a single-precision floating-point approximation. If 
 the arguments are all rational but the result cannot be expressed as a ra-
 tional number, then a single-precision floating-point approximation is 
 always returned.
  
 If the arguments to a function are all of type
  (or rational (complex 
 rational))
  and the true mathematical result is (mathematically) a complex",NA
12.5.1,NA,NA
Exponential and Logarithmic Functions,"Along with the usual one-argument and two-argument exponential and log-
 arithm functions,
  sqrt
  is considered to be an exponential function, because 
 it raises a number to the power 1/2.
  
 [Function]
  exp
  number
  
 Returns
  e
  raised to the power
  number
 , where
  e
  is the base of the natural 
 logarithms.
  
 [Function]
  expt
  base-number power-number
  
 Returns
  base-number
  raised to the power
  power-number
 . 
  
 If the
  base-
 number
  is of type
  rational
  and the
  power-number
  is an
  integer
 , the cal-
 culation will be exact and the result will be of type
  rational
 ; otherwise a 
 floating-point approximation may result.
  
 X3J13 voted in March 1989 to clarify that provisions similar to those of 
 the previous paragraph apply to complex numbers. If the
  base-number",NA
12.5.2 Trigonometric and Related Functions,"Some of the functions in this section, such as
  abs
  and
  signum
 , are apparently
  
 unrelated to trigonometric functions when considered as functions of real
  
 numbers only. The way in which they are extended to operate on complex
  
 numbers makes the trigonometric connection clear.
  
 [Function]
  abs
  number
  
 x
 ,
  
 Returns the absolute value of the argument. For a non-complex number
  
 (abs
  x
 )
  ≡
  (if (minusp
  x
 ) (-
  x
 )
  x
 )
  
 and the result is always of the same type as the argument.
  
 For a complex number
  z
 , the absolute value may be computed as
  
 (sqrt (+ (expt (realpart
  z
 ) 2) (expt (imagpart
  z
 ) 2)))
  
 Implementation note:
  The careful implementor will not use this formula directly 
 for all complex numbers but will instead handle very large or very small components 
 specially to avoid intermediate overflow or underflow. 
 For example:
  
 (abs #c(3.0 -4.0))
  ⟨
  5.0
  
 The result of
  (abs #c(3 4))
  may be either
  5
  or
  5.0
 , depending on the
  
 implementation.
  
 [Function]
  phase
  number
  
 The phase of a number is the angle part of its polar representation as a
  
 complex number. That is,",NA
12.5.3,NA,NA
"Branch Cuts, Principal Values, and Boundary",NA,NA
Conditions in the Complex Plane,"Many of the irrational and transcendental functions are multiply defined in 
 the complex domain; for example, there are in general an infinite number of 
 complex values for the logarithm function. In each such case, a principal 
 value must be chosen for the function to return. In general, such values 
 cannot be chosen so as to make the range continuous; lines in the domain 
 called
  branch cuts
  must be defined, which in turn define the discontinuities 
 in the range.
  
 Common Lisp defines the branch cuts, principal values, and boundary 
 conditions for the complex functions following a proposal for complex func-
 tions in APL [36]. The contents of this section are borrowed largely from 
 that proposal.
  
 Indeed, X3J13 voted in January 1989 to alter the direction of continuity 
 for the branch cuts of
  atan
 , and also to address the treatment of branch cuts 
 in implementations that have a distinct floating-point minus zero.
  
 The treatment of minus zero centers in two-argument
  atan
 . If there is 
 no minus zero, then the branch cut runs just below the negative real axis as 
 before, and the range of two-argument
  atan
  is (
 −π, π
 ]. If there is a minus 
 zero, however, then the branch cut runs precisely on the negative real axis, 
 skittering between pairs of numbers of the form
  −x ±
  0
 i
 , and the range of 
 two-argument
  atan
  is [
 −π, π
 ]. The treatment of minus zero by all other 
 irrational and transcenden-tal functions is then specified by defining those 
 functions in terms of two-argument
  atan
 . First,
  phase
  is defined in terms of 
 two-argument
  atan
 , and complex
  abs
  in terms of real
  sqrt
 ; then complex
  
 log
  is defined in terms of 
 phase
 ,
  abs
 , and real
  log
 ; then complex
  sqrt
  in 
 terms of complex
  log
 ; and finally all others are defined in terms of these.",NA
12.6 Type Conversions and Component Ex-,NA,NA
tractions on Numbers,"While most arithmetic functions will operate on any kind of number, coerc-
 ing types if necessary, the following functions are provided to allow specific 
 conversions of data types to be forced when desired.
  
 [Function]
  float
  number
  &optional
  other
  
 This converts any non-complex number to a floating-point number. 
 With no second argument, if
  number
  is already a floating-point number, 
 then
  num-ber
  is returned; otherwise a
  single-float
  is produced. If the 
 argument
  other 
 is provided, then it must be a floating-point number, and
  
 number
  is converted to the same format as
  other
 . See also
  coerce
 .
  
 [Function]
  rational
  number 
  
 [Function]
  rationalize
  number
  
 Each of these functions converts any non-complex number to a rational 
 number. If the argument is already rational, it is returned. The two 
 functions differ in their treatment of floating-point numbers.
  
 rational
  assumes that the floating-point number is completely accurate 
 and returns a rational number mathematically equal to the precise value of 
 the floating-point number.
  
 rationalize
  assumes that the floating-point number is accurate only to 
 the precision of the floating-point representation and may return any 
 rational number for which the floating-point number is the best available 
 approxima-tion of its format; in doing this it attempts to keep both 
 numerator and denominator small.
  
 It is always the case that
  
 (float (rational
  x
 )
  x
 )
  ≡ x",NA
12.7 Logical Operations on Numbers,"The logical operations in this section require integers as arguments; it is an 
 error to supply a non-integer as an argument. The functions all treat 
 integers as if they were represented in two’s- complement notation.
  
 Implementation note:
  Internally, of course, an implementation of Common Lisp 
 may or may not use a two’s-complement representation. All that is necessary is 
 that the logical operations perform calculations so as to give this appearance to 
 the user. 
 The logical operations provide a convenient way to represent an infinite 
 vector of bits. Let such a conceptual vector be indexed by the non-negative 
 integers. Then bit
  j
  is assigned a “weight” 2
 j
 . Assume that only a finite 
 number of bits are 1’s or only a finite number of bits are 0’s. A vector with 
 only a finite number of one-bits is represented as the sum of the weights of 
 the one-bits, a positive integer. A vector with only a finite number of zero-
 bits is represented as
  -1
  minus the sum of the weights of the zero-bits, a 
 negative integer.
  
 This method of using integers to represent bit-vectors can in turn be 
 used to represent sets. Suppose that some (possibly countably infinite) 
 universe",NA
12.8 Byte Manipulation Functions,"Several functions are provided for dealing with an arbitrary-width field of
  
 contiguous bits appearing anywhere in an integer. Such a contiguous set of
  
 bits is called a
  byte
 . Here the term
  byte
  does not imply some fixed number
  
 of bits (such as eight), rather a field of arbitrary and user-specifiable width.",NA
12.9,NA,NA
Random Numbers,"The Common Lisp facility for generating pseudo-random numbers has been 
 carefully defined to make its use reasonably portable. While two implemen-
 tations may produce different series of pseudo-random numbers, the distri-
 bution of values should be relatively independent of such machine-
 dependent aspects as word size.",NA
12.10 ,NA,NA
Implementation Parameters,"The values of the named constants defined in this section are 
 implementation-dependent. They may be useful for parameterizing code in 
 some situations.
  
 [Constant]
  most-positive-fixnum 
  
 [Constant]
  most-negative-fixnum
  
 The value of
  most-positive-fixnum
  is that fixnum closest in value to 
 positive infinity provided by the implementation.
  
 The value of
  most-negative-fixnum
  is that fixnum closest in value to 
 negative infinity provided by the implementation.
  
 X3J13 voted in January 1989 to specify that
  fixnum
  must be a supertype 
 of the type
  (signed-byte 16)
 , and additionally that the value of
  array-
 dimension-limit
  must be a fixnum. This implies that the value of
  most-
 negative-fixnum
  must be less than or equal to
  −
 2
 15
 , and the value of
  most-
 positive-fixnum
  must be greater than or equal to both 2
 15
 −
 1 and the value 
 of
  array-dimension-limit
 .
  
 [Constant]
  most-positive-short-float 
  
 [Constant]
  least-positive-short-float 
  
 [Constant]
  least-negative-short-float 
  
 [Constant]
  most-negative-short-float
  
 The value of
  most-positive-short-float
  is that short-format floating-
 point number closest in value to (but not equal to) positive infinity 
 provided by the implementation.
  
 The value of
  least-positive-short-float
  is that positive short-format 
 floating-point number closest in value to (but not equal to) zero provided 
 by the implementation.",NA
Chapter 13,NA,NA
Characters,"Common Lisp provides a character data type; objects of this type represent 
 printed symbols such as letters.
  
 In general, characters in Common Lisp are not true objects;
  eq
  cannot be 
 counted upon to operate on them reliably. In particular, it is possible that 
 the expression
  
 (let ((x z) (y z)) (eq x y))
  
 may be false rather than true, if the value of
  z
  is a character.
  
 Rationale:
  This odd breakdown of
  eq
  in the case of characters allows the imple- 
 mentor enough design freedom to produce exceptionally efficient code on conven- 
 tional architectures. In this respect the treatment of characters exactly parallels 
 that of numbers, as described in chapter 12. 
 If two objects are to be compared for “identity,” but either might be a 
 character, then the predicate
  eql
  is probably appropriate.",NA
13.1 Character Attributes,"[Constant]
  char-code-limit
  
 The value of
  char-code-limit
  is a non-negative integer that is the upper 
 exclusive bound on values produced by the function
  char-code
 , which re-
 turns the
  code
  component of a given character; that is, the values returned 
 by
  
 383",NA
13.2 Predicates on Characters,"The predicate
  characterp
  may be used to determine whether any Lisp 
 object is a character object.
  
 [Function]
  standard-char-p
  char
  
 The argument
  char
  must be a character object. 
 standard-char-p
  is true if 
 the argument is a “standard character,” that is, an object of type 
 standard-
 char
 .
  
 Note that any character with a non-zero bits or font attribute is non-
 standard.
  
 [Function]
  graphic-char-p
  char
  
 The argument
  char
  must be a character object.
  graphic-char-p
  is true if the 
 argument is a “graphic” (printing) character, and false if it is a “non-graphic” 
 (formatting or control) character. Graphic characters have a stan-dard 
 textual representation as a single glyph, such as
  A
  or
  *
  or
  =
 . 
  
 By 
 convention, the space character is considered to be graphic. Of the stan-dard 
 characters all but
  #\Newline
  are graphic. The semi-standard charac-ters
  
 #\Backspace
 ,
  #\Tab
 ,
  #\Rubout
 ,
  #\Linefeed
 ,
  #\Return
 , and 
 #\Page
  are 
 not graphic.
  
 [Function]
  alpha-char-p
  char
  
 The argument
  char
  must be a character object.
  alpha-char-p
  is true if the 
 argument is an alphabetic character, and otherwise is false.
  
 If a character is alphabetic, then it is perforce graphic. Therefore any 
 character with a non-zero bits attribute cannot be alphabetic. Whether a 
 character is alphabetic may depend on its font number.",NA
13.3 Character Construction and Selection,"These functions may be used to extract attributes of a character and to 
 construct new characters.
  
 [Function]
  char-code
  char
  
 The argument
  char
  must be a character object.
  char-code
  returns the 
 code attribute of the character object; this will be a non-negative integer 
 less than the (normal) value of the variable
  char-code-limit
 .
  
 This is usually what you need in order to treat a character as an index 
 into a vector. The length of the vector should then be equal to
  char-code-
 limit
 . Be careful how you initialize this vector; remember that you cannot 
 necessarily expect all non-negative integers less than
  char-code-limit
  to be 
 valid character codes.
  
 [Function]
  code-char
  code
  
  
 Returns a character with the code attribute given by code. If no such 
 character exists and one cannot be created, nil is returned. For example:
  
 (char= (code-char (char-code c)) c)",NA
13.4 Character Conversions,"These functions perform various transformations on characters, including 
 case conversions.
  
 [Function]
  character
  object
  
  
 The function
  character
  coerces its argument to be a character if 
 possible; see
  coerce
 .
  
 (character x)
  ≡
  (coerce x ’character)
  
 [Function]
  char-upcase
  char",NA
Chapter 14,NA,NA
Sequences,"The type
  sequence
  encompasses both lists and vectors (one-dimensional 
 arrays). While these are different data structures with different structural 
 properties leading to different algorithmic uses, they do have a common 
 prop-erty: each contains an ordered set of elements. Note that
  nil
  is 
 considered to be a sequence of length zero.
  
 Some operations are useful on both lists and arrays because they deal 
 with ordered sets of elements. One may ask the number of elements, 
 reverse the ordering, extract a subsequence, and so on. For such purposes 
 Common Lisp provides a set of generic functions on sequences.
  
 Note that this remark, predating the design of the Common Lisp Object 
 System, uses the term “generic” in a generic sense, and not necessarily in 
 the technical sense used by CLOS (see chapter 2).
  
 elt
  
 reverse
  
 map
  
 remove
  
 length
  
 nreverse
  
 some
  
 remove-duplicates
  
 subseq
  
 concatenate
  
 every
  
 delete
  
 copy-seq
  
 position
  
 notany
  
 delete-duplicates
  
 fill
  
 find
  
 notevery
  
 substitute
  
 replace
  
 sort
  
 reduce
  
 nsubstitute
  
 count
  
 merge
  
 search
  
 mismatch
  
 Some of these operations come in more than one version. Such versions are 
 indicated by adding a suffix (or occasionally a prefix) to the basic name of 
 the operation. In addition, many operations accept one or more optional 
 keyword arguments that can modify the operation in various ways.
  
 393",NA
14.1 Simple Sequence Functions,"Most of the following functions perform simple operations on a single se-
 quence;
  make-sequence
  constructs a new sequence.
  
 [Function]
  elt
  sequence index
  
 This returns the element of
  sequence
  specified by
  index
 , which must be a 
 non-negative integer less than the length of the
  sequence
  as returned by 
 length
 . The first element of a sequence has index
  0
 .
  
  
 (Note that
  elt
  observes the fill pointer in those vectors that have fill 
 point-ers. The array-specific function
  aref
  may be used to access vector 
 elements that are beyond the vector’s fill pointer.) 
  
  
 setf
  may be used with
  elt
  to destructively replace a sequence element 
 with a new value.
  
 [Function]
  subseq
  sequence start
  &optional
  end
  
 This returns the subsequence of
  sequence
  specified by
  start
  and
  end
 .
  
 sub-seq
  always
  allocates a new sequence for a result; it never shares 
 storage with an old sequence. The result subsequence is always of the same 
 type as the argument
  sequence
 .
  
  
 setf
  may be used with
  subseq
  to destructively replace a subsequence 
 with a sequence of new values; see also
  replace
 .
  
 [Function]
  copy-seq
  sequence
  
  
 A copy is made of the argument
  sequence
 ; the result is
  equalp
  to the 
 argument but not
  eq
  to it.
  
 (copy-seq
  x
 )
  ≡
  (subseq
  x
  0)
  
 but the name
  copy-seq
  is more perspicuous when applicable.
  
 [Function]
  length
  sequence
  
 The number of elements in
  sequence
  is returned as a non-negative 
 integer. If the sequence is a vector with a fill pointer, the “active length” as 
 specified by the fill pointer is returned (see section 17.5).",NA
"14.2 Concatenating, Mapping, and Reducing",NA,NA
Sequences,"The functions in this section each operate on an arbitrary number of se-
 quences except for
  reduce
 , which is included here because of its conceptual 
 relationship to the mapping functions.
  
 [Function]
  concatenate
  result-type
  &rest
  sequences
  
 The result is a new sequence that contains all the elements of all the 
 sequences in order. All of the sequences are copied from; the result does 
 not share any structure with any of the argument sequences (in this
  
 concatenate 
 differs from
  append
 ). The type of the result is specified by
  
 result-type
 , which must be a subtype of
  sequence
 , as for the function
  
 coerce
 . It must be possible for every element of the argument sequences to 
 be an element of a sequence of type
  result-type
 .
  
 If only one
  sequence
  argument is provided and it has the type specified 
 by 
 result-type
 ,
  concatenate
  is required to copy the argument rather than 
 simply returning it. If a copy is not required, but only possibly type 
 conversion, then the
  coerce
  function may be appropriate.
  
 X3J13 voted in June 1989 to specify that
  concatenate
  should signal an 
 error if the sequence type specifies the number of elements and the sum of 
 the argument lengths is different.
  
 [Function]
  map
  result-type function sequence
  &rest
  more-sequences
  
  
 The
  function
  must take as many arguments as there are sequences pro-
 vided; at least one sequence must be provided. 
  
 The result of
  map
  is a 
 sequence such that element
  j
  is the result of applying
  function
  to element 
 j
  of 
 each of the argument sequences. The result sequence is as long as the 
 shortest of the input sequences.
  
  
 If the
  function
  has side effects, it can count on being called first on all the 
 elements numbered
  0
 , then on all those numbered
  1
 , and so on.
  
 The type of the result sequence is specified by the argument
  result-type 
 (which must be a subtype of the type
  sequence
 ), as for the function
  coerce
 . 
 In addition, one may specify
  nil
  for the result type, meaning that no result 
 sequence is to be produced; in this case the
  function
  is invoked only for 
 effect, and
  map
  returns
  nil
 . This gives an effect similar to that of
  mapc
 .",NA
Modifying Sequences,CHAPTER 14. SEQUENCES,NA
14.3,"Each of these functions alters the contents of a sequence or produces an 
 altered copy of a given sequence.
  
 [Function]
  fill
  sequence item
  &key
  :start :end
  
 The
  sequence
  is destructively modified by replacing each element of the 
 subsequence specified by the
  :start
  and
  :end
  parameters with the
  item
 . The 
 item
  may be any Lisp object but must be a suitable element for the
  sequence
 . 
 The
  item
  is stored into all specified components of the
  sequence
 , beginning 
 at the one specified by the
  :start
  index (which defaults to zero), up to but 
 not including the one specified by the
  :end
  index (which defaults to the 
 length of the sequence).
  fill
  returns the modified
  sequence
 . For example:
  
 (setq x (vector ’a ’b ’c ’d ’e))
  ⟨
  #(a b c d e) 
  
 (fill x ’z
  :start
  1
  :end
  3)
  ⟨
  #(a z z d e) 
  
 and now x
  ⟨
  #(a z z d e) 
  
 (fill x ’p)
  ⟨
  #(p p p p p) 
  
 and now x
  ⟨
  #(p p p p p)
  
 [Function]
  replace
  sequence1 sequence2
  &key
  :start1 :end1 :start2 :end2
  
 The sequence
  sequence1
  is destructively modified by copying successive 
 elements into it from
  sequence2
 . The elements of
  sequence2
  must be of a 
 type that may be stored into
  sequence1
 . The subsequence of
  sequence2
  
 specified by
  :start2
  and
  :end2
  is copied into the subsequence of
  sequence1
  
 specified by
  :start1
  and
  :end1
 . (The arguments
  :start1
  and
  :start2
  default 
 to zero. The arguments
  :end1
  and
  :end2
  default to
  nil
 , meaning the end of 
 the appropriate sequence.) If these subsequences are not of the same 
 length, then the shorter length determines how many elements are copied; 
 the extra elements near the end of the longer subsequence are not involved 
 in the operation. The number of elements copied may be expressed as:
  
 (min (-
  end1 start1
 ) (-
  end2 start2
 ))
  
 The value returned by
  replace
  is the modified
  sequence1
 .
  
 If
  sequence1
  and
  sequence2
  are the same (
 eq
 ) object and the region be-
 ing modified overlaps the region being copied from, then it is as if the entire 
 source region were copied to another place and only then copied back into",NA
14.4 Searching Sequences for Items,"Each of these functions searches a sequence to locate one or more elements 
 satisfying some test.
  
 [Function]
  find
  item sequence
  &key
  :from-end :test :test-not :start :end :key 
  
 [Function]
  find-if
  predicate sequence
  &key
  :from-end :start :end :key 
 [Function]
  find-if-not
  predicate sequence
  &key
  :from-end :start :end :key
  
  
 If the
  sequence
  contains an element satisfying the test, then the leftmost 
 such element is returned; otherwise
  nil
  is returned.
  
  
 If
  :start
  and
  :end
  keyword arguments are given, only the specified sub-
 sequence of
  sequence
  is searched.
  
  
 If a non-
 nil :from-end
  keyword argument is specified, then the result is 
 the
  rightmost
  element satisfying the test.
  
 X3J13 voted in January 1989 to restrict user side effects; see section 7.9.
  
 [Function]
  position
  item sequence
  &key
  :from-end :test :test-not 
  
 :start :end :key 
  
 [Function]
  position-if
  predicate sequence
  &key
  :from-end :start :end :key 
 [Function]
  position-if-not
  predicate sequence
  &key
  :from-end 
  
 :start :end :key
  
 If the
  sequence
  contains an element satisfying the test, then the index 
 within the sequence of the leftmost such element is returned as a non-
 negative integer; otherwise
  nil
  is returned.
  
 If
  :start
  and
  :end
  keyword arguments are given, only the specified sub-
 sequence of
  sequence
  is searched. However, the index returned is relative to 
 the entire sequence, not to the subsequence.
  
  
 If a non-
 nil :from-end
  keyword argument is specified, then the result is 
 the index of the
  rightmost
  element satisfying the test. (The index returned, 
 however, is an index from the left-hand end, as usual.) 
  
  
 X3J13 voted in January 1989 to restrict user side effects; see section 7.9.
  
 Here is a simple piece of code that uses several of the sequence 
 functions, notably
  position-if
  and
  find-if
 , to process strings. Note one use 
 of
  loop
  as well.",NA
14.5 Sorting and Merging,"These functions may destructively modify argument sequences in order to 
 put a sequence into sorted order or to merge two already sorted sequences.
  
 [Function]
  sort
  sequence predicate
  &key
  :key 
  
 [Function]
  stable-sort
  sequence predicate
  &key
  :key",NA
Chapter 15,NA,NA
Lists,"A
  cons
 , or dotted pair, is a compound data object having two components 
 called the
  car
  and
  cdr
 . Each component may be any Lisp object. A
  list
  is a 
 chain of conses linked by
  cdr
  fields; the chain is terminated by some atom (a 
 non-cons object). An ordinary list is terminated by
  nil
 , the empty list (also 
 written ()). A list whose
  cdr
  chain is terminated by some non-
 nil
  atom is 
 called a
  dotted list
 .
  
 The recommended predicate for testing for the end of a list is
  endp
 .",NA
15.1 Conses,"These are the basic operations on conses viewed as pairs rather than as the 
 constituents of a list.
  
 [Function]
  car
  list
  
 This returns the
  car
  of
  list
 , which must be a cons or (); that is,
  list
  must 
 satisfy the predicate
  listp
 . By definition, the
  car
  of () is (). If the cons is 
 regarded as the first cons of a list, then
  car
  returns the first element of the 
 list. For example:
  
 (car ’(a b c))
  ⟨
  a
  
 See
  first
 . The
  car
  of a cons may be altered by using
  rplaca
  or
  setf
 .
  
 417",NA
15.2 Lists,"The following functions perform various operations on lists.
  
  
 The list is one of the original Lisp data types. The very name “Lisp” is an 
 abbreviation for “LISt Processing.”
  
 [Function]
  endp
  object
  
  
 The predicate
  endp
  is the recommended way to test for the end of a list. 
 It is false of conses, true of
  nil
 , and an error for all other arguments.
  
 Implementation note:
  Implementations are encouraged to signal an error, espe- 
 cially in the interpreter, for a non-list argument. The
  endp
  function is defined so 
 as to allow compiled code to perform simply an atom check or a null check if speed 
 is more important than safety. 
 [Function]
  list-length
  list
  
 list-length
  returns, as an integer, the length of
  list
 .
  list-length
  differs 
 from
  length
  when the
  list
  is circular;
  length
  may fail to return, whereas 
 list-length
  will return
  nil
 . For example:
  
 (list-length ’())
  ⟨
  0 
  
 (list-length ’(a b c d))
  ⟨
  4 
  
 (list-length ’(a (b c) d))
  ⟨
  3 
 (let ((x (list ’a b c))) 
  
 (rplacd (last x) x) 
  
 (list-length x))
  ⟨
  nil
  
 list-length
  could be implemented as follows:",NA
15.3 Alteration of List Structure,"The functions
  rplaca
  and
  rplacd
  may be used to make alterations in 
 already existing list structure, that is, to change the
  car
  or
  cdr
  of an existing 
 cons. One may also use
  setf
  in conjunction with
  car
  and
  cdr
 .
  
 The structure is not copied but is destructively altered; hence caution 
 should be exercised when using these functions, as strange side effects can 
 occur if portions of list structure become shared. The
  nconc
 ,
  nreverse
 , 
 nreconc
 , and
  nbutlast
  functions, already described, have the same prop-
 erty, as do certain of the generic sequence functions such as
  delete
 . 
 However, they are normally not used for this side effect; rather, the list-
 structure mod-ification is purely for efficiency, and compatible non-
 modifying functions are provided.
  
 [Function]
  rplaca
  x y
  
 (rplaca
  x y
 )
  changes the
  car
  of
  x
  to
  y
  and returns (the modified)
  x
 .
  x 
 must be 
 a cons, but
  y
  may be any Lisp object. For example:
  
 (setq g ’(a b c)) 
  
 (rplaca (cdr g) ’d)
  ⟨
  (d c) 
  
 Now g
  ⟨
  (a d c)
  
 [Function]
  rplacd
  x y
  
 (rplacd
  x y
 )
  changes the
  cdr
  of
  x
  to
  y
  and returns (the modified)
  x
 .
  x 
 must be 
 a cons, but
  y
  may be any Lisp object. For example:",NA
15.4 Substitution of Expressions,"A number of functions are provided for performing substitutions within a 
 tree. All take a tree and a description of old subexpressions to be replaced 
 by new ones. They come in non-destructive and destructive varieties and 
 specify substitution either by two arguments or by an association list.
  
 The naming conventions for these functions and for their keyword argu-
 ments generally follow the conventions for the generic sequence functions. 
 See chapter 14.
  
 [Function]
  subst
  new old tree
  &key
  :test :test-not :key 
 [Function]
  subst-if
  new test tree
  &key
  :key 
  
 [Function]
  subst-if-not
  new test tree
  &key
  :key
  
 (subst
  new old tree
 )
  makes a copy of
  tree
 , substituting
  new
  for every 
 subtree or leaf of
  tree
  (whether the subtree or leaf is a
  car
  or a
  cdr
  of its 
 parent) such that
  old
  and the subtree or leaf satisfy the test. It returns the 
 modified copy of
  tree
 . The original
  tree
  is unchanged, but the result tree 
 may share with parts of the argument
  tree
 .
  
 For example:
  
 (subst ’tempest ’hurricane
  
  
 ’(shakespeare wrote (the hurricane)))
  
 ⟨
  (shakespeare wrote (the tempest))
  
 (subst ’foo ’
 nil
  ’(shakespeare wrote (twelfth night)))",NA
15.5 Using Lists as Sets,"Common Lisp includes functions that allow a list of items to be treated as a 
 set
 . There are functions to add, remove, and search for items in a list, based 
 on various criteria. There are also set union, intersection, and difference 
 functions.
  
 The naming conventions for these functions and for their keyword argu-
 ments generally follow the conventions that apply to the generic sequence 
 functions. See chapter 14.
  
 [Function]
  member
  item list
  &key
  :test :test-not :key 
 [Function]
  member-if
  predicate list
  &key
  :key 
  
 [Function]
  member-if-not
  predicate list
  &key
  :key
  
 The
  list
  is searched for an element that satisfies the test. If none is found, 
 nil
  is returned; otherwise, the tail of
  list
  beginning with the first element 
 that",NA
15.6 Association Lists,"An
  association list
 , or
  a-list
 , is a data structure used very frequently in Lisp. 
 An a-list is a list of pairs (conses); each pair is an association. The
  car
  of a 
 pair is called the
  key
 , and the
  cdr
  is called the
  datum
 .
  
 An advantage of the a-list representation is that an a-list can be incre-
 mentally augmented simply by adding new entries to the front. Moreover, 
 because the searching function
  assoc
  searches the a-list in order, new 
 entries can “shadow” old entries. If an a-list is viewed as a mapping from 
 keys to data, then the mapping can be not only augmented but also altered 
 in a non-destructive manner by adding new entries to the front of the a-list.
  
 Sometimes an a-list represents a bijective mapping, and it is desirable to 
 retrieve a key given a datum. For this purpose, the “reverse” searching func-
 tion
  rassoc
  is provided. Other variants of a-list searches can be constructed 
 using the function
  find
  or
  member
 .",NA
Chapter 16,NA,NA
Hash Tables,"A hash table is a Lisp object that can efficiently map a given Lisp object to 
 another Lisp object. Each hash table has a set of
  entries
 , each of which 
 associates a particular
  key
  with a particular
  value
 . The basic functions that 
 deal with hash tables can create entries, delete entries, and find the value 
 that is associated with a given key. Finding the value is very fast, even if 
 there are many entries, because hashing is used; this is an important 
 advantage of hash tables over property lists.
  
 A given hash table can associate only one
  value
  with a given
  key
 ; if you 
 try to add a second
  value
 , it will replace the first. Also, adding a value to a 
 hash table is a destructive operation; the hash table is modified. By contrast, 
 association lists can be augmented non-destructively.
  
 Hash tables come in three kinds, the difference being whether the keys 
 are compared with
  eq
 ,
  eql
 , or
  equal
 . In other words, there are hash tables 
 that hash on Lisp
  objects
  (using
  eq
  or
  eql
 ) and there are hash tables that 
 hash on
  tree structure
  (using
  equal
 ).
  
 Hash tables are created with the function
  make-hash-table
 , which 
 takes various options, including which kind of hash table to make (the 
 default being the
  eql
  kind). To look up a key and find the associated value, 
 use
  gethash
 . New entries are added to hash tables using
  setf
  with
  gethash
 . 
 To remove an entry, use
  remhash
 . Here is a simple example.
  
 (setq a (make-hash-table)) 
  
 (setf (gethash ’color a) ’brown) 
  
 (setf (gethash ’name a) ’fred) 
  
 (gethash ’color a)
  ⟨
  brown
  
 441",NA
16.1 Hash Table Functions,"This section documents the functions for hash tables, which use
  objects
  as 
 keys and associate other objects with them.
  
 [Function]
  make-hash-table
  &key
  :test :size :rehash-size 
 :rehash-threshold
  
 This function creates and returns a new hash table. The
  :test
  argument 
 determines how keys are compared; it must be one of the three values
  #’eq
 , 
 #’eql
 , or
  #’equal
 , or one of the three symbols
  eq
 ,
  eql
 , or
  equal
 . If no test is 
 specified,
  eql
  is assumed.
  
 X3J13 voted in January 1989 to add a fourth type of hash table: the value 
 of
  #’equalp
  and the symbol
  equalp
  are to be additional valid possibilities 
 for the
  :test
  argument.
  
 Note that one consequence of the vote to change the rules of floating-
 point contagion (described in section 12.1) is to require
  =
 , and therefore 
 also 
 equalp
 , to compare the values of numbers exactly and not 
 approximately, making
  equalp
  a true equivalence relation on numbers.
  
  
 Another valuable use of
  equalp
  hash tables is case-insensitive 
 comparison of keys that are strings.",NA
16.2 Primitive Hash Function,"The function
  sxhash
  is a convenient tool for the user who needs to create 
 more complicated hashed data structures than are provided by
  hash-table 
 objects.
  
 [Function]
  sxhash
  object
  
 sxhash
  computes a hash code for an object and returns the hash code as 
 a non-negative fixnum. A property of
  sxhash
  is that
  (equal
  x y
 )
  implies 
 (= 
 (sxhash
  x
 ) (sxhash
  y
 ))
 .
  
 The manner in which the hash code is computed is implementation-
 dependent but independent of the particular “incarnation” or “core 
 image.”Hash values produced by
  sxhash
  may be written out to files, for 
 example, and meaningfully read in again into an instance of the same 
 implementation.",NA
Chapter 17,NA,NA
Arrays,"An array is an object with components arranged according to a rectilinear 
 coordinate system. In principle, an array in Common Lisp may have any 
 number of dimensions, including zero. (A zero-dimensional array has 
 exactly one element.) In practice, an implementation may limit the number 
 of di-mensions supported, but every Common Lisp implementation must 
 support arrays of up to seven dimensions. Each dimension is a non-negative 
 integer; if any dimension of an array is zero, the array has no elements.
  
 An array may be a
  general array
 , meaning each element may be any Lisp 
 object, or it may be a
  specialized array
 , meaning that each element must be 
 of a given restricted type.",NA
17.1 Array Creation,"Do not be daunted by the many options of the function
  make-array
 . All that 
 is required to construct an array is a list of the dimensions; most of the 
 options are for relatively esoteric applications.
  
 [Function]
  make-array
  dimensions
  &key
  :element-type :initial-element 
 :initial-contents :adjustable :fill-pointer :displaced-to :displaced-index-offset
  
 This is the primitive function for making arrays. The
  dimensions
  argu-
 ment should be a list of non-negative integers that are to be the dimensions 
 of the array; the length of the list will be the dimensionality of the array. 
 Each dimension must be smaller than
  array-dimension-limit
 , and the 
 product of all the dimensions must be smaller than
  array-total-size-limit
 . 
 Note
  
 449",NA
17.2 Array Access,"The function
  aref
  is normally used for accessing an element of an array. 
 Other access functions, such as
  svref
 ,
  char
 , and
  bit
 , may be more efficient 
 in specialized circumstances.
  
 [Function]
  aref
  array
  &rest
  subscripts
  
 This accesses and returns the element of
  array
  specified by the
  
 subscripts
 . The number of subscripts must equal the rank of the array, and 
 each subscript must be a non-negative integer less than the corresponding 
 array dimension.
  
  
 aref
  is unusual among the functions that operate on arrays in that it 
 completely ignores fill pointers. 
 aref
  can access without error any array 
 element, whether active or not. The generic sequence function
  elt
 , however,",NA
17.3 Array Information,"The following functions extract from an array interesting information other 
 than the elements.",NA
17.4 Functions on Arrays of Bits,"The functions described in this section operate only on arrays of bits, that is, 
 specialized arrays whose elements are all
  0
  or
  1
 .
  
 [Function]
  bit
  bit-array
  &rest
  subscripts 
  
 [Function]
  sbit
  simple-bit-array
  &rest
  subscripts
  
 bit
  is exactly like
  aref
  but requires an array of bits, that is, one of type 
 (array bit)
 . The result will always be
  0
  or
  1
 .
  sbit
  is like
  bit
  but additionally 
 requires that the first argument be a
  simple
  array (see section 2.5). Note 
 that 
 bit
  and
  sbit
 , unlike
  char
  and
  schar
 , allow the first argument to be an 
 array of any rank.
  
  
 setf
  may be used with
  bit
  or
  sbit
  to destructively replace a bit-array 
 element with a new value.
  
 bit
  and
  sbit
  are identical to
  aref
  except for the more specific type re-
 quirements on the first argument. In some implementations of Common 
 Lisp, 
 bit
  may be faster than
  aref
  in situations where it is applicable, and
  
 sbit
  may similarly be faster than
  bit
 .",NA
17.5 Fill Pointers,"Several functions for manipulating a
  fill pointer
  are provided in Common 
 Lisp to make it easy to incrementally fill in the contents of a vector and, 
 more generally, to allow efficient varying of the length of a vector. For 
 example, a string with a fill pointer has most of the characteristics of a PL/I 
 varying string.
  
 The fill pointer is a non-negative integer no larger than the total number 
 of elements in the vector (as returned by
  array-dimension
 ); it is the 
 number of “active” or “filled-in” elements in the vector. The fill pointer 
 constitutes the“active length” of the vector; all vector elements whose index 
 is less than the fill pointer are active, and the others are inactive. Nearly all 
 functions that operate on the contents of a vector will operate only on the 
 active elements. An important exception is
  aref
 , which can be used to 
 access any vector element whether in the active region of the vector or not. 
 It is important to note that vector elements not in the active region are still 
 considered part of the vector.
  
 Implementation note:
  An implication of this rule is that vector elements outside 
 the active region may not be garbage-collected.",NA
17.6 Changing the Dimensions of an Array,"This function may be used to resize or reshape an array. Its options are 
 similar to those of
  make-array
 .
  
 [Function]
  adjust-array
  array new-dimensions
  &key
  :element-type 
 :initial-element :initial-contents :fill-pointer :displaced-to 
  
 :displaced-index-offset
  
 adjust-array
  takes an array and a number of other arguments as for 
 make-array
 . The number of dimensions specified by
  new-dimensions
  must 
 equal the rank of
  array
 .
  
 adjust-array
  returns an array of the same type and rank as
  array
 , with 
 the specified
  new-dimensions
 . In effect, the
  array
  argument itself is modified 
 to conform to the new specifications, but this may be achieved either by 
 modifying the
  array
  or by creating a new array and modifying the
  array 
 argument to be
  displaced
  to the new array.
  
  
 In the simplest case, one specifies only the
  new-dimensions
  and possibly 
 an
  :initial-element
  argument. 
  
 Those elements of
  array
  that are still in 
 bounds appear in the new array. The elements of the new array that are not 
 in the bounds of
  array
  are initialized to the
  :initial-element
 ; if this 
 argument is not provided, then the initial contents of any new elements are 
 undefined.",NA
Chapter 18,NA,NA
Strings,"A string is a specialized vector (one-dimensional array) whose elements are 
 characters.
  
 X3J13 voted in March 1989 to eliminate the type
  string-char
  and to 
 redefine the type
  string
  to be the union of one or more specialized vector 
 types, the types of whose elements are subtypes of the type
  character
 .
  
 Any string-specific function defined in this chapter whose name begins 
 with the prefix
  string
  will accept a symbol instead of a string as an argu-
 ment
  provided
  that the operation never modifies that argument; the print 
 name of the symbol is used. In this respect the string-specific sequence 
 oper-ations are not simply specializations of generic versions; the generic 
 sequence operations described in chapter 14 never accept symbols as 
 sequences. This slight inelegance is permitted in Common Lisp in the name 
 of pragmatic utility. One may get the effect of having a generic sequence 
 function operate on either symbols or strings by applying the coercion 
 function
  string
  to any argument whose data type is in doubt.
  
 Note that this remark, predating the design of the Common Lisp Object 
 System, uses the term “generic” in a generic sense and not necessarily in the 
 technical sense used by CLOS (see chapter 2).
  
 Also, there is a slight non-parallelism in the names of string functions. 
 Where the suffixes
  equalp
  and
  eql
  would be more appropriate, for 
 historical compatibility the suffixes
  equal
  and
  =
  are used instead to indicate 
 case-insensitive and case-sensitive character comparison, respectively.
  
 Any Lisp object may be tested for being a string by the predicate
  stringp
 .
  
 Note that strings, like all vectors, may have fill pointers (though such 
 strings are not necessarily
  simple
 ). String operations generally operate only
  
 469",NA
18.1 String Access,"The following functions access a single character element of a string.
  
 [Function]
  char
  string index 
  
 [Function]
  schar
  simple-string index
  
 The given
  index
  must be a non-negative integer less than the length of 
 string
 , which must be a string. The character at position
  index
  of the string 
 is returned as a character object.
  
  
 As with all sequences in Common Lisp, indexing is zero-origin. For ex-
 ample:
  
 (char ""Floob-Boober-Bab-Boober-Bubs"" 0)
  ⟨
  #\F 
 (char ""Floob-Boober-Bab-Boober-Bubs"" 1)
  ⟨
  #\l
  
 See
  aref
  and
  elt
 . In effect,
  
 (char s j)
  ≡
  (aref (the string s) j)
  
  
 setf
  may be used with
  char
  to destructively replace a character within a 
 string.
  
 For
  char
 , the string may be any string; for
  schar
 , it must be a simple 
 string. In some implementations of Common Lisp, the function
  schar
  may 
 be faster than
  char
  when it is applicable.",NA
18.2 String Comparison,"The naming conventions for these functions and for their keyword 
 arguments generally follow the conventions for the generic sequence 
 functions (see chap-ter 14).
  
 Note that this remark, predating the design of the Common Lisp Object 
 System, uses the term “generic” in a generic sense and not necessarily in the 
 technical sense used by CLOS (see chapter 2).",NA
18.3 String Construction and Manipulation,"Most of the interesting operations on strings may be performed with the 
 generic sequence functions described in chapter 14. The following functions 
 perform additional operations that are specific to strings.
  
 Note that this remark, predating the design of the Common Lisp Object 
 System, uses the term “generic” in a generic sense and not necessarily in the 
 technical sense used by CLOS (see chapter 2).
  
 [Function]
  make-string
  size
  &key
  :initial-element :element-type
  
 This returns a simple string of length
  size
 , each of whose characters has been 
 initialized to the
  :initial-element
  argument. 
  
 If an
  :initial-
 element
  argument is not specified, then the string will be initialized in an 
 implementation-dependent way.
  
 The
  :element-type
  argument names the type of the elements of the 
 string; a string is constructed of the most specialized type that can accom-
 modate elements of the given type. If
  :element-type
  is omitted, the type 
 character
  is the default.
  
 X3J13 voted in January 1989 to clarify that the
  size
  argument must be a non-
 negative integer less than the value of
  array-dimension-limit
 .
  
 [Function]
  string-trim
  character-bag string 
  
 [Function]
  string-left-trim
  character-bag string 
 [Function]
  string-right-trim
  character-bag string
  
 string-trim
  returns a substring of
  string
 , with all characters in
  
 character-bag
  stripped off the beginning and end. The function
  string-left-
 trim
  is sim-ilar but strips characters off only the beginning;
  string-right-
 trim
  strips off only the end. The argument
  character-bag
  may be any 
 sequence containing characters. For example:
  
 (string-trim ’(#\Space #\Tab #\Newline) "" garbanzo beans
  
 (string-trim "" (*)"" "" ( *three (silly) words* ) "") "")
  ⟨
  ""garbanzo beans""
  
 ⟨
  ""three (silly) words""",NA
Chapter 19,NA,NA
Structures,"Common Lisp provides a facility for creating named record structures with 
 named components. In effect, the user can define a new data type; every 
 data structure of that type has components with specified names. 
 Constructor, access, and assignment constructs are automatically defined 
 when the data type is defined.
  
 This chapter is divided into two parts. The first part discusses the basics 
 of the structure facility, which is very simple and allows the user to take 
 advantage of the type-checking, modularity, and convenience of user-
 defined record data types. The second part, beginning with section 19.5, 
 discusses a number of specialized features of the facility that have advanced 
 applications. These features are completely optional, and you needn’t even 
 know they exist in order to take advantage of the basics.",NA
19.1 Introduction to Structures,"The structure facility is embodied in the
  defstruct
  macro, which allows the 
 user to create and use aggregate data types with named elements. These 
 are like “structures” in PL/I, or “records” in Pascal.
  
 As an example, assume you are writing a Lisp program that deals with 
 space ships in a two-dimensional plane. In your program, you need to rep-
 resent a space ship by a Lisp object of some kind. The interesting things 
 about a space ship, as far as your program is concerned, are its position 
 (rep-resented as
  x
  and
  y
  coordinates), velocity (represented as components 
 along the
  x
  and
  y
  axes), and mass.
  
 477",NA
19.2 How to Use Defstruct,"All structures are defined through the
  defstruct
  construct. A call to
  def-
 struct
  defines a new data type whose instances have named slots.
  
 [Macro]
  defstruct
  name-and-options [doc-string] {slot-description}*
  
  
 This defines a record-structure data type. A general call to
  defstruct 
 looks like the following example.
  
 (defstruct (
 name option-1 option-2
  ...
  option-m
 ) 
 doc-string 
  
 slot-description-1 
  
 slot-description-2 
  
 ...
  
 slot-description-n
 )
  
 The
  name
  must be a symbol; it becomes the name of a new data type 
 consisting of all instances of the structure. The function
  typep
  will accept 
 and use this name as appropriate. The
  name
  is returned as the value of the 
 defstruct
  form.
  
 Usually no options are needed at all. If no options are specified, then one 
 may write simply
  name
  instead of
  (
 name
 )
  after the word
  defstruct
 . The 
 syntax of options and the options provided are discussed in section 19.5.",NA
19.3 Using the Automatically Defined Con-,NA,NA
structor Function,"After you have defined a new structure with
  defstruct
 , you can create in-
 stances of this structure by using the constructor function. By default,
  def-
 struct
  defines this function automatically. For a structure named
  foo
 , the 
 constructor function is normally named
  make-foo
 ; you can specify a differ-
 ent name by giving it as the argument to the
  :constructor
  option, or specify 
 that you don’t want a normal constructor function at all by using
  nil
  as the 
 argument (in which case one or more “by-position” constructors should be 
 requested; see section 19.6).
  
 A call to a constructor function, in general, has the form
  
 (
 name-of-constructor-function 
  
 slot-keyword-1 form-1 
  
 slot-keyword-2 form-2 
  
 ...)
  
 All arguments are keyword arguments. Each
  slot-keyword
  should be a 
 keyword whose name matches the name of a slot of the structure 
 (
 defstruct 
 determines the possible keywords simply by interning each slot-
 name in the keyword package). All the
  keywords
  and
  forms
  are evaluated. In 
 short, it is just as if the constructor function took all its arguments as
  &key
  
 parameters. For example, the
  ship
  structure shown in section 19.1 has a 
 constructor function that takes arguments roughly as if its definition were
  
 (defun make-ship (&key x-position y-position 
  
  
 x-velocity y-velocity mass) 
  
 ...)
  
 If
  slot-keyword-j
  names a slot, then that element of the created structure 
 will be initialized to the value of
  form-j
 . If no pair
  slot-keyword-j
  and
  form-j 
 is present for a given slot, then the slot will be initialized by evaluating the 
 default-init
  form specified for that slot in the call to
  defstruct
 . (In other 
 words, the initialization specified in the
  defstruct
  defers to any specified in 
 a call to the constructor function.) If the default initialization form is used, it 
 is evaluated at construction time, but in the lexical environment of the
  
 defstruct
  form in which it appeared. If the
  defstruct
  itself also did not 
 specify any initialization, the element’s initial value is undefined. You 
 should",NA
19.4 Defstruct Slot-Options,"Each
  slot-description
  in a
  defstruct
  form may specify one or more slot-
 options. A slot-option consists of a pair of a keyword and a value (which is 
 not a form to be evaluated, but the value itself). For example:
  
 (defstruct ship 
  
 (x-position 0.0
  :type
  short-float) 
  
 (y-position 0.0
  :type
  short-float) 
  
 (x-velocity 0.0
  :type
  short-float) 
  
 (y-velocity 0.0
  :type
  short-float) 
  
 (mass *default-ship-mass*
  :type
  short-float
  :read-only
  t))
  
 This specifies that each slot will always contain a short-format floating-
 point number, and that the last slot may not be altered once a ship is con-
 structed.
  
 The available slot-options are as follows.",NA
19.5 Defstruct Options,"The preceding description of
  defstruct
  is all that the average user will need 
 (or want) to know in order to use structures. The remainder of this chapter 
 discusses more complex features of the
  defstruct
  facility.
  
 This section explains each of the options that can be given to
  defstruct
 . 
 A
  defstruct
  option may be either a keyword or a list of a keyword and 
 arguments for that keyword. (Note that the syntax for
  defstruct
  options 
 differs from the pair syntax used for slot-options. No part of any of these 
 options is evaluated.)
  
 :conc-name
  This provides for automatic prefixing of names of access func-
 tions. It is conventional to begin the names of all the access functions 
 of a structure with a specific prefix, the name of the structure followed 
 by a hyphen. This is the default behavior.
  
 The argument to the
  :conc-name
  option specifies an alternative 
 prefix to be used. (If a hyphen is to be used as a separator, it must be 
 specified as part of the prefix.) If
  nil
  is specified as an argument, then
  
 no
  prefix is used; then the names of the access functions are the same 
 as the slot-names, and it is up to the user to name the slots 
 reasonably.",NA
19.6 By-Position Constructor Functions,"If the
  :constructor
  option is given as
  (:constructor
  name arglist
 )
 , then 
 instead of making a keyword-driven constructor function,
  defstruct
  defines 
 a “positional” constructor function, taking arguments whose meaning is de-
 termined by the argument’s position rather than by a keyword. 
  
 The
  ar-
 glist
  is used to describe what the arguments to the constructor will be. In the 
 simplest case something like
  (:constructor make-foo (a b c))
  defines 
 make-foo
  to be a three-argument constructor function whose arguments 
 are used to initialize the slots named
  a
 ,
  b
 , and
  c
 .
  
 In addition, the keywords
  &optional
 ,
  &rest
 , and
  &aux
  are recognized 
 in the argument list. They work in the way you might expect, but there are a 
 few fine points worthy of explanation. Consider this example:
  
 (
 :constructor
  create-foo 
  
 (a &optional b (c ’sea) &rest d &aux e (f ’eff)))
  
 This defines
  create-foo
  to be a constructor of one or more arguments. 
 The first argument is used to initialize the
  a
  slot. The second argument is 
 used to initialize the
  b
  slot. If there isn’t any second argument, then the 
 default value given in the body of the
  defstruct
  (if given) is used instead. 
 The third argument is used to initialize the
  c
  slot. If there isn’t any third 
 argument, then the symbol
  sea
  is used instead. Any arguments following 
 the third argument are collected into a list and used to initialize the
  d
  slot. If 
 there are three or fewer arguments, then
  nil
  is placed in the
  d
  slot. The 
 e
  
 slot
  is not initialized
 ; its initial value is undefined. Finally, the
  f
  slot is 
 initialized to contain the symbol
  eff
 .",NA
19.7 Structures of Explicitly Specified Repre-,NA,NA
sentational Type,"Sometimes it is important to have explicit control over the representation 
 of a structure. The
  :type
  option allows one to specify that a structure must 
 be implemented in a particular way, using a list or a specific kind of vector, 
 and to specify the exact allocation of structure slots to components of the 
 representation. A structure may also be “unnamed” or “named,” according 
 to whether the structure name is stored in (and thus recoverable from) the 
 structure.",NA
19.7.1 Unnamed Structures,"Sometimes a particular data representation is imposed by external require-
 ments, and yet it is desirable to document the data format as a
  defstruct
 -
 style structure. For example, consider expressions built up from numbers, 
 symbols, and binary operations such as
  +
  and
  *
 . An operation might be 
 represented as it is in Lisp, as a list of the operator and the two operands.
  
 This fact can be expressed succinctly with
  defstruct
  in this manner: е
  
 (defstruct (binop (:type list)) 
  
 (operator ’? :type symbol)",NA
19.7.2 Named Structures,"A “named” structure has the property that, given an instance of the 
 structure, the structure name (that names the type) can be reliably 
 recovered. For structures defined with no
  :type
  option, the structure name 
 actually becomes part of the Common Lisp data-type system. The function
  
 type-of
 , when applied to such a structure, will return the structure name as 
 the type of the",NA
19.7.3 Other Aspects of Explicitly Specified Structures,"The
  :initial-offset
  option allows one to specify that slots be allocated be-
 ginning at a representational element other than the first. For example, the 
 form
  
 (defstruct (binop (:type list) (:initial-offset 2)) 
 (operator ’? :type symbol) 
  
 operand-1 
  
 operand-2)
  
 would result in the following behavior for
  make-binop
 :
  
 (make-binop :operator ’+ :operand-1 ’x :operand-2 
 5)
 ⟨
  (nil nil + x 5)
  
 (make-binop :operand-2 4 :operator ’*)
  
 ⟨
  (nil nil *
  nil
  4)
  
  
 The selectors 
 binop-operator
 , 
 binop-operand-1
 , 
  
 and 
  
 binop-
 operand-2
  would be essentially equivalent to
  caddr
 ,
  cadddr
 , and
  car
  of 
 cddddr
 , respectively. Similarly, the form
  
 (defstruct (binop (:type list) :named (:initial-offset 2)) 
 (operator ’? :type symbol) 
  
 operand-1 
  
 operand-2)
  
 would result in the following behavior for
  make-binop
 :
  
 (make-binop :operator ’+ :operand-1 ’x :operand-2 
 5)
 ⟨
  (nil nil binop + x 5)
  
 (make-binop :operand-2 4 :operator ’*)
  
 ⟨
  (nil nil binop *
  nil
  4)",NA
Chapter 20,NA,NA
Evaluator,"The mechanism that executes Lisp programs is called the evaluator. More 
 precisely, the evaluator accepts a form and performs the computation 
 speci-fied by the form. This mechanism is made available to the user 
 through the function
  eval
 .
  
 The evaluator is typically implemented as an interpreter that traverses 
 the given form recursively, performing each step of the computation as it 
 goes. An interpretive implementation is not required, however. A permis-
 sible alternative approach is for the evaluator first to completely compile 
 the form into machine-executable code and then invoke the resulting code. 
 This technique virtually eliminates incompatibilities between interpreted 
 and compiled code but also renders the
  evalhook
  mechanism relatively 
 useless. Various mixed strategies are also possible. All of these approaches 
 should produce the same results when executing a correct program but 
 may pro-duce different results for incorrect programs. For example, the 
 approaches may differ as to when macro calls are expanded; macro 
 definitions should not depend on the time at which they are expanded. 
 Implementors should document the evaluation strategy for each 
 implementation.",NA
20.1 Run-Time Evaluation of Forms,"The function
  eval
  is the main user interface to the evaluator. Hooks are 
 provided for user-supplied debugging routines to obtain control during the 
 execution of an interpretive evaluator. The functions
  evalhook
  and
  apply-
 hook
  provide alternative interfaces to the evaluator mechanism for use by
  
 503",NA
20.2 The Top-Level Loop,"Normally one interacts with Lisp through a “top-level
  read
 -
 eval
 -
 print
  
 loop,”so called because it is the highest level of control and consists of an 
 endless loop that reads an expression, evaluates it, and prints the results. 
 One has an effect on the state of the Lisp system only by invoking actions 
 that have side effects.
  
 The precise nature of the top-level loop for Common Lisp is purposely 
 not rigorously specified here so that implementors can experiment to 
 improve",NA
Chapter 21,NA,NA
Streams,"Streams are objects that serve as sources or sinks of data. Character 
 streams produce or absorb characters; binary streams produce or absorb 
 integers. The normal action of a Common Lisp system is to read characters 
 from a character input stream, parse the characters as representations of 
 Common Lisp data objects, evaluate each object (as a form) as it is read, and 
 print representations of the results of evaluation to an output character 
 stream.
  
 Typically streams are connected to files or to an interactive terminal. 
 Streams, being Lisp objects, serve as the ambassadors of external devices by 
 which input/output is accomplished.
  
 A stream, whether a character stream or a binary stream, may be input-
 only, output-only, or bidirectional. What operations may be performed on a 
 stream depends on which of the six types of stream it is.",NA
21.1 Standard Streams,"There are several variables whose values are streams used by many 
 functions in the Lisp system. These variables and their uses are listed here. 
 By con-vention, variables that are expected to hold a stream capable of 
 input have names ending with
  -input
 , and variables that are expected to 
 hold a stream capable of output have names ending with
  -output
 . Variables 
 expected to hold a bidirectional stream have names ending with
  -io
 .
  
 511",NA
21.2 Creating New Streams,"Perhaps the most important constructs for creating new streams are those 
 that open files; see
  with-open-file
  and
  open
 . The following functions con-
 struct streams without reference to a file system.
  
 [Function]
  make-synonym-stream
  symbol
  
 make-synonym-stream
  creates and returns a synonym stream. Any 
 operations on the new stream will be performed on the stream that is then 
 the value of the dynamic variable named by the
  symbol
 . If the value of the 
 variable should change or be bound, then the synonym stream will operate 
 on the new stream.
  
  
 The result of
  make-synonym-stream
  is always a stream of type 
 synonym-stream
 . Note that the type of a synonym stream is
  always 
 synonym-stream
 , regardless of the type of the stream for which it is a 
 synonym.",NA
21.3 Operations on Streams,"This section contains discussion of only those operations that are common 
 to all streams. Input and output is rather complicated and is discussed 
 separately in chapter 22. The interface between streams and the file system 
 is discussed in chapter 23.
  
 [Function]
  streamp
  object
  
 streamp
  is true if its argument is a stream, and otherwise is false.
  
 (streamp x)
  ≡
  (typep x ’stream)
  
  
 streamp
  is unaffected by whether its argument, if a stream, is open or 
 closed. In either case it returns true.
  
 [Function]
  open-stream-p
  stream
  
 X3J13 voted in January 1989 to add the predicate
  open-stream-p
 . It is 
 true if its argument (which must be a stream) is open, and otherwise is false.
  
 A stream is always created open; it remains open until closed with the 
 close
  function. The macros
  with-open-stream
 ,
  with-input-from-string
 , 
 with-output-to-string
 , and
  with-open-file
  automatically close the cre-
 ated stream as control leaves their bodies, in effect imposing dynamic 
 extent on the openness of the stream.",NA
Chapter 22,NA,NA
Input/Output,"Common Lisp provides a rich set of facilities for performing input/output. 
 All input/output operations are performed on streams of various kinds. 
 This chapter is devoted to stream data transfer operations. Streams are 
 discussed in chapter 21, and ways of manipulating files through streams are 
 discussed in chapter 23.
  
 While there is provision for reading and writing binary data, most of the 
 I/O operations in Common Lisp read or write characters. There are simple 
 primitives for reading and writing single characters or lines of data. The 
 format
  function can perform complex formatting of output data, directed 
 by a control string in manner similar to a Fortran
  FORMAT
  statement or a
  
 PL/I PUT EDIT
  statement. The most useful I/O operations, however, read 
 and write printed representations of arbitrary Lisp objects.
  
 Common Lispсодержит
  
 богатый
  
 функционал
  
 для
  
 выполненияопераций ввода/вывода. Все эти операции 
 производятся на различноговида потоках. Данная глава посвящена 
 тому, как оперировать даннымив потоках. Потоки обсуждаются в главе 
 21, а способы работы с файламичерез потоки в главе 23.
  
 Большинство операций ввода/вывода в Common Lisp’е читают 
 изаписывают буквы, но также есть функции и для бинарных 
 данных.Есть простые примитивы для чтения и записи одного символа 
 или строкданных. Функция
  format
  может выполнять сложное 
 форматированиевыходных данных, с помощью управляющей строки 
 как в выражении
 FORMAT
  в Fortran’е или в
  PUT EDIT
  в
  PL/I
 . Однако, 
 самыеполезные операции ввода/вывода читают и записывает 
 выводимыепредставления произвольных Lisp’овых объектов.
  
 523",NA
22.1 Printed Representation of Lisp Objects,"Lisp objects in general are not text strings but complex data structures. 
 They have very different properties from text strings as a consequence of 
 their internal representation. However, to make it possible to get at and talk 
 about Lisp objects, Lisp provides a representation of most objects in the 
 form of printed text; this is called the
  printed representation
 , which is used 
 for input/output purposes and in the examples throughout this book. 
 Functions such as
  print
  take a Lisp object and send the characters of its 
 printed representation to a stream. The collection of routines that does this 
 is known as the (Lisp)
  printer
 . The
  read
  function takes characters from a 
 stream, interprets them as a printed representation of a Lisp object, builds 
 that object, and returns it; the collection of routines that does this is called 
 the (Lisp)
  reader
 .
  
  
 В общем случае Lisp’овые объекты являются не строками,
  
 асложными структурами данных.Как следствие их 
 внутреннегопредставления, свойства этих объектов очень отличается 
 от свойствстрок. Однако, для того, чтобы можно было повествовать о 
 Lisp’овыхобъектах, Lisp большинство объектов отображает в форме 
 текста.Это называется
  строковое представление
 , которое 
 используется дляввода/вывода, а также в примерах в данной книге. 
 Такие функции, как
 print
 , принимают Lisp’овый объект и посылают 
 строку представления впоток.Коллекция этих функций называется 
 (Lisp’овым)
  принтером
 .Функция
  read
  принимает буквы из потока, 
 интерпретирует их какпредставление некоторого Lisp’ового объекта, 
 создаёт этот объект ивозвращает его.Коллекция этих функций 
 называется (Lisp’овым)
 считывателем
 .
  
 Ideally, one could print a Lisp object and then read the printed 
 represen-tation back in, and so obtain the same identical object. In practice 
 this is difficult and for some purposes not even desirable. Instead, reading a 
 printed representation produces an object that is (with obscure technical 
 exceptions) 
 equal
  to the originally printed object.
  
  
 В идеале, можно вывести Lisp’овый объект, а затем прочесть 
 егообратно и получить идентичный первому объект.На практике 
 этосделать сложнее, а в некоторых случаях это и не желательно. 
 Вместоэтого, считывание выводимого представления создаёт объект, 
 которыйравен
  equal
  оригинальному объекту.
  
 Most Lisp objects have more than one possible printed representation.",NA
22.1.1 What the Read Function Accepts,"The purpose of the Lisp reader is to accept characters, interpret them as the 
 printed representation of a Lisp object, and construct and return such an 
 object. The reader cannot accept everything that the printer produces; for 
 example, the printed representations of compiled code objects cannot be 
 read in. However, the reader has many features that are not used by the 
 output of the printer at all, such as comments, alternative representations, 
 and convenient abbreviations for frequently used but unwieldy constructs. 
 The reader is also parameterized in such a way that it can be used as a 
 lexical analyzer for a more general user-written parser.
  
  
 Целью Lisp’ового считывателя (ридера) является чтение 
 строки,интерпретация как Lisp’ового объекта, создание и возврат 
 этого объекта.Считыватель (ридер) не может прочесть все возможные 
 выводимыепредставления объектов, например невозможно прочесть 
 представлениескомпилированного кода.
  
 Однако считыватель (ридер) содержит
  
  
 Кмного таких возможностей, которые не используются при выводе.
  
 ним относятся комментарии, альтернативные представления и 
 удобныеаббревиатуры для часто используемых, но тяжеловесных 
 конструкций.Считыватель также может быть настроен так, чтобы 
 использоваться вкачестве лексического анализатора для более общих 
 пользовательскихпарсеров.
  
  
 The reader is organized as a recursive-descent parser. Broadly speaking, 
 the reader operates by reading a character from the input stream and 
 treating it in one of three ways. Whitespace characters serve as separators 
 but are otherwise ignored. Constituent and escape characters are 
 accumulated to make a
  token
 , which is then interpreted as a number or 
 symbol. 
  
 Macro 
 characters trigger the invocation of functions (possibly user-supplied) that 
 can perform arbitrary parsing actions, including recursive invocation of the 
 reader.
  
  
 выполнен
  
 какрекурсивный
  
 нисходящийпарсер.Считыватель
  
 Проще говоря, считыватель считывает букву из входящего потока",NA
22.1.2 Parsing of Numbers and Symbols,"When an extended token is read, it is interpreted as a number or symbol. In 
 general, the token is interpreted as a number if it satisfies the syntax for 
 numbers specified in table 22.3; this is discussed in more detail below.
  
 The characters of the extended token may serve various syntactic func-
 tions as shown in table 22.5, but it must be remembered that any character 
 included in a token under the control of an escape character is treated as 
 alphabetic
  rather than according to the attributes shown in the table. One 
 consequence of this rule is that a whitespace, macro, or escape character 
 will always be treated as alphabetic within an extended token because such 
 a character cannot be included in an extended token except under the 
 control of an escape character.
  
  
 To allow for extensions to the syntax of numbers, a syntax for
  potential 
 numbers
  is defined in Common Lisp that is more general than the actual 
 syntax for numbers. Any token that is not a potential number and does not 
 consist entirely of dots will always be taken to be a symbol, now and in the 
 future; programs may rely on this fact. Any token that is a potential number 
 but does not fit the actual number syntax defined below is a
  reserved token
  
 and has an implementation-dependent interpretation; an implementa-tion 
 may signal an error, quietly treat the token as a symbol, or take some other 
 action. Programmers should avoid the use of such reserved tokens. (A 
 symbol whose name looks like a reserved token can always be written using 
 one or more escape characters.) 
  
  
 Just as
  bignum
  is the standard term used by Lisp implementors for very 
 large integers, and
  flonum
  (rhymes with “low hum”) refers to a floating-",NA
22.1.3 Macro Characters,"If the reader encounters a macro character, then the function associated 
 with that macro character is invoked and may produce an object to be 
 returned. This function may read following characters in the stream in 
 whatever syntax it likes (it may even call
  read
  recursively) and return the 
 object represented by that syntax. Macro characters may or may not be 
 recognized, of course, when read as part of other special syntaxes (such as 
 for strings).
  
  
 The reader is therefore organized into two parts: the basic dispatch loop, 
 which also distinguishes symbols and numbers, and the collection of macro 
 characters. Any character can be reprogrammed as a macro character; this is 
 a means by which the reader can be extended. 
  
 The macro characters 
 normally defined are as follows:
  
 (
  The left-parenthesis character initiates reading of a pair or list. The func-
 tion
  read
  is called recursively to read successive objects until a right 
 parenthesis is found to be next in the input stream. A list of the 
 objects read is returned. Thus the input sequence
  
 (a b c)
  
 is read as a list of three objects (the symbols
  a
 ,
  b
 , and
  c
 ). The right 
 parenthesis need not immediately follow the printed representation 
 of the last object; whitespace characters and comments may precede 
 it. This can be useful for putting one object on each line and making it 
 easy to add new objects:
  
 (defun traffic-light (color) 
  
 (case color 
  
  
 (green) 
  
  
 (red (stop)) 
  
  
 (amber (accelerate)) 
  
 ))
  
 ;Insert more colors after this line
  
 It may be that
  no
  objects precede the right parenthesis, as in
  ()
  or
  ( )
 ; 
 this reads as a list of zero objects (the empty list).
  
 If a token that is just a dot, not preceded by an escape character, is 
 read after some object, then exactly one more object must follow the 
 dot, possibly followed by whitespace, followed by the right 
 parenthesis:",NA
22.1.4 Standard Dispatching Macro Character Syntax,"The standard syntax includes forms introduced by the
  #
  character. These 
 take the general form of a
  #
 , a second character that identifies the syntax, 
 and following arguments in some form. If the second character is a letter, 
 then case is not important;
  #O
  and
  #o
  are considered to be equivalent, for 
 example.
  
 Certain
  #
  forms allow an unsigned decimal number to appear between 
 the
  #
  and the second character; some other forms even require it. Those 
 forms that do not explicitly permit such a number to appear forbid it.
  
 The currently defined
  #
  constructs are described below and 
 summarized in table 22.6; more are likely to be added in the future. 
 However, the con-structs
  #!
 ,
  #?
 ,
  #[
 ,
  #]
 ,
  #{
 , and
  #}
  are explicitly reserved for 
 the user and will never be defined by the Common Lisp standard.
  
 #\ #\
 x
  reads in as a character object that represents the character
  x
 . Also,
  
 #\
 name
  reads in as the character object whose name is
  name
 . Note 
 that the backslash
  \
  allows this construct to be parsed easily by 
 EMACS-like editors.
  
 In the single-character case, the character
  x
  must be followed by a 
 non-constituent character, lest a
  name
  appear to follow the
  #\
 . A good 
 model of what happens is that after
  #\
  is read, the reader backs up 
 over the
  \
  and then reads an extended token, treating the initial
  \
  as 
 an escape character (whether it really is or not in the current 
 readtable).
  
 Uppercase and lowercase letters are distinguished after
  #\
 ;
  #\A
  and 
 #\a
  denote different character objects. Any character works after
  #\
 , 
 even those that are normally special to
  read
 , such as parentheses. 
 Non-printing characters may be used after
  #\
 , although for them 
 names are generally preferred.
  
 #\
 name
  reads in as a character object whose name is
  name
  (actu-ally, 
 whose name is
  (string-upcase
  name
 )
 ; therefore the syntax is case-
 insensitive). The
  name
  should have the syntax of a symbol. The 
 following names are standard across all implementations:
  
 newline 
  
 space
  
 The character that represents the division between lines 
 The space or blank character
  
 The following names are semi-standard; if an implementation 
 supports them, they should be used for the described characters and 
 no others.",NA
22.1.5 The Readtable,"Previous sections describe the standard syntax accepted by the
  read
  func-
 tion. This section discusses the advanced topic of altering the standard syn-
 tax either to provide extended syntax for Lisp objects or to aid the writing 
 of other parsers.
  
 There is a data structure called the
  readtable
  that is used to control the 
 reader. It contains information about the syntax of each character 
 equivalent to that in table 22.2. It is set up exactly as in table 22.2 to give 
 the standard Common Lisp meanings to all the characters, but the user can 
 change the meanings of characters to alter and customize the syntax of 
 characters. It is also possible to have several readtables describing different 
 syntaxes and to switch from one to another by binding the variable
  
 *readtable*
 .
  
 [Variable]
  *readtable*
  
 The value of
  *readtable*
  is the current readtable. The initial value of 
 this is a readtable set up for standard Common Lisp syntax. You can bind 
 this variable to temporarily change the readtable being used.
  
 To program the reader for a different syntax, a set of functions are pro-
 vided for manipulating readtables. Normally, you should begin with a copy 
 of the standard Common Lisp readtable and then customize the individual 
 characters within that copy.",NA
22.1.6 What the Print Function Produces,"The Common Lisp printer is controlled by a number of special variables. 
 These are referred to in the following discussion and are fully documented 
 at the end of this section.
  
 How an expression is printed depends on its data type, as described in the 
 following paragraphs.
  
 Integers
  If appropriate, a radix specifier may be printed; see the variable 
 *print-radix*
 . If an integer is negative, a minus sign is printed and 
 then the absolute value of the integer is printed. Integers are printed 
 in the radix specified by the variable
  *print-base*
  in the usual 
 positional notation, most significant digit first. The number zero is 
 represented by the single digit
  0
  and never has a sign. A decimal point 
 may then be printed, depending on the value of
  *print-radix*
 .
  
 Ratios
  If appropriate, a radix specifier may be printed; see the variable 
 *print-radix*
 . If the ratio is negative, a minus sign is printed. Then 
 the absolute value of the numerator is printed, as for an integer; then 
 a
  /
 ; then the denominator. The numerator and denominator are both 
 printed in the radix specified by the variable
  *print-base*
 ; they are",NA
22.2 Input Functions,"The input functions are divided into two groups: those that operate on 
 streams of characters and those that operate on streams of binary data.",NA
22.2.1 Input from Character Streams,"Many character input functions take optional arguments called
  input-
 stream
 , 
 eof-error-p
 , and
  eof-value
 . The
  input-stream
  argument is the stream 
 from which to obtain input; if unsupplied or
  nil
  it defaults to the value of 
 the special variable
  *standard-input*
 . One may also specify
  t
  as a stream, 
 meaning the value of the special variable
  *terminal-io*
 .
  
 The
  eof-error-p
  argument controls what happens if input is from a file 
 (or any other input source that has a definite end) and the end of the file is 
 reached. If
  eof-error-p
  is true (the default), an error will be signaled at end 
 of file. If it is false, then no error is signaled, and instead the function 
 returns
  eof-value
 .
  
 An
  eof-value
  argument may be any Lisp datum whatsoever.
  
 Functions such as
  read
  that read the representation of an object rather 
 than a single character will always signal an error, regardless of
  eof-error-p
 , 
 if the file ends in the middle of an object representation. For example, if a 
 file does not contain enough right parentheses to balance the left 
 parentheses in it,
  read
  will complain. If a file ends in a symbol or a number 
 immediately followed by end-of-file,
  read
  will read the symbol or number 
 successfully and when called again will see the end-of-file and only then act 
 according to
  eof-error-p
 . Similarly, the function
  read-line
  will successfully 
 read the last line of a file even if that line is terminated by end-of-file rather 
 than the newline character. If a file contains ignorable text at the end, such 
 as blank lines and comments,
  read
  will not consider it to end in the middle 
 of an object. Thus an
  eof-error-p
  argument controls what happens when the 
 file ends
  between 
 objects.
  
 Many input functions also take an argument called
  recursive-p
 . If spec-
 ified and not
  nil
 , this argument specifies that this call is not a “top-level”call 
 to
  read
  but an imbedded call, typically from the function for a macro 
 character. It is important to distinguish such recursive calls for three 
 reasons.
  
 First, a top-level call establishes the context within which the
  #
 n
 =
  and 
 #
 n
 #
  
 syntax is scoped. Consider, for example, the expression
  
 (cons ’#3=(p q r) ’(x y . #3#))",NA
22.2.2 Input from Binary Streams,"Common Lisp currently specifies only a very simple facility for binary input: 
 the reading of a single byte as an integer.
  
 [Function]
  read-byte
  binary-input-stream
  &optional
  eof-error-p eof-value
  
 read-byte
  reads one byte from the
  binary-input-stream
  and returns it in the 
 form of an integer.",NA
Output Functions,CHAPTER 22. INPUT/OUTPUT,NA
22.3,"The output functions are divided into two groups: those that operate on 
 streams of characters and those that operate on streams of binary data. The 
 function
  format
  operates on streams of characters but is described in a 
 section separate from the other character-output functions because of its 
 great complexity.",NA
22.3.1 Output to Character Streams,"These functions all take an optional argument called
  output-stream
 , which 
 is where to send the output. If unsupplied or
  nil
 ,
  output-stream
  defaults to 
 the value of the variable
  *standard-output*
 . If it is
  t
 , the value of the 
 variable 
 *terminal-io*
  is used.
  
 X3J13 voted in June 1989 to add the keyword argument
  :readably
  to 
 the function
  write
 , and voted in June 1989 to add the keyword arguments 
 :right-margin
 ,
  :miser-width
 ,
  :lines
 , and
  :pprint-dispatch
 . The revised 
 description is as follows.
  
 [Function]
  write
  object
  &key
  :stream :escape :radix :base :circle :pretty 
 :level :length :case :gensym :array :readably :right-margin :miser-width 
 :lines :pprint-dispatch
  
  
 The printed representation of
  object
  is written to the output stream 
 spec-ified by
  :stream
 , which defaults to the value of
  *standard-output*
 .
  
  
 The other keyword arguments specify values used to control the gen-
 eration of the printed representation. 
  
 Each defaults to the value of the 
 corresponding global variable: 
  
 see
  *print-escape*
 ,
  *print-radix*
 , 
 *print-
 base*
 ,
  *print-circle*
 ,
  *print-pretty*
 ,
  *print-level*
 ,
  *print-length*
 , and
  
 *print-case*
 , 
  
  
 in addition to
  *print-array*
 , 
  
 *print-gensym*
 , 
  
  
 *print-
 readably*
 , 
   
 *print-right-margin*
 , 
  
 *print-miser-
 width*
 ,
  *print-lines*
 , and
  *print-pprint-dispatch*
 . (This is the means by 
 which these variables affect printing operations: supplying default values 
 for the
  write
  function.) Note that the printing of symbols is also affected by 
 the value of the variable
  *package*
 .
  write
  returns
  object
 .
  
 [Function]
  prin1
  object
  &optional
  output-stream 
 [Function]
  print
  object
  &optional
  output-stream",NA
22.3.2 Output to Binary Streams,"Common Lisp currently specifies only a very simple facility for binary 
 output: the writing of a single byte as an integer.
  
 [Function]
  write-byte
  integer binary-output-stream
  
 write-byte
  writes one byte, the value of
  integer
 . It is an error if
  integer 
 is not of the type specified as the
  :element-type
  argument to
  open
  when 
 the stream was created. The value
  integer
  is returned.",NA
22.3.3 Formatted Output to Character Streams,"The function
  format
  is very useful for producing nicely formatted text, pro-
 ducing good-looking messages, and so on.
  format
  can generate a string or 
 output to a stream.
  
 Formatted output is performed not only by the
  format
  function itself 
 but by certain other functions that accept a control string “the way
  format 
 does.” For example, error-signaling functions such as
  cerror
  accept
  format 
 control strings.
  
 [Function]
  format
  destination control-string
  &rest
  arguments
  
 format
  is used to produce formatted output.
  format
  outputs the char-
 acters of
  control-string
 , except that a tilde (
 ~
 ) introduces a directive. The",NA
Querying the User,CHAPTER 22. INPUT/OUTPUT,NA
22.4,"The following functions provide a convenient and consistent interface for 
 ask-ing questions of the user. Questions are printed and the answers are 
 read us-ing the stream
  *query-io*
 , which normally is synonymous with
  
 *terminal-io*
  but can be rebound to another stream for special 
 applications.
  
 [Function]
  y-or-n-p
  &optional
  format-string
  &rest
  arguments
  
  
 This predicate is for asking the user a question whose answer is 
 either“yes” or “no.” It types out a message (if supplied), reads an answer in 
 some implementation-dependent manner (intended to be short and simple, 
 like reading a single character such as
  Y
  or
  N
 ), and is true if the answer 
 was“yes” or false if the answer was “no.”
  
  
 If the
  format-string
  argument is supplied and not
  nil
 , then a
  fresh-line 
 operation is performed; then a message is printed as if the
  format-string
  and 
 arguments
  were given to
  format
 . Otherwise it is assumed that any message 
 has already been printed by other means. If you want a question mark at the 
 end of the message, you must put it there yourself;
  y-or-n-p
  will not add it. 
 However, the message should not contain an explanatory note such as
  (Y or 
 N)
 , because the nature of the interface provided for
  y-or-n-p
  by a given 
 implementation might not involve typing a character on a keyboard; 
 y-or-n-
 p
  will provide such a note if appropriate.
  
  
 All input and output are performed using the stream in the global 
 variable 
 *query-io*
 .
  
 Here are some examples of the use of
  y-or-n-p
 :
  
 (y-or-n-p ""Produce listing file?"") 
  
 (y-or-n-p ""Cannot connect to network host ~S. Retry?"" host)
  
 y-or-n-p
  should only be used for questions that the user knows are 
 com-ing or in situations where the user is known to be waiting for a 
 response of some kind. If the user is unlikely to anticipate the question, or if 
 the conse-quences of the answer might be grave and irreparable, then
  y-or-
 n-p
  should not be used because the user might type ahead and thereby 
 accidentally an-swer the question. For such questions as “Shall I delete all of 
 your files?” it is better to use
  yes-or-no-p
 .",NA
Chapter 23,NA,NA
File System Interface,"A frequent use of streams is to communicate with a
  file system
  to which 
 groups of data (files) can be written and from which files can be retrieved.
  
 Потоки чаще всего используются для работы с
  файловой 
 системой
 ,в которую могут быть записаны данные (файлы) и из 
 которой после этифайлы могут быть прочитаны.
  
 Common Lisp defines a standard interface for dealing with such a file 
 sys-tem. This interface is designed to be simple and general enough to 
 accom-modate the facilities provided by “typical” operating system 
 environments within which Common Lisp is likely to be implemented. The 
 goal is to make Common Lisp programs that perform only simple 
 operations on files reason-ably portable.
  
 Common Lisp определяет стандартный интерфейс для работы 
 сфайловой системой.
  
 Данные интерфейс спроектирован простым 
 идостаточно обобщённым для того, чтобы предоставлять 
 функционал«типичной» операционной системы, в которой работает 
 реализация Com-mon Lisp’а. Целью является переносимость Common 
 Lisp’овых программв случае, если они используют простые операции 
 над файлами.
  
 To this end, Common Lisp assumes that files are named, that given a 
 name one can construct a stream connected to a file of that name, and that 
 the names can be fit into a certain canonical, implementation-independent 
 form called a
  pathname
 .
  
 И наконец, Common Lisp предполагает, что файлы имеют имена,
  
  
 Эти именакоторые используются при создании файлового потока.
  
 абстрагируются в системонезависимую форму -
  pathname
 .
  
 Facilities are provided for manipulating pathnames, for creating streams
  
 645",NA
23.1,NA,NA
File Names,"Common Lisp programs need to use names to designate files.
  
 The main
  
 difficulty in dealing with names of files is that different file systems have 
 different naming formats for files. For example, here is a table of several file 
 systems (actually, operating systems that provide file systems) and what 
 equivalent file names might look like for each one:
  
 System
  
 File Name
  
 TOPS-20
  
 <LISPIO>FORMAT.FASL.13
  
 TOPS-10
  
 FORMAT.FAS[1,4]
  
 ITS
  
 LISPIO;FORMAT FASL
  
 MULTICS
  
 >udd>LispIO>format.fasl
  
 TENEX
  
 <LISPIO>FORMAT.FASL;13
  
 VAX/VMS
  
 [LISPIO]FORMAT.FAS;13
  
 UNIX
  
 /usr/lispio/format.fasl
  
 It would be impossible for each program that deals with file names to know 
 about each different file name format that exists; a new Common Lisp 
 imple-mentation might use a format different from any of its predecessors. 
 There-fore, Common Lisp provides
  two
  ways to represent file names:
  
 namestrings
 , which are strings in the implementation-dependent form 
 customary for the file system, and
  pathnames
 , which are special abstract 
 data objects that represent file names in an implementation-independent 
 way. Functions are provided to convert between these two representations, 
 and all manipulations of files can be expressed in machine-independent 
 terms by using pathnames.
  
 In order to allow Common Lisp programs to operate in a network en-
 vironment that may have more than one kind of file system, the pathname 
 facility allows a file name to specify which file system is to be used. In this 
 context, each file system is called a
  host
 , in keeping with the usual 
 networking terminology.",NA
23.1.1 Pathnames,"All file systems dealt with by Common Lisp are forced into a common frame-
 work, in which files are named by a Lisp data object of type
  pathname
 .
  
 A pathname always has six components, described below. These compo-
 nents are the common interface that allows programs to work the same 
 way with different file systems; the mapping of the pathname components 
 into the concepts peculiar to each file system is taken care of by the 
 Common Lisp implementation.
  
 host
  The name of the file system on which the file resides.
  
 device
  Corresponds to the “device” or “file structure” concept in many host 
 file systems: the name of a (logical or physical) device containing files.
  
 directory
  Corresponds to the “directory” concept in many host file systems: 
 the name of a group of related files (typically those belonging to a 
 single user or project).
  
 name
  The name of a group of files that can be thought of as the “same” file.
  
 type
  Corresponds to the “filetype” or “extension” concept in many host file 
 systems; identifies the type of file. Files with the same names but different 
 types are usually related in some specific way, for instance, one being a 
 source file, another the compiled form of that source, and a third the listing 
 of error messages from the compiler.
  
 version
  Corresponds to the “version number” concept in many host file 
 systems. Typically this is a number that is incremented every time the 
 file is modified.
  
 Note that a pathname is not necessarily the name of a specific file. Rather, it 
 is a specification (possibly only a partial specification) of how to access a file. 
  
 A pathname need not correspond to any file that actually exists, and 
 more than one pathname can refer to the same file. For example, the",NA
23.1.2 Case Conventions,"Issues of alphabetic case in pathnames are a major source of problems. In 
 some file systems, the customary case is lowercase, in some uppercase, in 
 some mixed. Some file systems are case-sensitive (that is, they treat
  FOO 
 and
  foo
  as different file names) and others are not.
  
 There are two kinds of pathname case portability problems: moving 
 pro-grams from one Common Lisp to another, and moving pathname 
 component values from one file system to another. The solution to the first 
 problem is the requirement that all Common Lisp implementations that 
 support a particu-lar file system must use compatible representations for 
 pathname component values. The solution to the second problem is the use 
 of a common represen-tation for the least-common-denominator pathname 
 component values that exist on all interesting file systems.
  
 Requiring a common representation directly conflicts with the desire 
 among programmers that use only one file system to work with the local 
 conventions and to ignore issues of porting to other file systems. The com-
 mon representation cannot be the same as local (varying) conventions.
  
 X3J13 voted in June 1989 to add a keyword argument
  :case
  to each of 
 the functions
  make-pathname
 ,
  pathname-host
 ,
  pathname-device
 , 
 pathname-directory
 ,
  pathname-name
 , and
  pathname-type
 . The pos-
 sible values for the argument are
  :common
  and
  :local
 . The default is
  :local
 .
  
 The value
  :local
  means that strings given to
  make-pathname
  or re-
 turned by any of the pathname component accessors follow the local file 
 system’s conventions for alphabetic case. Strings given to
  make-pathname 
 will be used exactly as written if the file system supports both cases. If the 
 file system supports only one case, the strings will be translated to that 
 case.
  
 The value
  :common
  means that strings given to
  make-pathname
  or 
 returned by any of the pathname component accessors follow this common 
 convention:
  
 •
  All uppercase means that a file system’s customary case will be used.
  
 •
  All lowercase means that the opposite of the customary case will be used.
  
 •
  Mixed case represents itself.
  
 Uppercase is used as the common case for no better reason than consistency 
 with Lisp symbols. The second and third points allow translation from local",NA
23.1.3 Structured Directories,"X3J13 voted in June 1989 to define a specific pathname component format 
 for structured directories.
  
 The value of a pathname’s directory component may be a list. The
  car
  of 
 the list should be a keyword, either
  :absolute
  or
  :relative
 . Each remaining 
 element of the list should be a string or a symbol (see below). Each string 
 names a single level of directory structure and should consist of only the 
 directory name without any punctuation characters.
  
 A list whose
  car
  is the symbol
  :absolute
  represents a directory path 
 starting from the root directory. For example, the list
  (:absolute)
  
 represents the root directory itself; the list
  (:absolute ""foo"" ""bar"" ""baz"")
  
 represents the directory that in a UNIX file system would be called
  
 /foo/bar/baz
 .
  
 A list whose
  car
  is the symbol
  :relative
  represents a directory path 
 start-ing from a default directory. The list
  (:relative)
  has the same meaning 
 as 
 nil
  and hence normally is not used. The list
  (:relative ""foo"" ""bar"")
  rep-
 resents the directory named
  bar
  in the directory named
  foo
  in the default 
 directory.
  
 In place of a string, at any point in the list, a symbol may occur to indicate a 
 special file notation. The following symbols have standard meanings.
  
 :wild
  Wildcard match of one level of directory structure
  
 :wild-inferiors
  Wildcard match of any number of directory levels
  
 :up
  Go upward in directory structure (semantic)
  
 :back
  Go upward in directory structure (syntactic)",NA
23.1.4 Extended Wildcards,"Some file systems provide more complex conventions for wildcards than 
 sim-ple component-wise wildcards representable by
  :wild
 . 
  
 For 
 example, the namestring
  ""F*O""
  might mean a normal three-character name; 
 a three-character name with the middle character wild; a name with at least 
 two char-acters, beginning with
  F
  and ending with
  O
 ; or perhaps a wild 
 match span-ning multiple directories. 
  
 Similarly, the 
 namestring
  "">foo>**>bar>"" 
 might imply that the middle directory is named
  
 ""**""
 ; the middle directory is
  :wild
 ; there are zero or more middle directories 
 that are
  :wild
 ; or per-haps that the middle directory name matches any two-
 letter name. Some file systems support even more complex wildcards, such 
 as regular expressions.
  
  
 X3J13 voted in June 1989 to provide some facilities for dealing with 
 more general wildcard pathnames in a fairly portable manner.
  
 [Function]
  wild-pathname-p
  pathname
  &optional
  field-key
  
 Tests a pathname for the presence of wildcard components. If the first 
 argument is not a pathname, string, or file stream, an error of type
  type-
 error
  is signaled.
  
  
 If no
  field-key
  is provided, or the
  field-key
  is
  nil
 , the result is true if and 
 only if
  pathname
  has any wildcard components.
  
 If a non-null
  field-key
  is provided, it must be one of
  :host
 ,
  :device
 , 
 :directory
 ,
  :name
 ,
  :type
 , or
  :version
 . In this case, the result is true if and 
 only if the indicated component of
  pathname
  is a wildcard.
  
 Note that X3J13 voted in June 1989 to specify that an implementation 
 need not support wildcards in all fields; the only requirement is that the",NA
23.1.5 Logical Pathnames,"Pathname values are not portable, but sometimes they must be mentioned 
 in a program (for example, the names of files containing the program and 
 the data used by the program).
  
 X3J13 voted in June 1989 to provide some facilities for portable 
 pathname values. The idea is to provide a portable framework for 
 pathname values; these logical pathnames are then mapped to physical 
 (that is, actual) path-names by a set of implementation-dependent or site-
 dependent rules. The logical pathname facility therefore separates the 
 concerns of program writing and user software architecture from the 
 details of how a software system is embedded in a particular file system or 
 operating environment.
  
 Pathname values are not portable because not all Common Lisp imple-
 mentations use the same operating system and file name syntax varies 
 widely among operating systems. In addition, corresponding files at two 
 different sites may have different names even when the operating system is 
 the same; for example, they may be on different directories or different 
 devices. The Common Lisp logical pathname system defines a particular 
 pathname struc-ture and namestring syntax that must be supported by all 
 implementations.
  
 [Class]
  logical-pathname
  
 This is a subclass of
  pathname
 .
  
 Syntax of Logical Pathname Namestrings
  
 The syntax of a logical pathname namestring is as follows:
  
 logical-namestring
  ::= [
 host
  :
 ] [
 ;
 ] {
 directory
  ;
 }* [
 name
 ] [
 .
  type [
 .
  version]
  ]
  
 Note that a logical namestring has no
  device
  portion.
  
 host
  ::=
  word 
  
 directory
  ::=
  word
  |
  wildcard-word
  |
  wildcard-inferiors 
 name
  ::=
  word
  |
  wildcard-word 
  
 type
  ::=
  word
  |
  wildcard-word 
  
 version
  ::=
  word
  |
  wildcard-word 
  
 word
  ::= {
 letter | digit |
  -
 }+ 
  
 wildcard-word
  ::= [
 word
 ]
  *
  {
 word
  *
 }* [
 word
 ] 
  
 wildcard-inferiors
  ::=
  **",NA
23.1.6 Pathname Functions,"These functions are what programs use to parse and default file names that 
 have been typed in or otherwise supplied by the user.
  
 Any argument called
  pathname
  in this book may actually be a pathname, 
 a string or symbol, or a stream. Any argument called
  defaults
  may likewise 
 be a pathname, a string or symbol, or a stream.
  
 X3J13 voted in March 1988 to change the language so that a symbol is
  
 never
  allowed as a pathname argument. More specifically, the following 
 functions are changed to disallow a symbol as a
  pathname
  argument:
  
 pathname
  
 pathname-device
  
 namestring
  
 truename
  
 pathname-directory
  
 file-namestring
  
 parse-namestring
  
 pathname-name
  
 directory-namestring
  
 merge-pathnames
  
 pathname-type
  
 host-namestring
  
 pathname-host
  
 pathname-version
  
 enough-namestring
  
 (The function
  require
  was also changed by this vote but was deleted from 
 the language by a vote in January 1989 .) Furthermore, the vote reaffirmed 
 that the following functions do not accept symbols as
  file
 ,
  filename
 , or
  
 pathname 
 arguments:",NA
23.2 Opening and Closing Files,"When a file is
  opened
 , a stream object is constructed to serve as the file 
 system’s ambassador to the Lisp environment; operations on the stream 
 are reflected by operations on the file in the file system. The act of
  closing
  
 the file (actually, the stream) ends the association; the transaction with the 
 file system is terminated, and input/output may no longer be performed on 
 the stream. The stream function
  close
  may be used to close a file; the 
 functions described below may be used to open them. The basic operation 
 is
  open
 , but
  with-open-file
  is usually more convenient for most 
 applications.
  
 [Function]
  open
  filename
  &key
  :direction :element-type :if-exists :if-
 does-not-exist :external-format
  
 X3J13 voted in June 1989 to add to the function
  open
  a new keyword 
 argument
  :external-format
 . This argument did not appear in the preceding 
 argument description in the first edition.
  
 This returns a stream that is connected to the file specified by
  filename
 . The
  
 filename
  is the name of the file to be opened; it may be a string, a pathname, 
 or a stream. (If the
  filename
  is a stream, then it is not closed first or 
 otherwise affected; it is used merely to provide a file name for the opening of 
 a new stream.) 
  
 X3J13 voted in January 1989 to specify that the result of
  open
 , if it is a 
 stream, is always a stream of type
  file-stream
 .
  
 X3J13 voted in March 1988 to specify exactly which streams may be used as 
 pathnames. See section 23.1.6.
  
 X3J13 voted in January 1989 to specify that
  open
  is unaffected by 
 whether the first argument, if a stream, is open or closed. If the first argu-
 ment is a stream,
  open
  behaves as if the function
  pathname
  were applied 
 to the stream and the resulting pathname used instead.",NA
23.3,NA,NA
"Renaming, Deleting, and Other File Op-",NA,NA
erations,"These functions provide a standard interface to operations provided in 
 some form by most file systems. It may be that some implementations of 
 Common Lisp cannot support them all completely.",NA
23.4 Loading Files,"To
  load
  a file is to read through the file, evaluating each form in it. Programs 
 are typically stored in files containing calls to constructs such as
  defun
 ,
  def-
 macro
 , and
  defvar
 , which define the functions and variables of the 
 program.
  
 Loading a compiled (“fasload”) file is similar, except that the file does 
 not contain text but rather pre-digested expressions created by the 
 compiler that can be loaded more quickly.
  
 [Function]
  load
  filename
  &key
  :verbose :print :if-does-not-exist
  
 This function loads the file named by
  filename
  into the Lisp 
 environment. It is assumed that a text (character file) can be automatically 
 distinguished from an object (binary) file by some appropriate 
 implementation-dependent means, possibly by the file type. The defaults 
 for
  filename
  are taken from the variable
  *default-pathname-defaults*
 . If 
 the
  filename
  (after the merging in of the defaults) does not explicitly specify 
 a type, and both text and object",NA
23.5 Accessing Directories,"The following function is a very simple portable primitive for examining a 
 directory. Most file systems can support much more powerful directory-
 searching primitives, but no two are alike. It is expected that most imple-
 mentations of Common Lisp will extend the
  directory
  function or provide 
 more powerful primitives.
  
 Следующие функции это простые портируемые примитивы 
 дляработы 
 с 
 директорией. 
 Большинство 
 файловых 
 систем 
 поддерживаютгораздо более мощные примитивы. Ожидается, что 
 реализации Com-mon Lisp’а расширят функцию
  directory
  или 
 предоставят более мощныепримитивы.
  
 [Function]
  directory
  pathname
  &key
  
 A list of pathnames is returned, one for each file in the file system that 
 matches the given
  pathname
 . (The
  pathname
  argument may be a pathname, 
 a string, or a stream associated with a file.) For a file that matches, the 
 truename
  appears in the result list. If no file matches the
  pathname
 , it is 
 not an error;
  directory
  simply returns
  nil
 , the list of no results. Keywords 
 such as
  :wild
  and
  :newest
  may be used in
  pathname
  to indicate the search 
 space.
  
  
  
 каждое для одного 
 файла,Возвращается список имён-файлов,
  
 который подходит для переданного имени-файла
  pathname
 .
  
  
 X3J13 voted in March 1988 to specify exactly which streams may be used 
 as pathnames. See section 23.1.6.
  
 X3J13 voted in January 1989 to specify that
  directory
  is unaffected by 
 whether the first argument, if a stream, is open or closed. If the first 
 argument is a stream,
  directory
  behaves as if the function
  pathname
  were 
 applied",NA
Chapter 24,NA,NA
Miscellaneous Features,"In this chapter are described various things that don’t seem to fit neatly 
 anywhere else in this book: the compiler, the
  documentation
  function, 
 debugging aids, environment inquiries (including facilities for calculating 
 and measuring time), and the
  identity
  function.",NA
24.1 The Compiler,"The compiler is a program that may make code run faster by translating 
 programs into an implementation-dependent form that can be executed 
 more efficiently by the computer. Most of the time you can write programs 
 without worrying about the compiler; compiling a file of code should 
 produce an equivalent but more efficient program. When doing more 
 esoteric things, you may need to think carefully about what happens at 
 “compile time” and what happens at “load time.” Then the
  eval-when
  
 construct becomes particularly useful.
  
 Most declarations are not used by the Common Lisp interpreter; they 
 may be used to give advice to the compiler. The compiler may attempt to 
 check your advice and warn you if it is inconsistent.
  
 Unlike most other Lisp dialects, Common Lisp recognizes
  special
  decla-
 rations in interpreted code as well as compiled code.
  
 The internal 
  
 workings 
  
 of a 
  
 compiler 
  
 will 
  
 of course 
  
 be 
  
 highly 
 implementation-dependent. The following functions provide a standard in-
 terface to the compiler, however.
  
 703",NA
24.1.1 Compiler Diagnostics,"compile
  and
  compile-file
  may output warning messages; any such 
 messages should go to the stream that is the value of
  *error-output*
 .
  
 First, note that
  error
  and
  warning
  conditions may be signaled either by 
 the compiler itself or by code being processed by the compiler (for example, 
 arbitrary errors may occur during compile-time macro expansion or 
 process-ing of
  eval-when
  forms). Considering only those conditions 
 signaled
  by the compiler
  (as opposed to
  during compilation
 ):
  
 •
  Conditions of type
  error
  may be signaled by the compiler in situations 
 where the compilation cannot proceed without intervention. 
 Examples of such situations may include errors when opening a file or 
 syntax errors.
  
 •
  Conditions of type
  warning
  may be signaled by the compiler in situa-
 tions where the standard explicitly states that a warning must, should, 
 or may be signaled. They may also be signaled when the compiler can 
 determine that a situation would result at runtime that would have 
 un-defined consequences or would cause an error to be signaled. 
 Examples of such situations may include violations of type 
 declarations, alter-ing or rebinding a constant defined with
  
 defconstant
 , calls to built-in Lisp functions with too few or too many 
 arguments or with malformed keyword argument lists, referring to a 
 variable declared
  ignore
 , or un-recognized declaration specifiers.
  
 •
  The compiler is permitted to signal diagnostics about matters of pro-
 gramming style as conditions of type
  style-warning
 , a subtype of 
 warning
 . Although a
  style-warning
  condition
  may
  be signaled in 
 these situations, no implementation is
  required
  to do so. However, if 
 an implementation does choose to signal a condition, that condition 
 will be of type
  style-warning
  and will be signaled by a call to the 
 func-tion
  warn
 . Examples of such situations may include redefinition 
 of a function with an incompatible argument list, calls to functions 
 (other than built-in functions) with too few or too many arguments or 
 with malformed keyword argument lists, unreferenced local variables 
 not de-clared
  ignore
 , or standard declaration specifiers that are 
 ignored by the particular compiler in question.",NA
24.1.2 Compiled Functions,"Certain requirements are imposed on the functions produced by the compi-
 lation process.
  
  
 If a function is of type
  compiled-function
 , then all macro calls appear-
 ing lexically within the function have already been expanded and will not be 
 expanded again when the function is called. 
  
 The process of compila-
 tion effectively turns every
  macrolet
  or
  symbol-macrolet
  construct into a 
 progn
  (or a
  locally
 ) with all instances of the local macros in the body fully 
 expanded.
  
 If a function is of type
  compiled-function
 , then all
  load-time-value 
 forms appearing lexically within the function have already been pre-
 evaluated and will not be evaluated again when the function is called.
  
 Implementations are free to classify every function as a
  compiled-
 function
  provided that all functions satisfy the preceding requirements. 
 Conversely, it is permissible for a function that is not a
  compiled-function 
 to satisfy the preceding requirements.
  
 If one or more functions are defined in a file that is compiled with 
 compile-file
  and the compiled file is subsequently loaded by the function 
 load
 , the resulting loaded function definitions must be of type
  compiled-
 function
 .
  
 The function
  compile
  must produce an object of type
  compiled-
 function
  as the value that is either returned or stored into the
  symbol-
 function
  of a symbol argument.",NA
24.1.3 Compilation Environment,"Following information must be available at compile time for correct compi-
 lation and what need not be available until run time.
  
 The following information must be present in the compile-time environ-
 ment for a program to be compiled correctly. This information need not 
 also be present in the run-time environment.
  
 •
  In conforming code, macros referenced in the code being compiled 
 must have been previously defined in the compile-time environment. 
 The compiler must treat as a function call any form that is a list whose 
 car
  is a symbol that does not name a macro or special operator. (This 
 implies that
  setf
  methods must also be available at compile time.)
  
 •
  In conforming code, proclamations for
  special
  variables must be made 
 in the compile-time environment before any bindings of those 
 variables are processed by the compiler. The compiler must treat any 
 binding of an undeclared variable as a lexical binding.
  
 The compiler may incorporate the following kinds of information into 
 the code it produces, if the information is present in the compile-time 
 environ-ment and is referenced within the code being compiled; however, 
 the compiler is not required to do so. When compile-time and run-time 
 definitions differ, it is unspecified which will prevail within the compiled 
 code (unless some other behavior is explicitly specified below). It is also 
 permissible for an im-plementation to signal an error at run time on 
 detecting such a discrepancy. In all cases, the absence of the information at 
 compile time is not an error, but its presence may enable the compiler to 
 generate more efficient code.",NA
24.1.4 Similarity of Constants,"Following paragraphs specifies what objects can be in compiled constants 
 and what relationship there must be between a constant passed to the 
 compiler and the one that is established by compiling it and then loading its 
 file.
  
 The key is a definition of an equivalence relationship called “similarity 
 as constants” between Lisp objects. Code passed through the file compiler 
 and then loaded must behave as though quoted constants in it are similar in 
 this sense to quoted constants in the corresponding source code. An object 
 may be used as a quoted constant processed by
  compile-file
  if and only if 
 the compiler can guarantee that the resulting constant established by 
 loading the compiled file is “similar as a constant” to the original. Specific 
 requirements are spelled out below.
  
 Some types of objects, such as streams, are not supported in constants 
 processed by the file compiler. Such objects may not portably appear as 
 constants 
 in 
 code 
 processed 
 with
  
 compile-file
 . 
 Conforming 
 implementations are required to handle such objects either by having the 
 compiler or loader reconstruct an equivalent copy of the object in some 
 implementation-specific manner or by having the compiler signal an error.
  
 Of the types supported in constants, some are treated as aggregate ob-
 jects. For these types, being similar as constants is defined recursively. We 
 say that an object of such a type has certain “basic attributes”; to be similar 
 as a constant to another object, the values of the corresponding attributes 
 of the two objects must also be similar as constants.
  
 A definition of this recursive form has problems with any circular or 
 infinitely recursive object such as a list that is an element of itself. We use 
 the idea of depth-limited comparison and say that two objects are similar as 
 constants if they are similar at all finite levels. This idea is implicit in the 
 definitions below, and it applies in all the places where attributes of two 
 objects are required to be similar as constants. The question of handling 
 circular constants is the subject of a separate vote by X3J13 (see below).
  
 The following terms are used throughout this section. The term
  constant 
 refers to a quoted or self-evaluating constant, not a named constant defined 
 by
  defconstant
 . The term
  source code
  is used to refer to the objects con-
 structed when
  compile-file
  calls
  read
  (or the equivalent) and to additional 
 objects constructed by macro expansion during file compilation. The term 
 compiled code
  is used to refer to objects constructed by
  load
 .
  
 Two objects are
  similar as a constant
  if and only if they are both of one",NA
24.2 Debugging Tools,"The utilities described in this section are sufficiently complex and 
 sufficiently dependent on the host environment that their complete 
 definition is beyond the scope of this book. However, they are also 
 sufficiently useful to warrant",NA
24.3 Environment Inquiries,"Environment inquiry functions provide information about the environment 
 in which a Common Lisp program is being executed. They are described 
 here in two categories: first, those dealing with determination and 
 measurement of time, and second, all the others, most of which deal with 
 identification of the computer hardware and software.
  
 Справочные функции представляют информацию о среде, в 
 которойисполняется 
 Common 
 Lisp’овая 
 программа. 
 Функции 
 разделены на двекатегории: первые для работы со временем, и 
 остальные 
 для 
 полученияимен, 
 версий, 
 типов 
 программ 
 и 
 оборудования.",NA
24.3.1 Time Functions,"Time is represented in three different ways in Common Lisp: Decoded Time, 
 Universal Time, and Internal Time. The first two representations are used 
 primarily to represent calendar time and are precise only to one second. 
 Internal Time is used primarily to represent measurements of computer 
 time (such as run time) and is precise to some implementation-dependent 
 fraction of a second, as specified by
  internal-time-units-per-second
 . 
  
 Decoded 
 Time format is used only for absolute time indications. Universal Time and 
 Internal Time formats are used for both absolute and relative times.
  
 Decoded Time format represents calendar time as a number of compo-nents:
  
 • Second
 : an integer between 0 and 59, inclusive.
  
 • Minute
 : an integer between 0 and 59, inclusive.",NA
24.3.2 Other Environment Inquiries,NA,NA
24.3.3Справочные функции о среде,"For any of the following functions, if no appropriate and relevant result can 
 be produced,
  nil
  is returned instead of a string.
  
 Rationale:
  These inquiry facilities are functions rather than variables against the 
 possibility that a Common Lisp process might migrate from machine to machine. 
 This need not happen in a distributed environment; consider, for example, dumping 
 a core image file containing a compiler and then shipping it to another site. 
 [Function]
  lisp-implementation-type
  
 A string is returned that identifies the generic name of the particular 
 Common Lisp implementation. 
  
 Examples:
  ""Spice LISP""
 ,
  ""Zetalisp""
 , 
 ""SBCL""
 .
  
 [Function]
  lisp-implementation-version
  
 A string is returned that identifies the version of the particular Common 
 Lisp implementation; this information should be of use to maintainers of 
 the implementation. Examples:
  ""1192""
 ,
  ""53.7 with complex numbers""
 , 
 ""1746.9A, NEWIO 53, ETHER 5.3""
 .",NA
24.4 Identity Function,"This function is occasionally useful as an argument to other functions that 
 require functions as arguments. (Got that?)
  
 [Function]
  identity
  object
  
 The
  object
  is returned as the value of
  identity
 .
  
 The
  identity
  function is the default value for the
  :key
  argument to many 
 sequence functions (see chapter 14).
  
 Table 12.1 illustrates the behavior in the complex plane of the
  identity 
 function regarded as a function of a complex numerical argument.
  
 Many other constructs in Common Lisp have the behavior of
  identity 
 when given a single argument. For example, one might well use
  values
  in 
 place of
  identity
 . However, writing
  values
  of a single argument 
 convention-ally indicates that the argument form might deliver multiple 
 values and that the intent is to pass on only the first of those values.",NA
Chapter 25 ,NA,NA
Loop,737,NA
Chapter 26,NA,NA
Цикл loop,"Author: Jon L White
  
 Автор: Jon L White 
  
 preface:X3J13 voted in January 1989 to adopt an extended definition of the 
 loop
  macro as a part of the forthcoming draft Common Lisp standard. 
  
 This 
 chapter presents the bulk of the Common Lisp Loop Facility proposal, writ-
 ten by Jon L White. I have edited it only very lightly to conform to the overall 
 style of this book and have inserted a small number of bracketed remarks, 
 identified by the initials GLS. (See the Acknowledgments to this second 
 edition for acknowledgments to others who contributed to the Loop Facility 
 proposal.) 
  
 Guy L. Steele Jr.",NA
26.1 Introduction,NA,NA
26.2Введение,"A
  loop
  is a series of expressions that are executed one or more times, a 
 process known as
  iteration
 . The
  Loop Facility
  defines a variety of useful 
 methods, indicated by
  loop keywords
 , to iterate and to accumulate values in 
 a loop.
  
 Цикл
  
 представляет 
 собой 
 группу 
 выражений, 
 которые 
 выполняютсяодин или более раз, такой процесс известен как
  
 итерация
 . Цикл
  Loop
 включает в себя различную функциональность, 
 которая обозначается
 ключевыми символами loop
 , для итерации и для 
 накопления значений вцикле.
  
 739",NA
26.3 How the Loop Facility Works,NA,NA
26.4Как работает Loop,"The driving element of the Loop Facility is the
  loop
  macro. When Lisp 
 encounters a
  loop
  macro call form, it invokes the Loop Facility and passes 
 to it the loop clauses as a list of unevaluated forms, as with any macro. The 
 loop clauses contain Common Lisp forms and loop keywords. The loop 
 keywords are recognized by their symbol name, regardless of the packages 
 that contain them. The
  loop
  macro translates the given form into Common 
 Lisp code and returns the expanded form.
  
  
 Главным элементом Loop является макрос
  loop
 . Как только 
 Common Lisp видит вызов макроса
  loop
 , он разворачивает его без 
 вычисленияаргументов, что собственно происходит и с любым другим 
 макросом. Loop содержит формы и ключевые символы.Ключевые 
 символыобозначаются символами не обращая внимание на их 
 принадлежностьк пакету.
  
 Макрос
  loop
  
 транслирует полученную форму в Common Lisp’овый код и возвращает 
 развёрнутую форму.
  
 The expanded loop form is one or more lambda-expressions for the local 
 binding of loop variables and a block and a tagbody that express a looping 
 control structure. The variables established in the loop construct are bound 
 as if by using
  let
  or
  lambda
 . Implementations can interleave the setting of 
 initial values with the bindings. However, the assignment of the initial 
 values is always calculated in the order specified by the user. A variable is",NA
26.5 Parsing Loop Clauses,NA,NA
26.6Парсинг выражений Loop,"The syntactic parts of a loop construct are called
  clauses
 ; the scope of each 
 clause is determined by the top-level parsing of that clause’s keyword. The 
 following example shows a loop construct with six clauses:
  
  
 Синтаксические части конструкции loop называются
  
 выражениями
 .Область действия каждого выражения определяется 
 парсером данноготипа выражения.
  
 Следующий пример 
 показывает loop с шестьювыражениями:
  
 (loop for i from 1 to (compute-top-value) 
   
   
 ;First clause 
 while (not (unacceptable i)) 
  
  
 ;Second clause 
 collect (square i) ;Third clause 
  
 do (format t ""Working on ~D now"" i) 
  
   
 ;Fourth clause 
 when (evenp i) 
  
  
 ;Fifth clause 
  
  
 do (format t ""~D is a non-odd number"" i) 
  
 finally (format t ""About to exit!"")) 
  
   
 ;Sixth clause
  
 (loop for i from 1 to (compute-top-value) 
     
 ;Первое 
 выражениеwhile (not (unacceptable i)) 
    
 ;Второе
  
 collect (square i) ;Третье
  
 do (format t ""Обрабтка ~D "" i) 
  
   
 ;Четвёртое
  
 when (evenp i) 
  
  
 ;Пятое
  
  
 do (format t ""~D чётное"" i) 
  
 finally (format t ""Почти у выхода!"")) 
  
    
 ;Шестое
  
 Each loop keyword introduces either a compound loop clause or a simple 
 loop clause that can consist of a loop keyword followed by a single Lisp 
 form.",NA
26.6.1 Order of Execution,NA,NA
26.6.2Порядок вычисления,"With the exceptions listed below, clauses are executed in the loop body in 
 the order in which they appear in the source. Execution is repeated until a 
 clause terminates the loop or until a Common Lisp
  return
 ,
  go
 , or
  throw 
 form is encountered. The following actions are exceptions to the linear order 
 of execution:
  
 Выражения в теле loop вычисляются в том порядке, в котором 
 задалпользователь,
  
 с некоторыми исключениями перечисленными 
 ниже.Вычисление повторяется пока не сработает выражение, 
 завершающеецикл, или не будет вызвана одна из Common Lisp’овых 
 форм
  return
 , 
 go
 ,
  throw
 . Для последовательного выполнения 
 существуют следующиеисключения:
  
 •
  All variables are initialized first, regardless of where the establishing 
 clauses appear in the source. The order of initialization follows the order 
 of these clauses.",NA
26.6.3,"–
  проверка
  
 условия
  
 завершения
  
 цикла,
  
 обычно
  
 перед
  
 выполнение итерации",NA
Kinds of Loop Clauses,NA,NA
26.6.4,NA,NA
Разновидности Loop выражений,"Loop clauses fall into one of the following categories:
  
 Выражения делятся на следующие категории:
  
 •
  variable initialization and stepping
  
 •
  инициализация и пошаговое изменение
  
 –
  The
  for
  and
  as
  constructs provide iteration control clauses that
  
 establish a variable to be initialized. You can combine
  for
  and
  
 as
  clauses with the loop keyword
  and
  to get parallel initialization
  
 and stepping.
  
 –
  Конструкции
  for
  и
  as
  служат для установки переменных. Для
  
 параллельной инициализации и изменения, выражения
  for
  и
  
 as
  могут комбинироваться с помощью символа
  and
 .
  
 –
  The
  with
  construct is similar to a single
  let
  clause. You can
  
 combine
  with
  clauses using
  and
  to get parallel initialization.
  
 –
  Конструкция
  
 with
  
 похожа
  
 навыражение
 let
 .
  
 Для
  
 параллельной инициализации вы можете комбинировать
  with
  
 с помощью
  and
 .
  
 –
  The
  repeat
  construct causes iteration to terminate after a speci-
  
 fied number of times. It uses an internal variable to keep track of
  
 the number of iterations.",NA
26.6.5 Loop Syntax,NA,NA
26.6.6Синтаксис Loop,"The following syntax description provides an overview of the syntax for 
 loop clauses. 
  
 Detailed syntax descriptions of individual clauses appear in 
 sec-tions 26.12 through 26.23. A loop consists of the following types of 
 clauses:",NA
26.7 User Extensibility,"There is currently no specified portable method for users to add extensions
  
 to the Loop Facility. The names
  defloop
  and
  define-loop-method
  have
  
 been suggested as candidates for such a method.",NA
26.8Пользовательские расширения,Пользователю не предоставляется способа расширить функционал Loop.,NA
26.9 Loop Constructs,NA,NA
26.10Конструкции Loop,"The remaining sections of this chapter describe the constructs that the Loop
  
 Facility provides. The descriptions are organized according to the function-
  
 ality of the constructs. Each section begins with a general discussion of a
  
 particular operation; it then presents the constructs that perform the oper-
  
 ation.
  
 Следующиеразделы
  
 раскрывают
  
 конструкции
  
 цикла
  
 Loop.
  
 Описания сгруппированы по типам данных конструкций.
  
 Каждый
  
 раздел начинается с общего описания конкретной операции, затем
  
 раскрывается конструкция, которая выполняет данную операцию.
  
 •
  Section 26.12, “Iteration Control,” describes iteration control clauses that 
 allow directed loop iteration.",NA
26.11 Iteration Control,NA,NA
26.12Управление итерациями,"Iteration control clauses allow you to direct loop iteration. The loop 
 keywords 
 as
 ,
  for
 , and
  repeat
  designate iteration control clauses.
  
  
 Для управления итерациями используются выражения
  as
 ,
  for
  и
  re-
 peat
 .
  
 Iteration control clauses differ with respect to the specification of 
 termina-tion conditions and the initialization and stepping of loop 
 variables. Iteration clauses by themselves do not cause the Loop Facility to 
 return values, but they can be used in conjunction with value-accumulation 
 clauses to return values (see section 26.15).
  
  
 Управление итерациями отличается от условий завершения циклаи 
 инициализации и наращивания переменных цикла.
  
 Управлениеитерациями само по себе не выполняет возврат 
 значение, но оно можетиспользоваться в сочетании с выражениями 
 накопления значения длявозврата значений (смотрите раздел 26.15).
  
 All variables are initialized in the loop prologue. The scope of the 
 variable binding is
  lexical
  unless it is proclaimed special; thus, the variable 
 can be accessed only by expressions that lie textually within the loop. 
 Stepping assignments are made in the loop body before any other 
 expressions are evaluated in the body.",NA
26.13 End-Test Control,NA,NA
26.14Проверка завершения,"The loop keywords
  always
 ,
  never
 ,
  thereis
 ,
  until
 , and
  while
  designate 
 constructs that use a single test condition to determine when loop iteration 
 should terminate.
  
 Ключевые 
 символы
  always
 ,
  never
 ,
  thereis
 ,
  until
  и
  while
  
 обозначаютконструкции, которые с помощью условия проверяют 
 должен ли бытьзавершён цикл.
  
 The constructs
  always
 ,
  never
 , and
  thereis
  provide specific values to be 
 returned when a loop terminates. Using
  always
 ,
  never
 , or
  thereis
  with 
 value-returning accumulation clauses can produce unpredictable results. In 
 all other respects these constructs behave like the
  while
  and
  until
  
 constructs.
  
 The macro
  loop-finish
  can be used at any time to cause normal 
 termina-tion. In normal termination,
  finally
  clauses are executed and 
 default return values are returned.
  
 End-test control constructs can be used anywhere within the loop body.",NA
26.15 Value Accumulation,"Accumulating values during iteration and returning them from a loop is 
 often useful. Some of these accumulations occur so frequently that special 
 loop clauses have been developed to handle them.",NA
26.16 Variable Initializations,NA,NA
26.17Инициализация переменных,"A local loop variable is one that exists only when the Loop Facility is 
 invoked. At that time, the variables are declared and are initialized to some 
 value. These local variables exist until loop iteration terminates, at which 
 point they cease to exist. Implicitly variables are also established by 
 iteration control clauses and the
  into
  preposition of accumulation clauses.
  
 The loop keyword
  with
  designates a loop clause that allows you to 
 declare and initialize variables that are local to a loop. The variables are 
 initialized one time only; they can be initialized sequentially or in parallel.
  
 By default, the
  with
  construct initializes variables sequentially; that is, 
 one variable is assigned a value before the next expression is evaluated. 
 How-ever, by using the loop keyword
  and
  to join several
  with
  clauses, you 
 can force initializations to occur in parallel; that is, all of the specified 
 expres-",NA
26.18 Conditional Execution,NA,NA
26.19Условное выполнение,"The loop keywords
  if
 ,
  when
 , and
  unless
  designate constructs that are useful 
 when you want some loop clauses to operate under a specified condition.
  
 Ключевые 
 символы
  
 if
 ,
  
 when
  
 и
  
 unless
  
 обозначают 
 конструкцию,которая полезна, когда вы хотите выполнить некоторые 
 действия толькопри выполнении некоторого условия.
  
 If the specified condition is true, the succeeding loop clause is executed. 
 If the specified condition is not true, the succeeding clause is skipped, and 
 program control moves to the clause that follows the loop keyword
  else
 . If 
 the specified condition is not true and no
  else
  clause is specified, the entire 
 conditional construct is skipped. Several clauses can be connected into one 
 compound clause with the loop keyword
  and
 . The end of the conditional",NA
26.20 Unconditional Execution,NA,NA
26.21Безусловное выполнение,"The loop construct
  do
  (or
  doing
 ) takes one or more expressions and simply 
 evaluates them in order.
  
  
 The loop construct
  return
  takes one expression and returns its value. It 
 is equivalent to the clause
  do (return
  value
 )
 .
  
  
 Конструкция
  do
  (или
  doing
 ) принимает одно или более 
 выраженийи просто их выполняет в исходном порядке.
  
  
 Конструкция
  return
  принимает одно выражение и возвращает 
 егозначение. Оно эквивалентно такому выражению:
  do (return
  value
 )
 .
  
 [Loop clause]
  do
  {expr}*
  
 [Loop clause]
  doing
  {expr}*
  
  
 The
  do
  construct simply evaluates the specified expressions wherever 
 they occur in the expanded form of
  loop
 .
  
  
 Конструкция
 do
  
 простовыполняетуказанные
  
 выражения.Конструкция может быть использована в любом месте 
 формы
  loop
 .
  
  
 The
  expr
  argument can be any non-atomic Common Lisp form. Each 
 expr
  
 is evaluated in every iteration.
  
  
 Аргумент
  expr
  может быть любой неатомной Common 
 Lisp’овойформой.Каждое выражение
  expr
  вычисляется на каждой 
 итерациицикла.
  
  
 The constructs
  do
 ,
  initially
 , and
  finally
  are the only loop keywords that 
 take an arbitrary number of forms and group them as if using an implicit 
 progn
 . Because every loop clause must begin with a loop keyword, you 
 would use the keyword
  do
  when no control action other than execution is 
 required.
  
 Только 
 конструкции
  
 do
 ,
  
 initially
  
 и
  
 finally
  
 принимают 
 несколькоформ и группируют их как неявный
  progn
 . Так как каждое 
 выражениецикла
  loop
  начинается с ключевого символа, когда 
 требуется простовыполнение некоторых действий, вы должны 
 использовать ключевойсимвол
  do
 .
  
 Examples:",NA
26.22 ,NA,NA
Miscellaneous Features,NA,NA
26.23,NA,NA
Дополнительные возможности,"The Loop Facility provides the
  named
  construct to name a loop so that the 
 Common Lisp special operator
  return-from
  can be used.
  
 Для задания имени цикла используется конструкция
  named
 . 
 Данноеимя впоследствии можно использовать в
  return-from
 .
  
 The loop keywords
  initially
  and
  finally
  designate loop constructs that 
 cause expressions to be evaluated before and after the loop body, 
 respectively.
  
 Символы
  initially
  и
  finally
  обозначают выражения, которые 
 будутвыполнены перед и после тела цикла соответственно.
  
 The code for any
  initially
  clauses is collected into one
  progn
  in the 
 order in which the clauses appeared in the loop. The collected code is 
 executed once in the loop prologue after any implicit variable initializations.
  
 Выражения после всех
  initially
  собираются в один
  progn
  в 
 исходномпорядке. Сгруппированный код выполняется единожды 
 перед началомитераций.
  
 The code for any
  finally
  clauses is collected into one
  progn
  in the order 
 in which the clauses appeared in the loop. The collected code is executed 
 once in the loop epilogue before any implicit values are returned from the 
 accumulation clauses. Explicit returns in the loop body, however, will exit 
 the loop without executing the epilogue code.
  
 Выраженияпосле
  
 всех
 finally
  
 собираются
  
 водин
  
 progn
  
 висходном порядке. Сгруппированный код выполняется единожды 
 послевыполнения всех итераций в эпилоге перед неявным возвратом 
 значений.В случае явного выхода из цикла, эпилог не выполняется.",NA
26.23.1 ,NA,NA
Data Types,NA,NA
26.23.2,NA,NA
Типы данных,"Many loop constructs take a
  type-spec
  argument that allows you to specify
  
 certain data types for loop variables. While it is not necessary to specify a
  
 data type for any variable, by doing so you ensure that the variable has a
  
 correctly typed initial value. The type declaration is made available to the
  
 compiler for more efficient
  loop
  expansion. In some implementations, fixnum
  
 and float declarations are especially useful; the compiler notices them and
  
 emits more efficient code.
  
 Многиеконструкциипринимают
  
 аргумент
  
 type-spec
 ,
  
 который
  
 позволяет задать тип для переменной.Конечно в этом нет прямой
  
 необходимости, но декларации типов упрощают дальнейшую работу
  
 с программой.
  
 Декларация типовтакже помогаеткомпилятору
  
 оптимизировать программу. Особенно это касается типов fixnum и float.
  
 The
  type-spec
  argument has the following syntax:
  
 type-spec
  ::=
  of-type
  d-type-spec
  
 d-type-spec
  ::=
  type-specifier
  |
  (
 d-type-spec
  .
  d-type-spec
 )
  
 A
  type-specifier
  in this syntax can be any Common Lisp type specifier. The
  d-
  
 type-spec
  argument is used for destructuring, as described in section 26.23.3.
  
 If the
  d-type-spec
  argument consists solely of the types
  fixnum
 ,
  float
 ,
  t
 ,
  
 or
  nil
 , the
  of-type
  keyword is optional. The
  of-type
  construct is optional
  
 in these cases to provide backward compatibility; thus the following two
  
 expressions are the same:
  
 ;;; This expression uses the old syntax for type specifiers.
  
 (loop for i fixnum upfrom 3 ...)
  
 ;;; This expression uses the new syntax for type specifiers.
  
 (loop for i of-type fixnum upfrom 3 ...)
  
 Аргумент
  type-spec
  выглядит так:
  
 type-spec
  ::=
  of-type
  d-type-spec
  
 d-type-spec
  ::=
  type-specifier
  |
  (
 d-type-spec
  .
  d-type-spec
 )
  
 На месте
  type-specifier
  может быть любой спецификатор типа. Аргумент
  
 d-type-spec
  
 используетсядля
  
 деструктуризации,
  
 какнаписано
  
 в",NA
26.23.3 ,NA,NA
Destructuring,"Destructuring allows you to bind a set of variables to a corresponding set of 
 values anywhere that you can normally bind a value to a single variable. 
 During
  loop
  expansion, each variable in the variable list is matched with 
 the values in the values list. If there are more variables in the variable list 
 than there are values in the values list, the remaining variables are given a 
 value of
  nil
 . If there are more values than variables listed, the extra values 
 are discarded.
  
 Suppose you want to assign values from a list to the variables
  a
 ,
  b
 , and 
 c
 . 
 You could use one
  for
  clause to bind the variable
  numlist
  to the
  car
  of the 
 specified expression, and then you could use another
  for
  clause to bind the 
 variables
  a
 ,
  b
 , and
  c
  sequentially.
  
 ;;; Collect values by using FOR constructs.
  
 (loop for numlist in ’((1 2 4.0) (5 6 8.3) (8 9 10.4)) 
  
 for a integer = (first numlist) 
  
  
 and for b integer = (second numlist) 
  
  
 and for c float = (third numlist) 
  
  
 collect (list c b a))
  
 ⟨
  ((4.0 2 1) (8.3 6 5) (10.4 9 8))
  
 Destructuring makes this process easier by allowing the variables to be 
 bound in parallel in each loop iteration. You can declare data types by using 
 a list of
  type-spec
  arguments. If all the types are the same, you can use a 
 shorthand destructuring syntax, as the second example following 
 illustrates.",NA
Chapter 27,NA,NA
Pretty Printing,"Author: Richard C. Waters 
  
 preface: X3J13 voted in January 1989 to adopt a facility for user-controlled 
 pretty printing as a part of the forthcoming draft Common Lisp standard. 
 This facility is the culmination of thirteen years of design, testing, revision, 
 and use of this approach.
  
 This chapter presents the bulk of the Common Lisp pretty printing spec-
 ification, written by Richard C. Waters. I have edited it only very lightly to 
 conform to the overall style of this book.
  
 —Guy L. Steele Jr.",NA
27.1 Introduction,"Pretty printing has traditionally been a black box process, displaying pro-
 gram code using a set of fixed layout rules. Its utility can be greatly 
 enhanced by opening it up to user control. The facilities described in this 
 chapter pro-vide general and powerful means for specifying pretty-printing 
 behavior.
  
 By providing direct access to the mechanisms within the pretty printer 
 that make dynamic decisions about layout, the macros and functions
  
 pprint-logical-block
 ,
  pprint-newline
 , and
  pprint-indent
  make it possible 
 to specify pretty printing layout rules as a part of any function that 
 produces output. They also make it very easy for the function to support 
 detection of circularity and sharing and abbreviation based on length and 
 nesting depth. Using the function
  set-pprint-dispatch
 , one can associate a 
 user-defined pretty printing function with any type of object. A small set of 
 new
  for-
  
 797",NA
27.2,NA,NA
Pretty Printing Control Variables,"The function
  write
  accepts keyword arguments named
  :pprint-dispatch
 , 
 :miser-width
 ,
  :right-margin
 , and
  :lines
 , corresponding to these variables.
  
 [Variable]
  *print-pprint-dispatch*
  
  
 When
  *print-pretty*
  is not
  nil
 , printing is controlled by the ‘pprint 
 dispatch table’ stored in the variable
  *print-pprint-dispatch*
 . The initial 
 value of
  *print-pprint-dispatch*
  is implementation-dependent and causes 
 traditional pretty printing of Lisp code. 
  
 The last section of this chapter 
 explains how the contents of this table can be changed.
  
 [Variable]
  *print-right-margin*
  
 A primary goal of pretty printing is to keep the output between a pair of 
 margins. The left margin is set at the column where the output begins. If 
 this cannot be determined, the left margin is set to zero.
  
 When
  *print-right-margin*
  is not
  nil
 , it specifies the right margin to 
 use when making layout decisions. When
  *print-right-margin*
  is
  nil
  (the 
 initial value), the right margin is set at the maximum line length that can be 
 displayed by the output stream without wraparound or truncation. If this 
 cannot be determined, the right margin is set to an implementation-
 dependent value.
  
 To allow for the possibility of variable-width fonts,
  *print-right-
 margin*
  is in units of ems—the width of an “m” in the font being used to 
 display characters on the relevant output stream at the moment when the 
 variables are consulted.",NA
27.3 Dynamic Control of the Arrangement of,NA,NA
Output,"The following functions and macros support precise control of what should 
 be done when a piece of output is too large to fit in the space available. 
 Three concepts underlie the way these operations work:
  logical blocks
 ,
  
 conditional newlines
 , and
  sections
 . Before proceeding further, it is important 
 to define these terms.
  
 The first line of figure 27.1 shows a schematic piece of output. The char-
 acters in the output are represented by hyphens. The positions of 
 conditional newlines are indicated by digits. The beginnings and ends of 
 logical blocks are indicated in the figure by “
 <
 ” and “
 >
 ” respectively.",NA
27.4 Format Directive Interface,"The primary interface to operations for dynamically determining the 
 arrange-ment of output is provided through the functions above. However, 
 an addi-tional interface is provided via a set of format directives because, as 
 shown by the examples in this section and the next,
  format
  strings are 
 typically a much more compact way to specify pretty printing. In addition, 
 without such an interface, one would have to abandon the use of
  format
  
 when interacting with the pretty printer.
  
 ~W
  Write.
  An
  arg
 , any Lisp object, is printed obeying
  every
  printer control 
 variable (as by
  write
 ). In addition,
  ~W
  interacts correctly with depth 
 abbreviation by not resetting the depth counter to zero. 
  
 ~W
  does 
 not accept parameters. If given the colon modifier,
  ~W
  binds
  *print-pretty*
  
 to
  t
 . If given the atsign modifier,
  ~W
  binds
  *print-level* 
 and
  *print-length*
  
 to
  nil
 .
  
 ~W
  provides automatic support for circularity detection. If
  *print-
 circle*
  (and possibly also
  *print-shared*
 ) is not
  nil
  and
  ~W
  is ap-
 plied to an argument that is a circular (or shared) reference, an appro-
 priate “
 #
 n
 #
 ” marker is inserted in the output instead of printing the 
 argument.
  
 ~_
  Conditional newline. 
 Without any modifiers,
  ~_
  is equivalent to 
 (pprint-
 newline :linear)
 . The directive
  ~@_
  is equivalent to 
 (pprint-newline 
 :miser)
 . 
  
 The directive
  ~:_
  is equivalent to 
 (pprint-
 newline :fill)
 . The directive
  ~:@_
  is equivalent to
  (pprint-newline 
 :mandatory)
 .
  
 ~<
 str
 ~:>
  Logical block.
  If
  ~:>
  is used to terminate a
  ~<...
  directive, the 
 directive is equivalent to a call on
  pprint-logical-block
 . 
  
 The 
 format
  argument corresponding to the
  ~<...~:>
  directive is treated in the 
 same way as the
  list
  argument to
  pprint-logical-block
 , thereby providing 
 automatic support for non-list arguments and the detection of circularity, 
 sharing, and depth abbreviation. 
  
 The portion of the 
 format
  control string nested within the
  ~<...~:>
  specifies the
  :prefix 
 (or
  
 :per-line-prefix
 ),
  :suffix
 , and body of the
  pprint-logical-block
 .
  
 The
  format
  string portion enclosed by
  ~<...~:>
  can be divided into 
 segments
  ~<
 prefix
 ~;
 body
 ~;
  suffix
 ~:>
  by
  ~;
  directives. If the first",NA
27.5 Compiling Format Control Strings,"The control strings used by
  format
  are essentially programs that perform 
 printing. The macro
  formatter
  provides the efficiency of using a compiled 
 function for printing without losing the visual compactness of
  format
  
 strings.
  
 [Macro]
  formatter
  control-string
  
 The 
  
  
 control-string 
 must 
   
 be 
  
 a 
   
 literal string. 
  
  
 An 
  
 error 
  
 is 
   
 sig-
 naled if
  control-string 
  
  
 is not a valid
  format
  control string. 
    
 The 
 macro 
  
 formatter 
  
 expands 
  
 into 
   
 an expression 
  
 of 
  
 the 
   
 form 
  
 (func-
 tion (lambda (stream &rest args) ...)) 
  
 that does the printing spec-ified by
  
 control-string
 . The
  lambda
  created accepts an output stream as its first 
 argument and zero or more data values as its remaining arguments. The 
 value returned by the
  lambda
  is the tail (if any) of the data values that are 
 not printed out by
  control-string
 . (For example, if the
  control-string 
 is
  
 ""~A~A""
 , the
  cddr
  (if any) of the data values is returned.) The form 
 (formatter ""~%~2@{~S, ~}"")
  is equivalent to the following:",NA
27.6 Pretty Printing Dispatch Tables,"When
  *print-pretty*
  is not
  nil
 , the pprint dispatch table in the variable 
 *print-pprint-dispatch*
  controls how objects are printed. The informa-
 tion in this table takes precedence over all other mechanisms for specifying 
 how to print objects. In particular, it overrides user-defined
  print-object 
 methods and print functions for structures. However, if there is no specifi-
 cation for how to pretty print a particular kind of object, it is then printed 
 using the standard mechanisms as if
  *print-pretty*
  were
  nil
 .
  
 A pprint dispatch table is a mapping from keys to pairs of values. The 
 keys are type specifiers. The values are functions and numerical priorities. 
 Basic insertion and retrieval is done based on the keys with the equality of 
 keys being tested by
  equal
 . The function to use when pretty printing an 
 object is chosen by finding the highest priority function in
  *print-pprint-
 dispatch*
  that is associated with a type specifier that matches the object.",NA
Chapter 28,NA,NA
Common Lisp Object System,"Authors: Daniel G. Bobrow, Linda G. DeMichiel, Richard P. Gabriel, Sonya E. 
 Keene, Gregor Kiczales, and David A. Moon 
  
 This chapter presents the bulk of the first two chapters of the Common Lisp 
 Object System specification; it is substantially identical to these two 
 specification chapters as previously published elsewhere [5, 6, 7]. I have 
 edited the material only very lightly to conform to the overall style of this 
 book and to save a substantial number of pages by using a typographically 
 condensed presentation. I have inserted a small number of bracketed 
 remarks, identified by the initials GLS. The chapter divisions of the original 
 specification have become section divisions in this chapter; references to the 
 three chapters of the original specification now refer to the three “parts” of 
 the specification. (See the Acknowledgments to this second edition for 
 acknowledgments to others who contributed to the Common Lisp Object 
 System specification.) This is not the last word on CLOS; X3J13 may well 
 refine this material further. Keene has written a good tutorial introduction to 
 CLOS [26].
  
 —Guy L. Steele Jr.",NA
28.1 Programmer Interface Concepts,"The Common Lisp Object System (CLOS) is an object-oriented extension to 
 Common Lisp. 
  
 It is based on generic functions, multiple inheritance, 
 declarative method combination, and a meta-object protocol.
  
 The first two parts of this specification describe the standard 
 Programmer Interface for the Common Lisp Object System. The first part, 
 Programmer
  
 821",NA
28.1.1 Error Terminology,"A situation is the evaluation of an expression in some specific context. For 
 example, a situation might be the invocation of a function on arguments that",NA
28.1.2 Classes,"A
  class
  is an object that determines the structure and behavior of a set of 
 other objects, which are called its
  instances
 .
  
 A class can inherit structure and behavior from other classes. A class whose 
 definition refers to other classes for the purpose of inheriting from them is 
 said to be a
  subclass
  of each of those classes. 
  
 The classes that 
 are designated for purposes of inheritance are said to be
  superclasses
  of the 
 inheriting class.
  
 A class can have a
  name
 . The function
  class-name
  takes a class object 
 and returns its name. The name of an anonymous class is
  nil
 . A symbol can 
 name
  a class. The function
  find-class
  takes a symbol and returns the class 
 that the symbol names. A class has a
  proper name
  if the name is a symbol 
 and if the name of the class names that class. That is, a class
  C
  has the 
 proper 
 name S
  if
  S
  =
  (class-name
  C
 )
  and
  C
  =
  (find-class
  S
 )
 . Notice that it is 
 possible for
  (find-class
  S
 1
 )
  =
  (find-class
  S
 2
 )
  and
  S
 1
  ̸
 =
  S
 2
 . If 
 C
  =
  (find-class
  
 S
 )
 , we say that
  C
  is the
  class named S
 .
  
 A class
  C
 1
  is a
  direct superclass
  of a class
  C
 2
  if
  C
 2
  explicitly designates 
 C
 1
  as a 
 superclass in its definition. In this case,
  C
 2
  is a
  direct subclass
  of 
 C
 1
 . A class
  C
 n
  
 is a
  superclass
  of a class
  C
 1
  if there exists a series of classes 
 C
 2
 , . . . , C
 n−
 1
  such 
 that
  C
 i
 +1
  is a direct superclass of
  C
 i
  for 1
  ≤ i < n
 . In this case,
  C
 1
  is a
  subclass
  of
  
 C
 n
 . A class is considered neither a superclass nor a subclass of itself. That is, 
 if
  C
 1
  is a superclass of
  C
 2
 , then
  C
 1
  ̸
 =
  C
 2
 . The set of classes consisting of some 
 given class
  C
  along with all of its superclasses is called “
 C
  and its 
 superclasses.”
  
 Each class has a
  class precedence list
 , which is a total ordering on the set of 
 the given class and its superclasses. The total ordering is expressed as a list 
 ordered from most specific to least specific. The class precedence list is used 
 in several ways. In general, more specific classes can
  shadow
 , or override, 
 features that would otherwise be inherited from less specific classes.",NA
28.1.3 Inheritance,"A class can inherit methods, slots, and some
  defclass
  options from its su-
 perclasses. The following sections describe the inheritance of methods, the 
 inheritance of slots and slot options, and the inheritance of class options.
  
 Inheritance of Methods
  
 A subclass inherits methods in the sense that any method applicable to all 
 instances of a class is also applicable to all instances of any subclass of that 
 class.
  
 The inheritance of methods acts the same way regardless of whether the 
 method was created by using one of the method-defining forms or by using 
 one of the
  defclass
  options that causes methods to be generated automati-
 cally.
  
 The inheritance of methods is described in detail in section 28.1.7.
  
 Inheritance of Slots and Slot Options
  
 The set of names of all slots accessible in an instance of a class
  C
  is the union 
 of the sets of names of slots defined by
  C
  and its superclasses. The
  structure 
 of an instance is the set of names of local slots in that instance.
  
 In the simplest case, only one class among
  C
  and its superclasses defines 
 a slot with a given slot name. If a slot is defined by a superclass of
  C
 , the slot 
 is said to be
  inherited
 . The characteristics of the slot are determined by the 
 slot specifier of the defining class. Consider the defining class for a slot
  S
 . If 
 the value of the
  :allocation
  slot option is
  :instance
 , then
  S
  is a local slot and 
 each instance of
  C
  has its own slot named
  S
  that stores its own value. If the 
 value of the
  :allocation
  slot option is
  :class
 , then
  S
  is a shared slot, the class 
 that defined
  S
  stores the value, and all instances of
  C
  can access that single 
 slot. If the
  :allocation
  slot option is omitted,
  :instance
  is used.
  
 In general, more than one class among
  C
  and its superclasses can define a 
 slot with a given name. In such cases, only one slot with the given name",NA
28.1.4 Integrating Types and Classes,"The Common Lisp Object System maps the space of classes into the 
 Common Lisp type space. Every class that has a proper name has a 
 corresponding type with the same name.
  
 The proper name of every class is a valid type specifier. In addition, 
 every class object is a valid type specifier. Thus the expression
  (typep
  
 object class
 )
  evaluates to true if the class of
  object
  is
  class
  itself or a 
 subclass of 
 class
 . The evaluation of the expression
  (subtypep
  class1 
 class2
 )
  returns the values
  t
  and
  t
  if
  class1
  is a subclass of
  class2
  or if they 
 are the same class; otherwise it returns the values
  nil
  and
  t
 . If
  I
  is an 
 instance of some class
  C
  named
  S
  and
  C
  is an instance of
  standard-class
 , the 
 evaluation of the expression
  (type-of
  I
  )
  will return
  S
  if
  S
  is the proper 
 name of
  C
 ; if
  S 
 is not the proper name of
  C
 , the expression
  (type-of
  I
  )
  will 
 return
  C
 .
  
 Because the names of classes and class objects are type specifiers, they may 
 be used in the special operator
  the
  and in type declarations.
  
 Many but not all of the predefined Common Lisp type specifiers have a 
 corresponding class with the same proper name as the type. These type 
 specifiers are listed in table 28.1. For example, the type
  array
  has a corre-
 sponding class named
  array
 . No type specifier that is a list, such as
  (vector 
 double-float 100)
 , has a corresponding class. The form
  deftype
  does not 
 create any classes.
  
 Each class that corresponds to a predefined Common Lisp type specifier 
 can be implemented in one of three ways, at the discretion of each imple-",NA
28.1.5 Determining the Class Precedence List,"The
  defclass
  form for a class provides a total ordering on that class and its 
 direct superclasses. This ordering is called the
  local precedence order
 . It is 
 an ordered list of the class and its direct superclasses. The
  class precedence 
 list 
 for a class
  C
  is a total ordering on
  C
  and its superclasses that is 
 consistent with the local precedence orders for
  C
  and its superclasses.
  
 A class precedes its direct superclasses, and a direct superclass precedes 
 all other direct superclasses specified to its right in the superclasses list of 
 the
  defclass
  form. For every class
  C
 , define
  
 R
 C
  =
  {
 (
 C, C
 1
 )
 ,
  (
 C
 1
 , C
 2
 )
 , . . . ,
  (
 C
 n−
 1
 , C
 n
 )
 }
  
 where
  C
 1
 , . . . , C
 n
  are the direct superclasses of
  C
  in the order in which they 
 are mentioned in the
  defclass
  form. These ordered pairs generate the total 
 ordering on the class
  C
  and its direct superclasses.
  
 Let
  S
 C
  be the set of
  C
  and its superclasses. Let
  R
  be
  
 R
  = 
 R
 c
  
 c ⟨ S
 C
  
 The set
  R
  may or may not generate a partial ordering, depending on 
 whether the
  R
 c
 ,
  c ⟨ S
 C
 , are consistent; it is assumed that they are consistent 
 and that
  R
  generates a partial ordering. When the
  R
 c
  are not consistent, it is 
 said that
  R
  is inconsistent.
  
 To compute the class precedence list for
  C
 , topologically sort the 
 elements of
  S
 C
  with respect to the partial ordering generated by
  R
 . When 
 the topo-logical sort must select a class from a set of two or more classes, 
 none of which are preceded by other classes with respect to
  R
 , the class 
 selected is chosen deterministically, as described below. If
  R
  is inconsistent, 
 an error is signaled.",NA
28.1.6 Generic Functions and Methods,"A
  generic function
  is a function whose behavior depends on the classes or 
 identities of the arguments supplied to it. 
  
 The
  methods
  define the class-
 specific behavior and operations of the generic function. The following sec-
 tions describe generic functions and methods.",NA
28.1.7 Method Selection and Combination,"When a generic function is called with particular arguments, it must deter-
 mine the code to execute. This code is called the
  effective method
  for those 
 arguments. The effective method is a
  combination
  of the applicable methods 
 in the generic function. A combination of methods is a Lisp expression that 
 contains calls to some or all of the methods. If a generic function is called 
 and no methods apply, the generic function
  no-applicable-method
  is 
 invoked.
  
 When the effective method has been determined, it is invoked with the 
 same arguments that were passed to the generic function. Whatever values 
 it returns are returned as the values of the generic function.",NA
28.1.8 Meta-objects,"The implementation of the Object System manipulates classes, methods, 
 and generic functions. The meta-object protocol specifies a set of generic 
 func-tions defined by methods on classes; the behavior of those generic 
 functions defines the behavior of the Object System. The instances of the 
 classes on which those methods are defined are called
  meta-objects
 . 
 Programming at the meta-object protocol level involves defining new 
 classes of meta-objects along with methods specialized on these classes.
  
 Metaclasses
  
 The
  metaclass
  of an object is the class of its class. The metaclass determines 
 the representation of instances of its instances and the forms of inheritance 
 used by its instances for slot descriptions and method inheritance. The 
 meta-class mechanism can be used to provide particular forms of 
 optimization or to tailor the Common Lisp Object System for particular 
 uses. The protocol for defining metaclasses is discussed in the third part of 
 the CLOS specification, The Common Lisp Object System Meta-Object 
 Protocol 30.
  
 Standard Metaclasses
  
 The Common Lisp Object System provides a number of predefined meta-
 classes. These include the classes
  standard-class
 ,
  built-in-class
 , and 
 structure-class
 :
  
 •
  The class
  standard-class
  is the default class of classes defined by 
 defclass
 .
  
 •
  The class
  built-in-class
  is the class whose instances are classes that 
 have special implementations with restricted capabilities. Any class 
 that corresponds to a standard Common Lisp type might be an in-
 stance of
  built-in-class
 . The predefined Common Lisp type specifiers 
 that are required to have corresponding classes are listed in table 
 28.1. It is implementation-dependent whether each of these classes is 
 imple-mented as a built-in class.
  
 •
  All classes defined by means of
  defstruct
  are instances of
  structure-class
 .",NA
28.1.9 Object Creation and Initialization,"The generic function
  make-instance
  creates and returns a new instance of 
 a class. The first argument is a class or the name of a class, and the 
 remaining arguments form an
  initialization argument
  list.
  
  
 The initialization of a new instance consists of several distinct steps, in-
 cluding the following: combining the explicitly supplied initialization argu-
 ments with default values for the unsupplied initialization arguments, 
 check-ing the validity of the initialization arguments, allocating storage for 
 the instance, filling slots with values, and executing user-supplied methods 
 that perform additional initialization. 
  
 Each step of
  make-instance
  is 
 imple-mented by a generic function to provide a mechanism for customizing 
 that step. In addition,
  make-instance
  is itself a generic function and thus 
 also can be customized.",NA
28.1.10 ,NA,NA
Redefining Classes,"A class that is an instance of
  standard-class
  can be redefined if the new 
 class will also be an instance of
  standard-class
 . Redefining a class modifies 
 the existing class object to reflect the new class definition; it does not create 
 a new class object for the class. Any method object created by a
  :reader
 ,
  
 :writer
 , or
  :accessor
  option specified by the old
  defclass
  form is removed 
 from the corresponding generic function. Methods specified by the new
  
 defclass
  form are added.
  
 When the class
  C
  is redefined, changes are propagated to its instances 
 and to instances of any of its subclasses. Updating such an instance occurs 
 at an implementation-dependent time, but no later than the next time a slot 
 of that instance is read or written. Updating an instance does not change its 
 identity as defined by the
  eq
  function. The updating process may change 
 the slots of that particular instance, but it does not create a new instance. 
 Whether updating an instance consumes storage is implementation-
 dependent.
  
 Note that redefining a class may cause slots to be added or deleted. If a 
 class is redefined in a way that changes the set of local slots accessible",NA
28.1.11 ,NA,NA
Changing the Class of an Instance,"The function
  change-class
  can be used to change the class of an instance 
 from its current class,
  C
 from
 , to a different class,
  C
 to
 ; it changes the structure 
 of the instance to conform to the definition of the class
  C
 to
 .
  
 Note that changing the class of an instance may cause slots to be added or 
 deleted.
  
 When
  change-class
  is invoked on an instance, a two-step updating pro-
 cess takes place. The first step modifies the structure of the instance by 
 adding new local slots and discarding local slots that are not specified in the 
 new version of the instance. The second step initializes the newly added 
 local slots and performs any other user-defined actions. These steps are 
 further described in the following two sections.
  
 Modifying the Structure of an Instance
  
 In order to make an instance conform to the class
  C
 to
 , local slots specified by 
 the class
  C
 to
  that are not specified by the class
  C
 from
  are added, and local 
 slots not specified by the class
  C
 to
  that are specified by the class
  C
 from
  are 
 discarded.
  
 The values of local slots specified by both the class
  C
 to
  and the class 
 C
 from
  are 
 retained. If such a local slot was unbound, it remains unbound.
  
 The values of slots specified as shared in the class
  C
 from
  and as local in the 
 class
  C
 to
  are retained.
  
 This first step of the update does not affect the values of any shared slots.",NA
28.1.12 ,NA,NA
Reinitializing an Instance,"The generic function
  reinitialize-instance
  may be used to change the values 
 of slots according to initialization arguments.
  
 The process of reinitialization changes the values of some slots and per-
 forms any user-defined actions.
  
 Reinitialization does not modify the structure of an instance to add or delete 
 slots, and it does not use any
  :initform
  forms to initialize slots.
  
 The generic function
  reinitialize-instance
  may be called directly. It 
  
  
 It also takes any number of takes one required argument, the instance.
  
 initialization arguments to be used by methods for
  reinitialize-instance
  or 
 for
  shared-initialize
 . The arguments after the required instance must form 
 an initialization argument list.
  
 There is a system-supplied primary method for
  reinitialize-instance 
 whose parameter specializer is the class
  standard-object
 . First this 
 method checks the validity of initialization arguments and signals an error 
 if an ini-tialization argument is supplied that is not declared valid (see 
 section 28.1.9). Then it calls the generic function
  shared-initialize
  with the 
 following ar-guments: the instance,
  nil
 , and the initialization arguments it 
 received.
  
 Customizing Reinitialization
  
 Methods for the generic function
  reinitialize-instance
  may be defined to 
 specify actions to be taken when an instance is updated. 
  
 If only
  :after 
 methods for
  reinitialize-instance
  are defined, they will be run after the 
 system-supplied primary method for initialization and therefore will not in-
 terfere with the default behavior of
  reinitialize-instance
 .
  
 Methods for
  shared-initialize
  may be defined to customize class redefi-
 nition (see section 28.1.9).",NA
28.2 Functions in the Programmer Interface,"This section describes the functions, macros, special operators, and generic 
 functions provided by the Common Lisp Object System Programmer Inter-
 face. The Programmer Interface comprises the functions and macros that 
 are sufficient for writing most object-oriented programs.
  
 This section is reference material that requires an understanding of the",NA
Chapter 29,NA,NA
Conditions,"Author: Kent M. Pitman 
  
 This chapter presents the bulk of the Common Lisp Condition System 
 proposal, written by Kent M. Pitman and amended by X3J13. I have edited it 
 only very lightly to conform to the overall style of this book and have 
 inserted a small number of bracketed remarks identified by the initials GLS. 
 Please see the Acknowledgments to this second edition for the author’s ac-
 knowledgments to others who contributed to the Condition System 
 proposal.
  
 —Guy L. Steele Jr.",NA
29.1 Introduction,"Often we find it useful to describe a function in terms of its behavior 
 in“normal situations.” For example, we may say informally that the function 
 +
  returns the sum of its arguments or that the function
  read-char
  returns 
 the next available character on a given input stream.
  
 Sometimes, however, an “exceptional situation” will arise that does not 
 fit neatly into such descriptions. For example,
  +
  might receive an argument 
 that is not a number, or
  read-char
  might receive as a single argument a 
 stream that has no more available characters. This distinction between 
 normal and exceptional situations is in some sense arbitrary but is often 
 very useful in practice.
  
 For example, suppose a function
  f
  were defined to allow only integer 
 arguments but also guaranteed to detect and signal an error for non-integer 
 arguments. Such a description is in fact internally inconsistent (that is,
  
 923",NA
29.2 Changes in Terminology,"In this section, we introduce changes to the terminology defined in sec-tion 
 1.2.4.
  
 A
  condition
  is an interesting situation in a program that has been de-
 tected and announced. Later we allow this term also to refer to objects that 
 programs use to represent such situations.
  
 An
  error
  is a condition in which normal program execution may not 
 continue without some form of intervention (either interactively by the 
 user or under some sort of program control, as described below).
  
 The process by which a condition is formally announced by a program is 
 called
  signaling
 . The function
  signal
  is the primitive mechanism by which 
 such announcement is done. Other abstractions, such as
  error
  and
  cerror
 , 
 are built using
  signal
 .
  
 The first edition is ambiguous about the reason why a particular 
 program action “is an error.” There are two principal reasons why an action 
 may be an error without being required to signal an error:
  
 •
  Detecting the error might be prohibitively expensive.
  
 For example,
  (+ nil 3)
  is an error. It is likely that the designers of 
 Common Lisp believed this would be an error in all implementations 
 but felt it might be excessively expensive to detect the problem in 
 compiled code on stock hardware, so they did not require that it 
 signal an error.
  
 •
  Some implementations might implement the behavior as an extension. 
 For example,
  (loop for x from 1 to 3 do (print x))
  is an error 
 because
  loop
  is not defined to take atoms in its body. In fact, however, 
 some implementations offer an extension that makes this well-
 defined. In order to leave room for such extensions, the first edition 
 used the “is an error” terminology to keep implementors from being 
 forced to signal an error in the extended implementations.
  
 [This example was written well before the vote by X3J13 in January 
 1989 to add exactly this extension to the forthcoming draft standard 
 (see chapter 26).—GLS]
  
 In this chapter, we use the following terminology. [Compare this to the 
 terminology presented in section 28.1.1.—GLS]",NA
29.3 Survey of Concepts,"This section discusses various aspects of the condition system by topic, 
 illus-trating them with extensive examples. The next section contains 
 definitions of specific functions, macros, and other facilities.",NA
29.3.1 Signaling Errors,NA,NA
29.3.2 Trapping Errors,"By default, a call to
  error
  will force entry into the debugger. 
  
 You can 
 override that behavior in a variety of ways. The simplest (and most blunt) 
 tool for inhibiting entry to the debugger on an error is to use
  ignore-errors
 . 
 In the normal situation, forms in the body of
  ignore-errors
  are evaluated 
 sequentially and the last value is returned. If a condition of type
  error
  is 
 signaled,
  ignore-errors
  immediately returns two values, namely
  nil
  and the 
 condition that was signaled; the debugger is not entered and no error 
 message is printed. For example:
  
 Lisp> (setq filename ""nosuchfile"")
  
 Lisp> (ignore-errors (open filename :direction :input))
 ⟨
  ""nosuchfile""
  
 ⟨
  NIL and #<FILE-ERROR 3437523>
  
 The second return value is an object that represents the kind of error. This is 
 explained in greater detail in section 29.3.4.
  
 In many cases, however,
  ignore-errors
  is not desirable because it deals 
 with too many kinds of errors. Contrary to the belief of some, a program 
 that does not enter the debugger is not necessarily better than one that 
 does. Excessive use of
  ignore-errors
  may keep the program out of the 
 debugger, but it may not increase the program’s reliability, because the 
 program may continue to run after encountering errors other than those 
 you meant to work past. In general, it is better to attempt to deal only with 
 the particular kinds of errors that you believe could legitimately happen. 
 That way, if an unexpected error comes along, you will still find out about it.
  
 ignore-errors
  is a useful special case built from a more general facility, 
 handler-case
 , that allows the programmer to deal with particular kinds of 
 conditions (including non-error conditions) without affecting what happens 
 when other kinds of conditions are signaled. For example, an effect 
 equivalent to that of
  ignore-errors
  above is achieved in the following 
 example:
  
 Lisp> (setq filename ""nosuchfile"")
  
 Lisp> (handler-case (open filename :direction :input)
 ⟨
  ""nosuchfile""
  
 (error (condition) 
  
  
  
 (values nil condition)))
  
 ⟨
  NIL and #<FILE-ERROR 3437525>",NA
29.3.3 Handling Conditions,"Blind transfer of control to a
  handler-case
  is only one possible kind of 
 recovery action that can be taken when a condition is signaled. The low-
 level mechanism offers great flexibility in how to continue once a condition 
 has been signaled.
  
 The basic idea behind condition handling is that a piece of code called 
 the 
 signaler
  recognizes and announces the existence of an exceptional 
 situation using
  signal
  or some function built on
  signal
  (such as
  error
 ).
  
 The process of signaling involves the search for and invocation of a
  han-
 dler
 , a piece of code that will attempt to deal appropriately with the 
 situation.
  
 If a handler is found, it may either
  handle
  the situation, by performing 
 some non-local transfer of control, or
  decline
  to handle it, by failing to per-
 form a non-local transfer of control. If it declines, other handlers are sought.
  
 Since the lexical environment of the signaler might not be available to 
 handlers, a data structure called a
  condition
  is created to represent 
 explicitly the relevant state of the situation. A condition either is created 
 explicitly using
  make-condition
  and then passed to a function such as
  
 signal
 , or is created implicitly by a function such as
  signal
  when given 
 appropriate non-condition arguments.",NA
29.3.4 Object-Oriented Basis of Condition Handling,"Of course, the ability of the handler to usefully handle an exceptional situa-
 tion is related to the quality of the information it is provided. For example, if 
 all errors were signaled by",NA
29.3.5 Restarts,"The Common Lisp Condition System creats a clear separation between the 
 act of signaling an error of a particular type and the act of saying that a 
 particular way of recovery is appropriate. 
  
 In the
  divide
  example above, 
 simply signaling an error does not imply a willingness on the part of the 
 signaler to cooperate in any corrective action. For example, the following 
 sample interaction illustrates that the only recovery action offered for this 
 error is “Return to Lisp Toplevel”:
  
 Lisp> (+ (divide 3 0) 7) 
  
 Error: Attempt to divide 3 by 0.
  
 To continue, type :CONTINUE followed by an option number: 
 1: Return to Lisp Toplevel.
  
 Debug> :continue 1 
  
 Returned to Lisp Toplevel.
  
 Lisp>
  
 When an error is detected and the function
  error
  is called, execution 
 cannot continue normally because
  error
  will not directly return. Control",NA
29.3.6 Anonymous Restarts,"The simplest kind of restart involves structured transfer of control using a 
 macro called
  restart-case
 . The
  restart-case
  form allows execution of a 
 piece of code in a context where zero or more restarts are active, and where 
 if one of those restarts is “invoked,” control will be transferred to the 
 corresponding clause in the
  restart-case
  form. For example, we could 
 rewrite the previous
  divide
  example as follows.
  
 (defun divide (numerator denominator) 
  
 (loop 
  
  
 (restart-case 
  
    
 (return 
  
      
 (cond ((or (not (numberp numerator)) 
  
        
   
 (not (numberp denominator))) 
  
        
  
 (error ""(DIVIDE ’~S ’~S) - Bad arguments."" 
  
        
    
  
 numerator denominator)) 
  
        
 ((zerop denominator) 
  
        
  
 (error ’division-by-zero 
  
        
    
  
 :operator ’divide 
  
        
    
  
 :operands (list numerator denominator))) 
        
 (t ...))) 
  
   
 (nil (arg1 arg2) 
  
      
 :report ""Provide new arguments for use by DIVIDE."" 
      
 :interactive 
  
      
 (lambda () 
  
        
 (list (prompt-for ’number ""Numerator: "") 
  
        
   
 (prompt-for ’number ""Denominator: ""))) 
  
   
 (setq numerator arg1 denominator arg2)) 
  
   
 (nil (result) 
  
      
 :report ""Provide a value to return from DIVIDE."" 
  
     
 :interactive 
  
      
 (lambda () (list (prompt-for ’number ""Result: ""))) 
  
   
 (return result)))))",NA
Named Restarts,CHAPTER 29. CONDITIONS,NA
29.3.7,"In addition to anonymous restarts, one can have named restarts, which can 
 be invoked by name from within code. As a trivial example, one could write
  
 (restart-case (invoke-restart ’foo 3) 
  
 (foo (x) (+ x 1)))
  
  
 to add
  3
  to
  1
 , returning
  4
 . This trivial example is conceptually analogous 
 to writing:
  
 (+ (catch ’something (throw ’something 3)) 1)
  
  
 For a more realistic example, the code for the function
  symbol-value 
 might signal an unbound variable error as follows:
  
 (restart-case (error ""The variable ~S is unbound."" variable) 
 (continue () 
  
   
 :report 
  
    
 (lambda (s) 
  
 ;Argument
  s
  is a stream 
  
      
 (format s ""Retry getting the value of ~S."" variable)) 
  
 (symbol-value variable)) 
  
 (use-value (value) 
  
   
 :report 
  
    
 (lambda (s) 
  
 ;Argument
  s
  is a stream 
  
      
 (format s ""Specify a value of ~S to use this time."" 
  
     
 variable)) 
  
  
 value) 
  
 (store-value (value) 
  
   
 :report 
  
    
 (lambda (s) 
  
 ;Argument
  s
  is a stream 
  
      
 (format s ""Specify a value of ~S to store and use."" 
  
     
 variable)) 
  
  
 (setf (symbol-value variable) value) 
  
  
 value))
  
 If this were part of the implementation of
  symbol-value
 , then it would 
 be possible for users to write a variety of automatic handlers for unbound 
 variable errors. For example, to make unbound variables evaluate to them-
 selves, one might write",NA
29.3.8,NA,NA
Restart Functions,"For commonly used restarts, it is conventional to define a program interface 
 that hides the use of
  invoke-restart
 . Such program interfaces to restarts 
 are called
  restart functions
 .
  
 The normal convention is for the function to share the name of the 
 restart. The pre-defined functions
  abort
 ,
  continue
 ,
  muffle-warning
 ,
  store-
 value
 , and
  use-value
  are restart functions. With
  use-value
  the above 
 example of 
 handler-bind
  could have been written more concisely as
  
 (handler-bind ((unbound-variable 
  
  
 #’(lambda (c) 
  
 ;Argument
  c
  is a condition 
   
 (use-
 value (cell-error-name c))))) 
  
 body
 )",NA
29.3.9 Comparison of Restarts and Catch/Throw,"One important feature that
  restart-case
  (or
  restart-bind
 ) offers that 
 catch
  
 does not is the ability to reason about the available points to which control 
 might be transferred without actually attempting the transfer. One could, 
 for example, write
  
 (ignore-errors (throw ...))
  
 which is a sort of poor man’s variation of
  
 (when (find-restart ’something) 
  
 (invoke-restart ’something))
  
 but there is no way to use
  ignore-errors
  and
  throw
  to simulate some-thing 
 like",NA
29.3.10 ,NA,NA
Generalized Restarts,"restart-case
  is a mechanism that allows only imperative transfer of control 
 for its associated restarts.
  restart-case
  is built on a lower-level mechanism 
 called
  restart-bind
 , which does not force transfer of control.
  
 restart-bind
  is to
  restart-case
  as
  handler-bind
  is to
  handler-case
 .
  
 The syntax is
  
 (restart-bind ((
 name function
  .
  options
 )) .
  body
 )
  
 The
  body
  is executed in a dynamic context within which the
  function
  will 
 be called whenever
  (invoke-restart ’
 name
 )
  is executed. The
  options
  are 
 keyword-style and are used to pass information such as that provided with 
 the
  :report
  keyword in
  restart-case
 .
  
 A
  restart-case
  expands into a call to
  restart-bind
  where the function 
 simply does an unconditional transfer of control to a particular body of 
 code, passing along “argument” information in a structured way.
  
 It is also possible to write restarts that do not transfer control. Such 
 restarts may be useful in implementing various special commands for the 
 debugger that are of interest only in certain situations. For example, one 
 might imagine a situation where file space was exhausted and the following 
 was done in an attempt to free space in directory
  dir
 :
  
 (restart-bind ((nil #’(lambda () (expunge-directory dir)) 
   
  
 :report-function 
  
   
  
  
 #’(lambda (stream) 
  
   
  
   
 (format stream ""Expunge ~A."" 
  
   
  
   
 (directory-namestring dir))))) 
 (cerror ""Try this file operation again.""
  
   
 ’directory-full :directory dir))
  
 In this case, the debugger might be entered and the user could first per-
 form the expunge (which would not transfer control from the debugger 
 con-text) and then retry the file operation:
  
 Lisp> (open ""FOO"" :direction :output) 
  
 Error: The directory PS:<JDOE> is full.
  
 To continue, type :CONTINUE followed by an option number: 
 1: Try this file operation again.
  
 2: Expunge PS:<JDOE>.",NA
29.3.11 ,NA,NA
Interactive Condition Handling,"When a program does not know how to continue, and no active handler is 
 able to advise it, the “interactive condition handler,” or “debugger,” can be 
 entered. This happens implicitly through the use of functions such as
  error 
 and
  cerror
 , or explicitly through the use of the function
  invoke-debugger
 .
  
 The interactive condition handler never returns directly; it returns only 
 through structured non-local transfer of control to specially defined restart 
 points that can be set up either by the system or by user code. The mech-
 anisms that support the establishment of such structured restart points for 
 portable code are outlined in sections 29.3.5 through 29.3.10.
  
 Actually, implementations may also provide extended debugging 
 facilities that allow return from arbitrary stack frames. Although such 
 commands 
 are 
 frequently 
 useful 
 in 
 practice, 
 their 
 effects 
 are 
 implementation-dependent because they violate the Common Lisp program 
 abstraction. The effect of using such commands is undefined with respect to 
 Common Lisp.",NA
29.3.12 ,NA,NA
Serious Conditions,"The
  ignore-errors
  macro will trap conditions of type
  error
 . There are, 
 however, conditions that are not of type
  error
 .
  
 Some conditions are not considered errors but are still very serious, so 
 we call them
  serious conditions
  and we use the type
  serious-condition
  to 
 represent them. Conditions such as those that might be signaled for “stack 
 overflow” or “storage exhausted” are in this category.
  
 The type
  error
  is a subtype of
  serious-condition
 , and it would tech-
 nically be correct to use the term “serious condition” to refer to all serious 
 conditions whether errors or not. However, normally we use the term “seri-
 ous condition” to refer to things of type
  serious-condition
  but not of type 
 error
 .
  
 The point of the distinction between errors and other serious conditions 
 is that some conditions are known to occur for reasons that are beyond the 
 scope",NA
29.3.13 ,NA,NA
Non-Serious Conditions,"Some conditions are neither errors nor serious conditions. They are 
 signaled to give other programs a chance to intervene, but if no action is 
 taken, com-putation simply continues normally.
  
 For example, an implementation might choose to signal a non-serious 
 (and implementation-dependent) condition called
  end-of-line
  when output 
 reaches the last character position on a line of character output. In such an 
 implementation, the signaling of this condition might allow a convenient 
 way for other programs to intervene, producing output that is truncated at 
 the end of a line.
  
 By convention, the function
  signal
  is used to signal conditions that are 
 not serious. It would be possible to signal serious conditions using
  signal
 , 
 and the debugger would not be entered if the condition went unhandled. 
 However, by convention, handlers will generally tend to assume that 
 serious conditions and errors were signaled by calling the
  error
  function 
 (and will therefore force entry to the interactive condition handler) and 
 that they should work to avoid this.",NA
29.3.14 ,NA,NA
Condition Types,"Some types of conditions are predefined by the system. All types of 
 conditions are subtypes of
  condition
 . That is,
  (typep
  x
  ’condition)
  is true if 
 and only if the value of
  x
  is a condition.
  
  
 Implementations supporting multiple (or non-hierarchical) type inheri-
 tance are expressly permitted to exploit multiple inheritance in the tree of 
 condition types as implementation-dependent extensions, as long as such 
 ex-tensions are compatible with the specifications in this chapter. [X3J13 
 voted in March 1989 to integrate the Condition System and the Object 
 System, so multiple inheritance is always available for condition types.—
 GLS] 
  
  
 In order to avoid problems in portable code that runs both in systems 
 with multiple type inheritance and in systems without it, programmers are 
 explicitly warned that while all correct Common Lisp implementations will 
 ensure that
  (typep
  c
  ’condition)
  is true for all conditions
  c
  (and all subtype 
 relationships indicated in this chapter will also be true), it should
  not
  be 
 assumed that two condition types specified to be subtypes of the same third 
 type are disjoint. (In some cases, disjoint subtypes are identified explicitly, 
 but such disjointness is not to be assumed by default.) 
  
 For example, it 
 follows from the subtype descriptions contained in this chapter that in all 
 implementations
  (typep
  c
  ’control-error)
  implies
  (typep
  c
  ’error)
 , but 
 note that
  (typep
  c
  ’control-error)
  does
  not
  imply
  (not (typep
  c
  ’cell-
 error))
 .",NA
29.3.15 ,NA,NA
Signaling Conditions,"When a condition is signaled, the system tries to locate the most appropriate 
 handler for the condition and to invoke that handler.
  
  
 Handlers are established dynamically using
  handler-bind
  or abstrac-
 tions built on
  handler-bind
 .
  
 If an appropriate handler is found, it is called. In some circumstances, 
 the handler may
  decline
  simply by returning without performing a non-
 local transfer of control. In such cases, the search for an appropriate 
 handler is picked up where it left off, as if the called handler had never been 
 present.
  
  
 If no handler is found, or if all handlers that were found decline,
  signal 
 returns
  nil
 .
  
 Although it follows from the description above, it is perhaps worth 
 noting explicitly that the lookup procedure described here will prefer a 
 general but",NA
29.3.16 ,NA,NA
Resignaling Conditions,"[The contents of this section are still a subject of some debate within X3J13.
  
 The reader may wish to take this section with a grain of salt.—GLS] Note that 
 signaling a condition has no side effect on that condition, and that there is no 
 dynamic state contained in a condition object. As such, it may at times be 
 reasonable and appropriate to consider caching condition objects for 
 repeated use, re-signaling conditions from within handlers, or saving 
 conditions away somewhere and re-signaling them later.
  
 For example, it may be desirable for the system to pre-allocate objects of 
 type
  storage-condition
  so that they can be signaled when needed without 
 attempting to allocate more storage.",NA
29.3.17 ,NA,NA
Condition Handlers,"A
  handler
  is a function of one argument, the condition to be handled. The 
 handler may inspect the object to be sure it is “interested” in handling the 
 condition.
  
 A handler is executed in the dynamic context of the signaler, except that 
 the set of available condition handlers will have been rebound to the value 
 that was active at the time the condition handler was made active. The 
 intent of this is to prevent infinite recursion because of errors in a condition 
 handler.
  
 After inspecting the condition, the handler should take one of the follow-ing 
 actions:
  
 •
  It might
  decline
  to handle the condition (by simply returning). When 
 this happens, the returned values are ignored and the effect is the 
 same as if the handler had been invisible to the mechanism seeking to 
 find a handler. The next handler in line will be tried, or if no such 
 handler exists, the condition will go unhandled.",NA
29.3.18 ,NA,NA
Printing Conditions,"When
  *print-escape*
  is
  nil
  (for example, when the
  princ
  function or the 
 ~A
  directive is used with
  format
 ), the report method for the condition will 
 be invoked. This will be done automatically by functions such as
  invoke-
 debugger
 ,
  break
 , and
  warn
 , but there may still be situations in which it is 
 desirable to have a condition report under explicit user control. For 
 example,
  
 (let ((form ’(open ""nosuchfile""))) 
  
 (handler-case (eval form) 
  
  
 (serious-condition (c) 
  
   
 (format t ""~&Evaluation of ~S failed:~%~A"" form c))))
  
 might print something like
  
 Evaluation of (OPEN ""nosuchfile"") failed: 
  
 The file ""nosuchfile"" was not found.
  
 Some suggestions about the form of text typed by report methods:
  
 •
  The message should generally be a complete sentence, beginning with a 
 capital letter and ending with appropriate punctuation (usually a 
  
 period).
  
 •
  The message should
  not
  include any introductory text such as 
 “
 Error:
 ”or “
 Warning:
 ” and should not be followed by a trailing",NA
29.4 Program Interface to the Condition Sys-,NA,NA
tem,"This section describes functions, macros, variables, and condition types as-
 sociated with the Common Lisp Condition System.",NA
29.4.1 Signaling Conditions,"The functions in this section provide various mechanisms for signaling 
 warn-ings, breaks, continuable errors, and fatal errors.
  
 [Function]
  error
  datum
  &rest
  arguments
  
  
 Invokes the signal facility on a condition. If the condition is not handled, 
 (invoke-debugger
  condition
 )
  is executed. As a consequence of calling 
 invoke-debugger
 ,
  error
  never directly returns to its caller; the only exit 
 from this function can come by non-local transfer of control in a handler or 
 by use of an interactive debugging command.
  
 If
  datum
  is a condition, then that condition is used directly. In this case, 
 it is an error for the list of
  arguments
  to be non-empty; that is,
  error
  must 
 have been called with exactly one argument, the condition.
  
 If
  datum
  is a condition type (a class or class name), then the condition 
 used is effectively the result of
  (apply #’make-condition
  datum argu-
 ments
 )
 .
  
 If
  datum
  is a string, then the condition used is effectively the result of
  
 (make-condition ’simple-error 
  
 :format-string
  datum 
  
 :format-arguments
  
 arguments
 )",NA
29.4.2 Assertions,"These facilities are designed to make it convenient for the user to insert 
 error checks into code.
  
 [Macro]
  check-type
  place typespec [string]
  
 A
  check-type
  form signals an error of type
  type-error
  if the contents of
  
 place
  are not of the desired type.
  
 If a condition is signaled, handlers of this condition can use the functions 
 type-error-datum
  and
  type-error-expected-type
  to access the contents 
 of
  place
  and the
  typespec
 , respectively.
  
 This function can return only if the
  store-value
  restart is invoked, 
 either explicitly from a handler or implicitly as one of the options offered by 
 the debugger. The restart is associated with the signaled condition as if by 
 use of
  with-condition-restarts
 .
  
 If
  store-value
  is called,
  check-type
  will store the new value that is the 
 argument to
  store-value
  (or that is prompted for interactively by the 
 debugger) in
  place
  and start over, checking the type of the new value and 
 signaling another error if it is still not the desired type. Subforms of
  place
  
 may be evaluated multiple times because of the implicit loop generated.
  
 check-type
  returns
  nil
 .
  
 The
  place
  must be a generalized variable reference acceptable to
  setf
 . The 
 typespec
  must be a type specifier; it is not evaluated. The
  string
  should be an 
 English description of the type, starting with an indefinite article (“a” or 
 “an”); it is evaluated. If the
  string
  is not supplied, it is computed 
 automatically from the
  typespec
 . (The optional
  string
  argument is allowed 
 because some applications of
  check-type
  may require a more specific 
 description of what is wanted than can be generated automatically from the 
 type specifier.) The error message will mention the
  place
 , its contents, and 
 the desired type.
  
 Implementation note:
  An implementation may choose to generate a somewhat 
 differently worded error message if it recognizes that
  place
  is of a particular form, 
 such as one of the arguments to the function that called
  check-type
 .",NA
29.4.3 Exhaustive Case Analysis,"The syntax for
  etypecase
  and
  ctypecase
  is the same as for
  typecase
 , except 
 that no
  otherwise
  clause is permitted. 
  
 Similarly, the syntax for 
 ecase
  and
  ccase
  is the same as for
  case
  except for the
  otherwise
  clause.
  
 etypecase
  and
  ecase
  are similar to
  typecase
  and
  case
 , respectively, but 
 signal a non-continuable error rather than returning
  nil
  if no clause is 
 selected.
  
  
 ctypecase
  and
  ccase
  are also similar to
  typecase
  and
  case
 , respectively, 
 but signal a continuable error if no clause is selected.
  
 [Macro]
  etypecase
  keyform {(type {form}*)}*
  
  
 This control construct is similar to
  typecase
 , but no explicit
  otherwise 
 or
  t
  clause is permitted. If no clause is satisfied,
  etypecase
  signals an error 
 (of type
  type-error
 ) with a message constructed from the clauses. It is not 
 permissible to continue from this error. To supply an error message, the 
 user should use
  typecase
  with an
  otherwise
  clause containing a call to
  
 error
 . The name of this function stands for “exhaustive type case” or “error-
 checking type case.”
  
  
 Example:
  
 Lisp> (setq x 1/3)
  
 ⟨
  1/3",NA
29.4.4,NA,NA
Handling Conditions,"These macros allow a program to gain control when a condition is signaled.
  
 [Macro]
  handler-case
  expression {(typespec ([var]) {form}*)}*
  
 Executes the given
  expression
  in a context where various specified han-dlers 
 are active.
  
 Each
  typespec
  may be any type specifier. If during the execution of the 
 expression
  a condition is signaled for which there is an appropriate clause—
 that is, one for which
  (typep
  condition
  ’
 typespec
 )
  is true—and if there is 
 no intervening handler for conditions of that type, then control is 
 transferred to the body of the relevant clause (unwinding the dynamic state 
 appropriately in the process) and the given variable
  var
  is bound to the 
 condition that was signaled. If no such condition is signaled and the 
 computation runs to completion, then the values resulting from the
  
 expression
  are returned by the
  handler-case
  form.
  
 If more than one case is provided, those cases are made accessible in 
 parallel. That is, in
  
 (handler-case
  expression 
  
 (
 type
 1
  (
 var
 1
 )
  form
 1
 ) 
  
 (
 type
 2
  (
 var
 2
 )
  form
 2
 ))
  
 if the first clause (containing
  form
 1
 ) has been selected, the handler for the 
 second is no longer visible (and vice versa).
  
 The cases are searched sequentially from top to bottom. If a signaled 
 condition matches more than one case (possible if there is type overlap) the 
 earlier of the two cases will be selected.
  
 If the variable
  var
  is not needed, it may be omitted. That is, a clause such as
  
 (
 type
  (
 var
 ) (declare (ignore
  var
 ))
  form
 )
  
 may be written using the following shorthand notation:
  
 (
 type
  ()
  form
 )",NA
29.4.5 Defining Conditions,"[The contents of this section are still a subject of some debate within X3J13. 
 The reader may wish to take this section with a grain of salt, two aspirin 
 tablets, and call a hacker in the morning.—GLS]
  
 [Macro]
  define-condition
  name ({parent-type}*) 
 [({slot-specifier}*) {option}*]
  
  
 Defines a new condition type called
  name
 , which is a subtype of each 
 given 
 parent-type
 . Except as otherwise noted, the arguments are not 
 evaluated.
  
 Objects of this condition type will have all of the indicated
  slot
 s, plus any 
 additional slots inherited from the parent types (its superclasses). If the 
 slot
 s list is omitted, the empty list is assumed.
  
 A
  slot
  must have the form
  
 slot-specifier
  ::=
  slot-name
  | (
 slot-name
  [[
 ↓slot-option
  ]])",NA
29.4.6 Creating Conditions,"The function
  make-condition
  is the basic means for creating condition ob-
 jects.
  
 [Function]
  make-condition
  type
  &rest
  slot-initializations
  
 Constructs a condition object of the given
  type
  using
  slot-initializations 
 as a specification of the initial value of the slots. The newly created 
 condition is returned.
  
 The
  slot-initializations
  are alternating keyword/value pairs. For example:
  
 (make-condition ’peg/hole-mismatch 
  
  
 :peg-shape ’square :hole-shape ’round)",NA
Establishing Restarts,CHAPTER 29. CONDITIONS,NA
29.4.7,"The lowest-level form that creates restart points is called
  restart-bind
 . The 
 restart-case
  macro is an abstraction that addresses many common needs 
 for 
 restart-bind
  while offering a more palatable syntax. See also
  with-
 simple-restart
 . The function that transfers control to a restart point 
 established by one of these macros is called
  invoke-restart
 .
  
  
 All restarts have dynamic extent; a restart does not survive execution of 
 the form that establishes it.
  
 [Macro]
  with-simple-restart
  (name format-string {format-argument}*) 
 {form}*
  
 This is shorthand for one of the most common uses of
  restart-case
 .
  
  
 If the restart designated by
  name
  is not invoked while executing the 
 form
 s, all values returned by the last
  form
  are returned. 
  
 If that restart 
 is invoked, control is transferred to the
  with-simple-restart
  form, which 
 immediately returns the two values
  nil
  and
  t
 .
  
 The
  name
  may be
  nil
 , in which case an anonymous restart is established.
  
 with-simple-restart
  could be defined by
  
 (defmacro with-simple-restart ((restart-name format-string 
   
     
  
 &rest format-arguments) 
  
   
    
 &body forms)
  
 ‘(restart-case (progn ,@forms) 
  
   
 (,restart-name () 
  
   
 :report 
  
   
  
 (lambda (stream) 
  
   
   
 (format stream format-string ,@format-arguments)) 
   
 (values nil t))))
  
 Here is an example of the use of
  with-simple-restart
 .",NA
29.4.8 Finding and Manipulating Restarts,"The following functions determine what restarts are active and invoke 
 restarts.
  
 [Function]
  compute-restarts
  &optional
  condition
  
 Uses the dynamic state of the program to compute a list of the restarts that 
 are currently active. See
  restart-bind
 .
  
 If
  condition
  is
  nil
  or not supplied, all outstanding restarts are returned. If 
 condition
  is not
  nil
 , only restarts associated with that condition are returned.
  
 Each restart represents a function that can be called to perform some 
 form of recovery action, usually a transfer of control to an outer point in the 
 running program. Implementations are free to implement these objects in 
 whatever manner is most convenient; the objects need have only dynamic 
 extent (relative to the scope of the binding form that instantiates them).
  
 The list that results from a call to
  compute-restarts
  is ordered so that 
 the inner (that is, more recently established) restarts are nearer the head of 
 the list.
  
 Note, too, that
  compute-restarts
  returns all valid restarts, including 
 anonymous ones, even if some of them have the same name as others and 
 would therefore not be found by
  find-restart
  when given a symbol 
 argument.
  
 Implementations are permitted, but not required, to return different 
 (that is, non-
 eq
 ) lists from repeated calls to
  compute-restarts
  while in the 
 same dynamic environment. It is an error to modify the list that is returned 
 by 
 compute-restarts
 .
  
 [Function]
  restart-name
  restart
  
 Returns the name of the given
  restart
 , or
  nil
  if it is not named.",NA
29.4.9 Warnings,"Warnings are a subclass of errors that are conventionally regarded as “mild.”
  
 [Function]
  warn
  datum
  &rest
  arguments
  
 Warns about a situation, by signaling a condition of type
  warning
 .
  
 If
  datum
  is a condition, then that condition is used directly. In this case, 
 if the condition is not of type
  warning
  or arguments is non-
 nil
 , an error of 
 type
  type-error
  is signaled.
  
 If
  datum
  is a condition type (a class or class name), then the condition 
 used is effectively the result of
  (apply #’make-condition
  datum argu-
 ments
 )
 . This result must be of type
  warning
  or an error of type
  type-error 
 is signaled.
  
 If
  datum
  is a string, then the condition used is effectively the result of
  
 (make-condition ’simple-error 
  
 :format-string
  datum 
  
 :format-arguments
  
 arguments
 )
  
 The precise mechanism for warning is as follows.
  
 1. The warning condition is signaled.
  
 While the
  warning
  condition is being signaled, the
  muffle-warning 
 restart is established for use by a handler to bypass further action by 
 warn
  (that is, to cause
  warn
  to immediately return
  nil
 ).
  
 As part of the signaling process, if
  (typep
  condition
  *break-on-
 signals*)
  is true, then a
  break
  will occur prior to beginning the sig-
 naling process.
  
 2. If no handlers for the warning condition are found, or if all such han-
 dlers decline, then the condition will be reported to
  *error-output*
  by",NA
29.4.10 ,NA,NA
Restart Functions,"Common Lisp has the following restart functions built in.
  
 [Function]
  abort
  &optional
  condition
  
  
 This function transfers control to the restart named
  abort
 . If no such 
 restart exists,
  abort
  signals an error of type
  control-error
 .
  
 If
  condition
  is
  nil
  or not supplied, all outstanding restarts are consid-
 ered. If
  condition
  is not
  nil
 , only restarts associated with that condition are 
 considered.
  
  
 The purpose of the
  abort
  restart is generally to allow control to return to 
 the innermost “command level.”
  
 [Function]
  continue
  &optional
  condition
  
  
 This function transfers control to the restart named
  continue
 . If no such 
 restart exists,
  continue
  returns
  nil
 .
  
 If
  condition
  is
  nil
  or not supplied, all outstanding restarts are consid-
 ered. If
  condition
  is not
  nil
 , only restarts associated with that condition are 
 considered.
  
  
 The
  continue
  restart is generally part of simple protocols where there is 
 a single “obvious” way to continue, as with
  break
  and
  cerror
 . 
  
 Some 
 user-defined protocols may also wish to incorporate it for similar reasons. 
 In general, however, it is more reliable to design a special-purpose restart 
 with a name that better suits the particular application.
  
 [Function]
  muffle-warning
  &optional
  condition
  
 This function transfers control to the restart named
  muffle-warning
 . If 
 no such restart exists,
  muffle-warning
  signals an error of type
  control-
 error
 .",NA
29.4.11 ,NA,NA
Debugging Utilities,"Common Lisp does not specify exactly what a debugger is or does, but it 
 does provide certain means for indicating intent to transfer control to a 
 supervisory or debugging facility.",NA
29.5 Predefined Condition Types,"[The proposal for the Common Lisp Condition System introduced a new 
 notation for documenting types, treating them in the same syntactic 
 manner as functions and variables. This notation is used in this section but 
 is not reflected throughout the entire book.—GLS]",NA
Chapter 30,NA,NA
Metaobject Protocol,"Book: Art Of Metaobject Protocol 
  
 Chapters 5,6 
  
 Authors: Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow 
 http://www.alu.org/mop/index.html",NA
30.1 Concepts,NA,NA
30.1.1 Introduction,NA,NA
30.1.2Введение,"The CLOS Specification 28 describes the standard Programmer Interface for 
 the Common Lisp Object System (CLOS). This document extends that 
 specification by defining a metaobject protocol for CLOS—that is, a descrip-
 tion of CLOS itself as an extensible CLOS program. In this description, the 
 fundamental elements of CLOS programs (classes, slot definitions, generic 
 functions, methods, specializers and method combinations) are represented 
 by first-class objects. The behavior of CLOS is provided by these objects, or, 
 more precisely, by methods specialized to the classes of these objects.
  
 Because these objects represent pieces of CLOS programs, and because 
 their behavior provides the behavior of the CLOS language itself, they are 
 considered meta-level objects or metaobjects. The protocol followed by the 
 metaobjects to provide the behavior of CLOS is called the CLOS Metaobject 
 Protocol (MOP).
  
 987",NA
30.1.3 Inheritance Structure of Metaobject Classes,"The inheritance structure of the specified metaobject classes is shown in the
  
 table 30.1.
  
 The classes 
  
 standard-class
 , 
  
 standard-direct-slot-definition
 ,
  
 standard-effective-slot-definition
 , 
  
 standard-method
 , 
  
 standard-
  
 reader-method
 , 
 standard-writer-method 
  
 and 
  
 standard-generic-
  
 function
  are called
  standard metaobject classes
 . 
  
 For each kind of
  
 metaobject, this is the class the user interface macros presented in the
  
 CLOS Specification use by default. These are also the classes on which user
  
 specializations are normally based.
  
 The classes
  built-in-class
 ,
  funcallable-standard-class
  and
  forward-
  
 referenced-class
  are special-purpose class metaobject classes. 
  
 Built-in
  
 classes are instances of the class
  built-in-class
 . The class
  funcallable-
  
 standard-class
  provides a special kind of instances described in the sec-
  
 tion 30.1.5. When the definition of a class references another class which has",NA
30.1.4 Processing of the User Interface Macros,"A list in which the first element is one of the symbols
  defclass
 ,
  defmethod
 , 
 defgeneric
 , or
  define-method-combination
 , and which has proper syntax 
 for that macro is called a
  user interface macro form
 . This document pro-
 vides an extended specification of the
  defclass
 ,
  defmethod
  and
  defgeneric 
 macros.
  
 The user interface macros
  defclass
 ,
  defgeneric
  and
  defmethod
  can be 
 used not only to define metaobjects that are instances of the correspond-ing 
 standard metaobject class, but also to define metaobjects that are in-stances 
 of appropriate portable metaobject classes. To make it possible for portable 
 metaobject classes to properly process the information appearing in the 
 macro form, this document provides a limited specification of the 
 processing of these macro forms.
  
 User interface macro forms can be
  evaluated
  or
  compiled
  and later
  exe-
 cuted
 . The effect of evaluating or executing a user interface macro form is 
 specified in terms of calls to specified functions and generic functions which 
 provide the actual behavior of the macro. The arguments received by these 
 functions and generic functions are derived in a specified way from the 
 macro form.
  
 Converting a user interface macro form into the arguments to the appro-
 priate functions and generic functions has two major aspects: the 
 conversion of the macro argument syntax into a form more suitable for 
 later process-ing, and the processing of macro arguments which are forms 
 to be evaluated (including method bodies).
  
 In the syntax of the
  defclass
  macro, the
  initform
  and
  default-initarg-
 initial-value-form
  arguments are forms which will be evaluated one or more 
 times after the macro form is evaluated or executed. Special processing 
 must be done on these arguments to ensure that the lexical scope of the 
 forms is captured properly. This is done by building a function of zero 
 arguments which, when called, returns the result of evaluating the form in 
 the proper lexical environment.
  
 In the syntax of the
  defmethod
  macro the
  form*
  argument is a list of 
 forms that comprise the body of the method definition. This list of forms 
 must be processed specially to capture the lexical scope of the macro form. 
 In addition, the lexical functions available only in the body of methods must 
 be introduced. To allow this and any other special processing (such as slot 
 access optimization), a specializable protocol is used for processing the 
 body",NA
30.1.5 Subprotocols,"This section provides an overview of the Metaobject Protocols. The detailed 
 behavior of each function, generic function and macro in the Metaobject 
 Protocol is presented in the Generic Functions and Methods Dictionary. The 
 remainder of this chapter is intended to emphasize connections among the 
 parts of the Metaobject Protocol, and to provide some examples of the kinds 
 of specializations and extensions the protocols are designed to support.
  
 Metaobject Initialization Protocols
  
 Like other objects, metaobjects can be created by calling
  make-instance
 . 
 The initialization arguments passed to
  make-instance
  are used to initialize 
 the metaobject in the usual way. The set of legal initialization arguments, 
 and their interpretation, depends on the kind of metaobject being created. 
 Implementations and portable programs are free to extend the set of legal 
 initialization arguments. 
  
 Detailed information about the initialization of 
 each kind of metaobject are provided in Generic Functions and Methods 
 Dictionary; this section provides an overview and examples of this behavior.
  
  
 Initialization of Class Metaobjects 
  
  
 Class metaobjects created with
  make-instance
  are usually
  anonymous
 ; 
 that is, they have no proper name. An anonymous class metaobject can be 
 given a proper name using
  setf find-class
  and
  setf class-name
 .",NA
30.2 Generic Functions and Methods Dictio-,NA,NA
nary,"This chapter describes each of the functions and generic functions that 
 make up the CLOS Metaobject Protocol. The descriptions appear in 
 alphabetical order with the exception that all the reader generic functions 
 for each kind of metaobject are grouped together. So, for example,
  method-
 function
  would be found with
  method-qualifiers
  and other method 
 metaobject readers under section 30.2.7.",NA
30.2.1 Initialization of Class Metaobjects,"A class metaobject can be created by calling
  make-instance
 . The initializa-
 tion arguments establish the definition of the class. A class metaobject can 
 be redefined by calling
  reinitialize-instance
 . Some classes of class metaob-
 ject do not support redefinition; in these cases,
  reinitialize-instance
  
 signals an error.
  
  
 Initialization of a class metaobject must be done by calling
  make-
 instance
  and allowing it to call
  initialize-instance
 . 
  
 Reinitialization of 
 a class metaobject must be done by calling
  reinitialize-instance
 . Portable 
 programs must not call initialize-instance directly to initialize a class 
 metaob-ject. Portable programs must not call
  shared-initialize
  directly to 
 initialize or reinitialize a class metaobject. Portable programs must not call
  
 change-class
  to change the class of any class metaobject or to turn a non-
 class object into a class metaobject.",NA
30.2.2 Initialization of Generic Function Metaobjects,"A generic function metaobject can be created by calling
  make-instance
 . 
 The initialization arguments establish the definition of the generic func-
 tion. A generic function metaobject can be redefined by calling
  reinitialize-
 instance
 . Some classes of generic function metaobject do not support 
 redef-inition; in these cases,
  reinitialize-instance
  signals an error.
  
  
 Initialization of a generic function metaobject must be done by calling 
 make-instance
  and allowing it to call
  initialize-instance
 . Reinitializa-tion 
 of a generic-function metaobject must be done by calling
  reinitialize-
 instance
 . 
  
 Portable programs must not call
  initialize-instance
  directly to 
 initialize a generic function metaobject. Portable programs must not call
  
 shared-initialize
  directly to initialize or reinitialize a generic function 
 metaobject. Portable programs must not call
  change-class
  to change the 
 class of any generic function metaobject or to turn a non-generic-function 
 object into a generic function metaobject.
  
 Since metaobject classes may not be redefined, no behavior is specified 
 for the result of calls to
  update-instance-for-redefined-class
  on generic",NA
30.2.3 Initialization of Method Metaobjects,"A method metaobject can be created by calling
  make-instance
 . The initial-
 ization arguments establish the definition of the method. A method metaob-
 ject cannot be redefined; calling
  reinitialize-instance
  signals an error.
  
 Initialization of a method metaobject must be done by calling
  make-
 instance
  and allowing it to call
  initialize-instance
 . 
  
 Portable programs 
 must not call
  initialize-instance
  directly to initialize a method metao-ject. 
 Portable programs must not call
  shared-initialize
  directly to initialize a 
 method metaobject. Portable programs must not call
  change-class
  to",NA
30.2.4 Initialization of Slot Definition Metaobjects,"A slot definition metaobject can be created by calling
  make-instance
 . The 
 initialization arguments establish the definition of the slot definition. A slot 
 definition metaobject cannot be redefined; calling
  reinitialize-instance
  
 sig-nals an error.
  
 Initialization of a slot definition metaobject must be done by calling 
 make-instance
  and allowing it to call
  initialize-instance
 . Portable pro-
 grams must not call
  initialize-instance
  directly to initialize a slot defini-
 tion metaobject. Portable programs must not call
  shared-initialize
  directly 
 to initialize a slot definition metaobject. Portable programs must not call 
 change-class
  to change the class of any slot definition metaobject or to turn 
 a non-slot-definition object into a slot definition metaobject.
  
 Since metaobject classes may not be redefined, no behavior is specified 
 for the result of calls to update
 -instance-for-redefined-class
  on slot defi-
 nition metaobjects. Since the class of a slot definition metaobject cannot be 
 changed, no behavior is specified for the result of calls to
  update-instance-
 for-different-class
  on slot definition metaobjects.
  
 During initialization, each initialization argument is checked for errors 
 and then associated with the slot definition metaobject. The value can then 
 be accessed by calling the appropriate accessor as shown in table 30.5.
  
 This section begins with a description of the error checking and process-
 ing of each initialization argument. This is followed by a table showing the 
 generic functions that can be used to access the stored initialization argu-
 ments.
  
 In these descriptions, the phrase “this argument defaults to
  value”
  
 means that when that initialization argument is not supplied, initialization 
 is per-formed as if
  value
  had been supplied. For some initialization 
 arguments this could be done by the use of default initialization arguments, 
 but whether it is",NA
30.2.5 Readers for Class Metaobjects,"In this and the immediately following sections, the “reader” generic 
 functions which simply return information associated with a particular kind 
 of metaob-ject are presented together. General information is presented 
 first, followed by a description of the purpose of each, and ending with the 
 specified meth-ods for these generic functions.
  
  
 The reader generic functions which simply return information 
 associated with class metaobjects are presented together in this section.
  
 Each of the reader generic functions for class metaobjects has the same 
 syntax, accepting one required argument called
  class
 , which must be an 
 class metaobject; otherwise, an error is signaled. An error is also signaled if 
 the class metaobject has not been initialized.
  
 These generic functions can be called by the user or the implementation.
  
 For any of these generic functions which returns a list, such lists will not 
 be mutated by the implementation. The results are undefined if a portable 
 program allows such a list to be mutated.
  
 [Generic Function]
  class-default-initargs
  class
  
 Returns a list of the default initialization arguments for
  class
 . Each ele-
 ment of this list is a canonicalized default initialization argument. The 
 empty list is returned if class has no default initialization arguments.
  
  
 During 
  
 finalization 
 finalize-inheritance 
  
 calls 
  
 compute-default-
 initargs
  to compute the default initialization arguments for the class. That 
 value is associated with the class metaobject and is returned by
  class-
 default-initargs
 .
  
 This generic function signals an error if
  class
  has not been finalized.
  
 [Generic Function]
  class-direct-default-initargs
  class
  
 Returns a list of the direct default initialization arguments for class. Each 
 element of this list is a canonicalized default initialization argument. The 
 empty list is returned if class has no direct default initialization arguments. 
 This is the defaulted value of the
  :direct-default-initargs
  initialization 
 argument that was associated with the class during initialization or 
 reinitial-ization.",NA
30.2.6 Readers for Generic Function Metaobjects,"The reader generic functions which simply return information associated 
 with generic function metaobjects are presented together in this section.
  
 Each of the reader generic functions for generic function metaobjects 
 has the same syntax, accepting one required argument called
  generic-
 function
 , which must be a generic function metaobject; otherwise, an error 
 is signaled. An error is also signaled if the generic function metaobject has 
 not been initialized.
  
 These generic functions can be called by the user or the implementation.
  
 The list returned by this generic function will not be mutated by the 
 implementation. The results are undefined if a portable program mutates 
 the list returned by this generic function.
  
 [Generic Function]
  generic-function-argument-precedence-order 
 generic-function
  
 Returns the argument precedence order of the generic function. This value is 
 a list of symbols, a permutation of the required parameters in the lambda list 
 of the generic function. This is the defaulted value of the 
 :argument-
 precedence-order
  initialization argument that was associated with the 
 generic function metaobject during initialization or reinitialization.",NA
30.2.7 Readers for Method Metaobjects,"The reader generic functions which simply return information associated 
 with method metaobjects are presented together here in the format 
 described under section 30.2.5.
  
 Each of these reader generic functions have the same syntax, accepting 
 one required argument called method, which must be a method metaob-",NA
30.2.8 Readers for Slot Definition Metaobjects,"The reader generic functions which simply return information associated 
 with slot definition metaobjects are presented together here in the format 
 described under section 30.2.5.
  
 Each of the reader generic functions for slot definition metaobjects has 
 the same syntax, accepting one required argument called
  slot
 , which must be",NA
Bibliography,"[1] Adobe Systems Incorporated.
  PostScript Language Reference Manual
 . 
  
 Addison-Wesley (Reading, Massachusetts, 1985).
  
 [2] Alberga, 
  
 Cyril 
  
 N., Bosman-Clark, Chris, Mikelsons, Martin, 
  
 Van 
 Deusen, Mary S., and Padget, Julian. Experience with an un-
  
 common Lisp. In
  Proc. 1986 ACM Conference on Lisp and Functional 
  
 Programming
 . ACM SIGPLAN/SIGACT/SIGART (Cambridge, Mas-
  
 sachusetts, August 1986), 39–53.
  
 [3]
  American National Standard Programming Language FORTRAN
 , ANSI 
 X3.9-1978 edition. American National Standards Institute, Inc. (New 
 York, 1978).
  
 [4] Bates, Raymond L., Dyer, David, and Feber, Mark. Recent develop-
 ments in ISI-Interlisp. In
  Proc. 1984 ACM Symposium on Lisp and 
 Functional Programming
 . ACM SIGPLAN/SIGACT/SIGART (Austin, 
 Texas, August 1984), 129–139.
  
 [5] Bobrow, Daniel G., DiMichiel, Linda G., Gabriel, Richard P., Keene, Sonya 
 E., Kiczales, Gregor, and Moon, David A. Common Lisp Object System 
 Specification: X3J13 Document 
 88-002R.
  SIGPLAN Notices 23 
 (September 1988).
  
 [6] Bobrow, Daniel G., DiMichiel, Linda G., Gabriel, Richard P., Keene, Sonya 
 E., Kiczales, Gregor, and Moon, David A. Common Lisp Ob-ject System 
 specification: 1. Programmer interface concepts.
  Lisp and Symbolic 
 Computation 1
 , 3/4 (January 1989), 245–298.
  
 [7] Bobrow, Daniel G., DiMichiel, Linda G., Gabriel, Richard P., Keene, Sonya 
 E., Kiczales, Gregor, and Moon, David A. Common Lisp Object
  
 1091",NA
X3J13 Votes,"ADJUST-ARRAY-
  
  
 DISPLACEMENT, 466 
 ADJUST-ARRAY-FILL-
  
  
 POINTER, 465 
  
 ADJUST-ARRAY-NOT-
  
  
 ADJUSTABLE, 
  
 451, 
  
 452, 460, 464, 465 
  
 ALLOW-LOCAL-INLINE, 240 
  
 APPLYHOOK-ENVIROMENT, 
  
 505, 
 506 
  
 ARGUMENTS-
  
  
 UNDERSPECIFIED, 
  
  
 399, 443, 473, 564, 569 
  
 ARRAY-TYPE-ELEMENT-
  
  
 TYPE-SEMANTICS, 
  
  
  
 54, 
  
 56, 57, 59, 99, 100, 450
  
 CHARACTER-PROPOSAL, 131, 
  
 140, 278, 399, 469, 535, 
  
 556, 616 
  
 CLOS, 160, 482 
  
 CLOS-MACRO-COMPILATION, 
  
 718 
  
 CLOSE-CONSTRUCTED-
  
  
 STREAM, 520 
  
 CLOSED-STREAM-
  
  
 OPERATIONS, 
  
 519, 
  
 676, 678, 681–683, 
  
  
 691, 
  
 700 
  
 COLON-NUMBER, 542, 543 
  
 COMPILE-FILE-HANDLING-
  
 OF-
 TOP-LEVEL-
  
  
 FORMS, 715 
  
 COMPILE-FILE-PACKAGE, 705 
 COMPILE-FILE-SYMBOL-
  
 HANDLING, 705, 720 
  
 COMPILER-DIAGNOSTICS, 
  
 704, 705 
  
 COMPILER-VERBOSITY, 694, 695, 
 704 
  
 COMPLEX-ATAN-BRANCH-
  
 CUT, 312, 315 
  
 COMPLEX-RATIONAL-
  
 RESULT, 303 
  
 CONDITION-RESTARTS, 971 
 CONSTANT-CIRCULAR-
  
 COMPILATION, 120 
  
 CONSTANT-COLLAPSING, 722 
 CONSTANT-COMPILABLE-
  
 TYPES, 120 
  
 CONSTANT-FUNCTION-
  
 COMPILATION, 721 
  
 CONSTANT-MODIFICATION, 722 
  
 CONTAGION-ON-NUMERICAL-
 COMPARISONS, 112, 293, 442 
  
 COPY-SYMBOL-COPY-PLIST, 255 
  
 COPY-SYMBOL-PRINT-NAME, 255
  
 DATA-IO, 558, 563, 574–579, 602, 
 908 
  
 DATA-TYPES-HIERARCHY-
  
 UNDERSPECIFIED, 490, 835, 922 
  
 DECLARATION-SCOPE, 228 
  
 DECLARE-ARRAY-
  
 TYPE-ELEMENT-",NA
Symbols,"’
  
  
 macro character, 548 
  
 # 
  
  
 macro character, 553 
  
 #\ 
  
  
 macro character, 554 
  
 "" 
  
  
 macrocharacter, 549 
  
 ( 
  
  
 macro character, 546 
  
 (setf class-name) 
  
  
 function, 1077 
  
  
 generic function, 877 
  
  
 primary method, 877 
  
 (setf documentation) 
  
  
 generic function, 899 
  
  
 primary method, 899, 
 900 (setf generic-function-
 name) 
  
 function, 1078 
  
 (setf slot-value-using-class) 
  
 generic function, 1078 
  
  
 primary method, 1079 
  
 ) 
  
  
 macro character, 547 
  
 * 
  
  
 function, 299 
  
  
 variable, 508 
  
 ** 
  
  
 variable, 508 
  
 *** 
  
  
 variable, 508 
  
 *applyhook* 
  
  
 variable, 504 
  
 *break-on-signals*
  
  
 variable, 948 
  
 *compile-file-pathname* 
  
  
 variable, 707 
  
 *compile-file-truename* 
  
  
 variable, 707 
  
 *compile-print* 
  
  
 variable, 707 
  
 *compile-verbose* 
  
  
 variable, 707 
  
 *debug-io* 
  
  
 variable, 512 
  
 *debugger-hook* 
  
  
 variable, 977 
  
 *default-pathname-defaults* 
  
 variable, 680 
  
 *error-output* 
  
  
 variable, 512 
  
 *evalhook* 
  
  
 variable, 504 
  
 *features* 
  
  
 variable, 735 
  
 *gensym-counter* 
  
  
 variable, 256 
  
 *load-pathname* 
  
  
 variable, 695 
  
 *load-print* 
  
  
 variable, 695 
  
 *load-truename* 
  
  
 variable, 695 
  
 *load-verbose* 
  
  
 variable, 695 
  
 *macroexpand-hook* 
  
  
 variable, 212 
  
 *package*",NA
Colophon,"Camera-ready copy for this book was created by the author (using TEX, 
 L
 A
 TEX, and TEX macros written by the author), proofed on an Apple Laser-
 Writer II, and printed on a Linotron 300 at Advanced Computer Graphics. 
 The text of the first edition was converted from Scribe format to TEX format 
 by a throwaway program written in Common Lisp. The diagrams in chapter 
 12 were generated automatically as PostScript code (by a program written 
 in Common Lisp) and integrated into the text by Textures, an 
 implementation of TEX by Blue Sky Research for the Apple Macintosh 
 computer.
  
 The body type is 10-point Times Roman. 
  
 Chapter titles are in ITC 
 Eras Demi; running heads and chapter subtitles are in ITC Eras Book. The 
 monospace typeface used for program code in both displays and running 
 text is 8.5-point Letter Gothic Bold, somewhat modified by the author 
 through TEX macros for improved legibility. The accent grave (
 ‘
 ), accent 
 acute(
 ’
 ), circumflex (
 ^
 ), and tilde (
 ~
 ) characters are in 10-point Letter Gothic 
 Bold and adjusted vertically to match the height of the 8.5-point characters. 
 The hyphen (
 -
 ) was replaced by an en dash (
 -
 ). The equals sign (
 =
 ) was re-
 placed by a construction of two em dashes (
 =
 ), one raised and one lowered, 
 the better to match the other relational characters. The sharp sign (
 #
 ) is 
 overstruck with two hyphens, one raised and one lowered, to eliminate the 
 vertical gap (
 #
 ). Special mathematical characters such as square-root signs 
 are in Computer Modern Math. The typefaces used in this book were digi-
 tized by Adobe Systems Incorporated, except for Computer Modern Math, 
 which was designed by Donald E. Knuth.
  
 1131",NA
