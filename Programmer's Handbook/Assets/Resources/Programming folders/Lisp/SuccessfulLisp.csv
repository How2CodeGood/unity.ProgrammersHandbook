Larger Text,Smaller Text,Symbol
Successful Lisp:,NA,NA
How to Understand and Use Common Lisp,"David B. Lamkins
  
 dlamkins@psg.com
  
 This book:
  
  
  
  
  
  
  
  
  
  
 Provides an overview of Common Lisp for the working programmer. 
  
 Introduces key concepts in an easy-to-read format. 
  
 Describes format, typical use, and possible drawbacks of all important Lisp constructs. 
  
 Provides practical advice for the construction of Common Lisp programs. 
  
 Shows examples of how Common Lisp is best used. 
  
 Illustrates and compares features of the most popular Common Lisp systems on desktop computers. 
 Includes discussion and examples of advanced constructs for iteration, error handling, object oriented 
 programming, graphical user interfaces, and threading. 
  
 Supplements Common Lisp reference books and manuals with useful hands-on techniques. 
  
 Shows how to find what you need among the thousands of documented and undocumented functions 
 and variables in a typical Common Lisp system.
  
 1",NA
Table of Contents,"About the Author [p 20] 
  
 About the Book [p 21] 
  
 Dedication [p 22] 
  
 Credits [p 23] 
  
 Copyright [p 24] 
  
 Acknowledgments [p 25] 
  
 Foreword [p 26] 
  
 Introduction [p 28] 
  
 1 [p 2] 2 [p 2] 3 [p 3] 4 [p 4] 5 [p 5] 6 [p 5] 7 [p 5] 8 [p 5] 9 [p 6] 10 [p 6] 11 [p 6] 12 [p 7] 13 [p 7] 14 
 [p 7] 15 [p 8] 16 [p 8] 17 [p 8] 18 [p 8] 19 [p 9] 20 [p 9] 21 [p 9] 22 [p 9] 23 [p 9] 24 [p 10] 25 [p 10] 
 26 [p 10] 27 [p 10] 28 [p 11] 29 [p 11] 30 [p 11] 31 [p 12] 32 [p 12] 33 [p 12] 34 [p 12] Appendix A 
 [p 13] 
  
  
 Chapter 1 - Why Bother? Or: Objections Answered [p 29] 
  
 Chapter objective: Describe the most common objections to Lisp, and answer each with advice on 
 state-of-the-art implementations and previews of what this book will explain.
  
  
  
 I looked at Lisp before, and didn’t understand it. 
  
  
 I can’t see the program for the parentheses. 
  
  
 Lisp is very slow compared to my favorite language. 
  
  
 No one else writes programs in Lisp. 
  
  
 Lisp doesn’t let me use graphical interfaces. 
  
  
 I can’t call other people’s code from Lisp. 
  
  
 Lisp’s garbage collector causes unpredictable pauses when my program runs. 
  
  
 Lisp is a huge language. 
  
  
 Lisp is only for artificial intelligence research. 
  
  
 Lisp doesn’t have any good programming tools. 
  
  
 Lisp uses too much memory. 
  
  
 Lisp uses too much disk space. 
  
  
 I can’t find a good Lisp compiler. 
  
  
 Chapter 2 - Is this Book for Me? [p 35] 
  
 Chapter objective: Describe how this book will benefit the reader, with specific examples and 
 references to chapter contents.
  
  
  
  
 The Professional Programmer 
  
 The Student 
  
 The Hobbyist 
  
 2",NA
Professional Track Suggested Chapter List,NA,NA
Skim for basics:,"Chapter 3 - Essential Lisp in Twelve Lessons [p 38] 
 Chapter 4 - Mastering the Essentials [p 84] 
  
 Chapter 5 - Introducing Iteration [p 108] 
  
 Chapter 6 - Deeper into Structures [p 112]",NA
Read for new concepts:,"Chapter 7 - A First Look at Objects as Fancy Structures [p 117] 
  
 Chapter 8 - Lifetime and Visibility [p 126] 
  
 Chapter 9 - Introducing Error Handling and Non-Local Exits [p 129] 
 Chapter 11 - Destructive Modification [p 137] 
  
 Chapter 12 - Mapping Instead of Iteration [p 144] 
  
 Chapter 13 - Still More Things You Can Do with Sequences [p 150] 
 Chapter 14 - Can Objects Really Behave Themselves? [p 157] 
  
 Chapter 15 - Closures [p 165] 
  
 Chapter 17 - Not All Comparisons are Equal [p 174] 
  
 Chapter 18 - Very Logical, Indeed [p 177] 
  
 Chapter 19 - Streams [p 183] 
  
 Chapter 20 - Macro Etiquette [p 188] 
  
 Chapter 21 - Fancy Tricks with Function and Macro Arguments [p 198] 
 Chapter 23 - To Err is Expected; To Recover, Divine [p 205] 
  
 Chapter 24 - FORMAT Speaks a Different Language [p 215]",NA
Learn the environment and tools:,"Chapter 10 - How to Find Your Way Around, Part 1 [p 133] 
  
 Chapter 16 - How to Find Your Way Around, Part 2 [p 169] 
  
 Chapter 22 - How to Find Your Way Around, Part 3 [p 203] 
  
 Chapter 26 - Put on a Happy Face: Interface Builders [p 222] 
  
 Chapter 27 - A Good Editor is Worth a Thousand Keystrokes [p 227] 
 Chapter 28 - Practical Techniques for Programming [p 230]",NA
Additional topics:,"Chapter 25 - Connecting Lisp to the Real World [p 220] 
  
 Chapter 29 - I Thought it was Your Turn to Take Out the Garbage [p 238] 
 Chapter 30 - Helpful Hints for Debugging and Bug-Proofing [p 241] 
 Chapter 31 - Handling Large Projects in Lisp [p 247] 
  
 14",NA
Student Track Suggested Chapter List,NA,NA
Learn the whole language:,"Chapter 3 - Essential Lisp in Twelve Lessons [p 38] 
  
 Chapter 4 - Mastering the Essentials [p 84] 
  
 Chapter 5 - Introducing Iteration [p 108] 
  
 Chapter 6 - Deeper into Structures [p 112] 
  
 Chapter 7 - A First Look at Objects as Fancy Structures [p 117] 
  
 Chapter 8 - Lifetime and Visibility [p 126] 
  
 Chapter 9 - Introducing Error Handling and Non-Local Exits [p 129] 
 Chapter 10 - How to Find Your Way Around, Part 1 [p 133] 
  
 Chapter 11 - Destructive Modification [p 137] 
  
 Chapter 12 - Mapping Instead of Iteration [p 144] 
  
 Chapter 13 - Still More Things You Can Do with Sequences [p 150] 
 Chapter 14 - Can Objects Really Behave Themselves? [p 157] 
  
 Chapter 15 - Closures [p 165] 
  
 Chapter 16 - How to Find Your Way Around, Part 2 [p 169] 
  
 Chapter 17 - Not All Comparisons are Equal [p 174] 
  
 Chapter 18 - Very Logical, Indeed [p 177] 
  
 Chapter 19 - Streams [p 183] 
  
 Chapter 20 - Macro Etiquette [p 188] 
  
 Chapter 21 - Fancy Tricks with Function and Macro Arguments [p 198] 
 Chapter 22 - How to Find Your Way Around, Part 3 [p 203] 
  
 Chapter 23 - To Err is Expected; To Recover, Divine [p 205] 
  
 Chapter 24 - FORMAT Speaks a Different Language [p 215]",NA
Read as interested:,"Chapter 25 - Connecting Lisp to the Real World [p 220] 
  
 Chapter 26 - Put on a Happy Face: Interface Builders [p 222] 
  
 Chapter 27 - A Good Editor is Worth a Thousand Keystrokes [p 227] 
 Chapter 28 - Practical Techniques for Programming [p 230] 
  
 Chapter 29 - I Thought it was Your Turn to Take Out the Garbage [p 238] 
 Chapter 30 - Helpful Hints for Debugging and Bug-Proofing [p 241] 
 Chapter 31 - Handling Large Projects in Lisp [p 247] 
  
 Chapter 32 - Dark Corners and Curiosities [p 250] 
  
 Chapter 33 - Where to Go Next [p 255] 
  
 Chapter 34 - Lisp History, or: Origins of Misunderstandings [p 257] 
 Appendix A - Lisp System Feature Comparison [p 260] 
  
 Appendix B - Successful Lisp Applications 
  
 16",NA
Hobbyist Track Suggested Chapter List,NA,NA
Learn how to find your way:,"Chapter 10 - How to Find Your Way Around, Part 1 [p 133] 
  
 Chapter 16 - How to Find Your Way Around, Part 2 [p 169] 
  
 Chapter 22 - How to Find Your Way Around, Part 3 [p 203] 
  
 Chapter 28 - Practical Techniques for Programming [p 230] 
  
 Chapter 29 - I Thought it was Your Turn to Take Out the Garbage [p 238] 
 Chapter 30 - Helpful Hints for Debugging and Bug-Proofing [p 241]",NA
Read as interested:,"Chapter 3 - Essential Lisp in Twelve Lessons [p 38] 
  
 Chapter 4 - Mastering the Essentials [p 84] 
  
 Chapter 5 - Introducing Iteration [p 108] 
  
 Chapter 6 - Deeper into Structures [p 112] 
  
 Chapter 7 - A First Look at Objects as Fancy Structures [p 117] 
  
 Chapter 8 - Lifetime and Visibility [p 126] 
  
 Chapter 9 - Introducing Error Handling and Non-Local Exits [p 129] 
 Chapter 11 - Destructive Modification [p 137] 
  
 Chapter 12 - Mapping Instead of Iteration [p 144] 
  
 Chapter 13 - Still More Things You Can Do with Sequences [p 150] 
 Chapter 14 - Can Objects Really Behave Themselves? [p 157] 
  
 Chapter 15 - Closures [p 165] 
  
 Chapter 17 - Not All Comparisons are Equal [p 174] 
  
 Chapter 18 - Very Logical, Indeed [p 177] 
  
 Chapter 19 - Streams [p 183] 
  
 Chapter 20 - Macro Etiquette [p 188] 
  
 Chapter 21 - Fancy Tricks with Function and Macro Arguments [p 198] 
 Chapter 23 - To Err is Expected; To Recover, Divine [p 205] 
  
 Chapter 24 - FORMAT Speaks a Different Language [p 215] 
  
 Chapter 25 - Connecting Lisp to the Real World [p 220] 
  
 Chapter 26 - Put on a Happy Face: Interface Builders [p 222] 
  
 Chapter 27 - A Good Editor is Worth a Thousand Keystrokes [p 227] 
 Chapter 31 - Handling Large Projects in Lisp [p 247] 
  
 Chapter 32 - Dark Corners and Curiosities [p 250] 
  
 Chapter 33 - Where to Go Next [p 255] 
  
 Chapter 34 - Lisp History, or: Origins of Misunderstandings [p 257] 
 Appendix A - Lisp System Feature Comparison [p 260] 
  
 Appendix B - Successful Lisp Applications 
  
 17",NA
Former User Track Suggested Chapter List,NA,NA
Read as needed:,"Chapter 3 - Essential Lisp in Twelve Lessons [p 38] 
  
 Chapter 4 - Mastering the Essentials [p 84] 
  
 Chapter 5 - Introducing Iteration [p 108] 
  
 Chapter 6 - Deeper into Structures [p 112] 
  
 Chapter 7 - A First Look at Objects as Fancy Structures [p 117] 
  
 Chapter 8 - Lifetime and Visibility [p 126] 
  
 Chapter 9 - Introducing Error Handling and Non-Local Exits [p 129] 
 Chapter 10 - How to Find Your Way Around, Part 1 [p 133] 
  
 Chapter 11 - Destructive Modification [p 137] 
  
 Chapter 12 - Mapping Instead of Iteration [p 144] 
  
 Chapter 13 - Still More Things You Can Do with Sequences [p 150] 
 Chapter 14 - Can Objects Really Behave Themselves? [p 157] 
  
 Chapter 15 - Closures [p 165] 
  
 Chapter 16 - How to Find Your Way Around, Part 2 [p 169] 
  
 Chapter 17 - Not All Comparisons are Equal [p 174] 
  
 Chapter 18 - Very Logical, Indeed [p 177] 
  
 Chapter 19 - Streams [p 183] 
  
 Chapter 20 - Macro Etiquette [p 188] 
  
 Chapter 21 - Fancy Tricks with Function and Macro Arguments [p 198] 
 Chapter 22 - How to Find Your Way Around, Part 3 [p 203] 
  
 Chapter 23 - To Err is Expected; To Recover, Divine [p 205] 
  
 Chapter 24 - FORMAT Speaks a Different Language [p 215] 
  
 Chapter 25 - Connecting Lisp to the Real World [p 220] 
  
 Chapter 26 - Put on a Happy Face: Interface Builders [p 222] 
  
 Chapter 27 - A Good Editor is Worth a Thousand Keystrokes [p 227] 
 Chapter 28 - Practical Techniques for Programming [p 230] 
  
 Chapter 29 - I Thought it was Your Turn to Take Out the Garbage [p 238] 
 Chapter 30 - Helpful Hints for Debugging and Bug-Proofing [p 241] 
 Chapter 31 - Handling Large Projects in Lisp [p 247] 
  
 Chapter 32 - Dark Corners and Curiosities [p 250] 
  
 Chapter 33 - Where to Go Next [p 255] 
  
 Chapter 34 - Lisp History, or: Origins of Misunderstandings [p 257] 
 Appendix A - Lisp System Feature Comparison [p 260] 
  
 Appendix B - Successful Lisp Applications 
  
 Also see detailed Table of Contents.
  
 18",NA
Curious Reader Track Suggested Chapter List,NA,NA
"Read in order, skimming as desired:","Chapter 3 - Essential Lisp in Twelve Lessons [p 38] 
  
 Chapter 4 - Mastering the Essentials [p 84] 
  
 Chapter 5 - Introducing Iteration [p 108] 
  
 Chapter 6 - Deeper into Structures [p 112] 
  
 Chapter 7 - A First Look at Objects as Fancy Structures [p 117] 
  
 Chapter 8 - Lifetime and Visibility [p 126] 
  
 Chapter 9 - Introducing Error Handling and Non-Local Exits [p 129] 
 Chapter 10 - How to Find Your Way Around, Part 1 [p 133] 
  
 Chapter 11 - Destructive Modification [p 137] 
  
 Chapter 12 - Mapping Instead of Iteration [p 144] 
  
 Chapter 13 - Still More Things You Can Do with Sequences [p 150] 
 Chapter 14 - Can Objects Really Behave Themselves? [p 157] 
  
 Chapter 15 - Closures [p 165] 
  
 Chapter 16 - How to Find Your Way Around, Part 2 [p 169] 
  
 Chapter 17 - Not All Comparisons are Equal [p 174] 
  
 Chapter 18 - Very Logical, Indeed [p 177] 
  
 Chapter 19 - Streams [p 183] 
  
 Chapter 20 - Macro Etiquette [p 188] 
  
 Chapter 21 - Fancy Tricks with Function and Macro Arguments [p 198] 
 Chapter 22 - How to Find Your Way Around, Part 3 [p 203] 
  
 Chapter 23 - To Err is Expected; To Recover, Divine [p 205] 
  
 Chapter 24 - FORMAT Speaks a Different Language [p 215] 
  
 Chapter 25 - Connecting Lisp to the Real World [p 220] 
  
 Chapter 26 - Put on a Happy Face: Interface Builders [p 222] 
  
 Chapter 27 - A Good Editor is Worth a Thousand Keystrokes [p 227] 
 Chapter 28 - Practical Techniques for Programming [p 230] 
  
 Chapter 29 - I Thought it was Your Turn to Take Out the Garbage [p 238] 
 Chapter 30 - Helpful Hints for Debugging and Bug-Proofing [p 241] 
 Chapter 31 - Handling Large Projects in Lisp [p 247] 
  
 Chapter 32 - Dark Corners and Curiosities [p 250] 
  
 Chapter 33 - Where to Go Next [p 255] 
  
 Chapter 34 - Lisp History, or: Origins of Misunderstandings [p 257] 
 Appendix A - Lisp System Feature Comparison [p 260] 
  
 Appendix B - Successful Lisp Applications 
  
 19",NA
About the Author,"David Lamkins was born in Watervliet, New York. Very little is known about his childhood except that he 
 started taking things apart as soon as he could hold a screwdriver. It wasn’t until David reached the age of 
 twelve that he started putting things back together. 
  
 This fascination with the inner workings of things carried David forward through a long period of his life 
 (euphemistically dubbed ""The Quiet Years""), during which he masterfully combined the roles of computer 
 geek and responsible adult. Of course, this resulted in a rather mundane existence and bored the hell out of 
 everyone around him... 
  
 David has recently rediscovered that people are more fun to play with than symbols, and has decided to --in 
 the grand tradition of reformed geeks everywhere -- get a life. 
  
 After thirty years of half-heartedly messing around on the guitar (including some stints in very short-lived 
 bands during his teen years) David has finally decided that he’d like to be a musician and play in a band 
 that performs dark, langorous, fluid music; an alchemic transmutation of psychedelia and metal. 
  
 David’s favorite movies are ""The Fifth Element"" and ""The Matrix"". 
  
 20",NA
About this Book,"This book was produced on Apple Macintosh computers.
  
 I used Digitool’s Macintosh Common Lisp to edit and test the book’s sample code. Bill St. Clair’s HTML-
 Editor.lisp extended MCL’s editor to handle the HTML markup language used in the construction of this 
 book. This way, I was able to edit and test the Lisp code directly in the book’s source files and avoid 
 errors I might have otherwise made by cutting and pasting sample code.
  
 I used various Web browsers to view the book.
  
 I used Excalibur by Robert Gottshall and Rick Zaccone to spell check the book, and the computer version 
 of The American Heritage Dictionary Deluxe Edition by Wordstar International for my dictionary and 
 thesaurus.
  
 All software and hardware used in the production of this book was purchased at my own expense. I support 
 shareware products by purchasing those I use.
  
 21",NA
Dedication,"This book is dedicated to my sons Nick and Ian. I’m very proud of you guys. Follow your dreams! 
  
 22",NA
Credits,"Trademarks mentioned in this book are the property of their respective owners. 
  
 Ray Scanlon generously donated his proofreading services (http://www.naisp.net/~rscanlon/) for the entire 
 book. All errors that remain are probably due to my ignoring Ray’s advice or have been introduced since 
 his reading. 
  
 Mary-Suzanne donated the good-looking graphics used in the book. The graphics that look amateurish are 
 mine. Never let an engineer attempt to do graphic arts. 
  
 23",NA
Copyright,"This book is copyright © 1995-2001 David B. Lamkins. All rights are reserved worldwide. 
  
 24",NA
Acknowledgments,"Thanks to all of the people in the Lisp community who have made it possible for me to produce this, my 
 first book. Over the years, members of the Usenet newsgroup comp.lang.lisp have provided sage advice, 
 patient tutorials, historical insight, food for thought, and (perhaps unintentionally) amusement. Thanks 
 especially to Barry Margolin, Kent Pitman, Erik Naggum for their contributions to the ongoing dialog, and 
 to Howard Stearns and Mark Kantrowitz for their stewardship of community resources. 
  
 25",NA
Foreword,"I started writing this book six years ago in response to a publisher’s inquiry about Lisp books. Part of their 
 submissing process involved my filling out what amounted to a market research form that disclosed all of 
 the Lisp books I knew about, their publication dates, and a brief synopsis of the strengths and weaknesses 
 of each. 
  
 On the basis of my market research, the publisher decided that their marketplace didn’t need another Lisp 
 book. So I kept going, because I knew otherwise. I wrote in fits and starts over the first two years, and 
 published an early draft of the book on the web. Readers of ""Successful Lisp"" from all over the world have 
 sent me positive feedback, thanking me for making the book available as a resource for their use in classes 
 and personal studies of Common Lisp. 
  
 A few of the more enthusiastic readers even compared ""Successful Lisp"" to a couple of my favorite Lisp 
 texts. While I’ll admit to having my spirits buoyed by such unabashed enthusiam, I’ll also be the first to 
 point out that ""Successful Lisp"" attempts to cover the subject in a somewhat different manner, and at 
 different levels of detail, than the other available texts. By all means, enjoy this book. But when you need 
 more information than I’ve been able to fit in this limited space, please turn to some of the other fine 
 books listed in Chapter 33. 
  
 Common Lisp is, at its core, a very simple language. Its apparent size is due not to complexity (as is the 
 case with certain more recent languages) but rather to the breadth of functionality implemented via the 
 functions and data types that are provided in every copy of Common Lisp. 
  
 The other encouraging feature of Common Lisp is its stability. The language became an ANSI standard in 
 1994 after four years of intensive work by vendors and designers alike, during which time several subtle 
 problems and inconsistencies were removed from the language and the corrections implemented in 
 production compilers and tested against real-world applications. This time consuming process of review 
 and refinement was quite successful, in that the language has not required correction, change or 
 clarification since its standardization. That’s good news for me, since I haven’t had to revise my book to 
 keep up. Good news, too, for the people who write large, complex programs in Common Lisp; their code 
 just keeps on working even when they change hardware or compilers. 
  
 The one criticism that has arisen over the years is that Common Lisp hasn’t adopted enough cool new 
 functionality over the years to give it more of a mass appeal. Vendors provide their own extensions for 
 networking, graphics, multiprocessing and other features, but the lack of standardization makes it difficult 
 to employ these features in a portable manner. While I share some of that concern, I’ll also observe that 
 these very features have changed significantly over the years since the ANSI standardization of Common 
 Lisp. Over the same period, newer languages have borrowed from Common Lisp’s toolbox for ideas 
 regarding expression of algorithms, symbolic manipulation of data, and automatic storage management. 
 Someday networking and graphics will be as well defined, and I’m sure we’ll see these aspects of 
 computing incorporated into Common Lisp. For now, be glad that you can tell the difference between 
 what’s stable and what’s the flavor of the month. 
  
 This will probably be my last update to ""Successful Lisp"", as my personal goals and interests have taken 
 me away from the deep involvement I had with computing through the 80s and 90s. I suspect that 
 ""Success Lisp"", if it has a lasting value within the Common Lisp community, will do so because of the
  
 26",NA
Introduction,"Lisp has a long, rich history dating back more than forty years. It has survived all of the programming 
 ""revolutions"" that have rendered lesser langauges obsolete. Despite its being taught as a curiosity, if at all, 
 by college and university staff who themselves have a poor understanding of the continuing growth and 
 evolution of Lisp, new generations of programmers continue to seek out Lisp as a tool to solve some of the 
 most difficult problems in the world of computing. 
  
 This book is my attempt to help the current generation of Lisp programmers, and to give something back to 
 those who have paved the way for the rest of us. 
  
 The first two chapters lay out the book’s background and intent. Then chapters 3 through 24 introduce a 
 core subset of Common Lisp. Chapters 25 through 32 introduce useful features that may not be found in 
 all Lisp implementations, or their details may differ among implementations; these chapters should be read 
 in conjunction with your Lisp vendor’s documentation. Chapters 33 and 34 offer, respectively, an 
 annotated list of additional resources and an overview of Lisp’s historical timeline. 
  
 28",NA
Chapter 1 - Why Bother? Or: Objections Answered,"Everyone knows Lisp, right? Many of us took a course that introduced us to Lisp along with three or four 
 or more other languages. This is how I was introduced to Lisp around 1975, and I thought it was a pretty 
 useless language. It didn’t do 
 anything
  in the usual way, it was slow, and those parentheses were enough 
 to drive anyone crazy!
  
 If your own Lisp experience predates 1985 or so, you probably share this view. But in 1984, the year Big 
 Brother never 
 really
  became a reality (did it?), the year that the first bleeding-edge (but pathetic by today’s 
 standards) Macintosh started volume shipments, the Lisp world started changing. Unfortunately, most 
 programmers never noticed; Lisp’s fortune was tied to AI, which was undergoing a precipitous decline --
 The AI Winter -- just as Lisp was coming of age. Some say this was bad luck for Lisp. I look at the 
 resurgence of interest in other dynamic languages and the problems wrestled with by practicioners and 
 vendors alike, and wonder whether Lisp wasn’t too far ahead of its time.
  
 I changed my opinion of Lisp over the years, to the point where it’s not only my favorite progamming 
 language, but also a way of structuring much of my thinking about programming. I hope that this book 
 will convey my enthusiasm, and perhaps change your opinion of Lisp.
  
 Below I’ve listed most of the common objections to Lisp. These come from coworkers, acquaintances, 
 managers, and my own past experience. For each point, I’ll describe how much is actually true, how much 
 is a matter of viewpoint, and how much is a holdover from the dark days of early Lisp implementations. 
 As much as possible, I’ll avoid drawing comparisons to other languages. Lisp has its own way, and you’ll 
 be able to make your own comparisons once you understand Lisp as well as your usual language. If you 
 eventually understand Lisp enough to know when its use is appropriate, or find a place for Lisp in your 
 personal toolkit, then I’ve done my job.
  
 Without further introduction, here are a baker’s dozen reasons why you might be avoiding Lisp:",NA
"I looked at Lisp before, and didn’t understand it.","This is a really tough one. Most programming languages are more similar to each other than they are to 
 Lisp. If you look at a family tree of computer languages, you’ll see that the most common languages in use 
 today are descendants of the Algol family. Features common to languages in the Algol family include 
 algebraic notation for expressions, a block structure to control visibility of variables, and a way to call 
 subroutines for value or effect. Once you understand these concepts, you can get started with another 
 language in the family by studying the surface differences: the names of keywords and the style of 
 punctuation.
  
 Lisp really 
 is
  different. If you’ve only read code in Algol family languages, you’ll find no familiar 
 punctuation or block structure to aid your understanding of Lisp code -- just unfamiliar names appearing 
 in seemingly pointless nests of parentheses. In Lisp, the parenthesis 
 is
  the punctuation. Fortunately, its use 
 is quite simple; simpler than, for example, remembering the operator precedence rules of C or Pascal. Lisp 
 development environments even provide editors that help with matching opening and closing parentheses.
  
 29",NA
I can’t see the program for the parentheses.,"Part of this problem is a matter of dealing with the unfamiliar. I talked about that in the previous section. 
 Another part of this problem is real: you have to deal with a lot of parentheses. Fortunately, Lisp 
 programming environments have editors that mechanize the process of counting parentheses by flashing or 
 highlighting matching pairs or by manipulating entire balanced expressions. Finally, there’s a matter of 
 style. Judicious indentation improves the readability of Lisp programs, as it does in other languages. But 
 vertical whitespace often hinders readability in Lisp.
  
 I’ll cover both the mechanical and stylistic aspects of Lisp code in this book. By the time you’re done, 
 you’ll have an opinion on what constitues readable code, and you’ll be able to defend your position. When 
 you reach that level of confidence, you’ll be able to write aesthetic Lisp code, and to read anyone else’s 
 code. Parentheses won’t be a concern any longer.",NA
Lisp is very slow compared to my favorite language.,"Possibly... But the difference may not be as large as you’d expect. First, let’s clear the table of an 
 old 
 misconception: that Lisp is an interpreted language. As a rule, most modern Lisp systems compile to 
 machine code. A few compile to byte code that typically runs five times slower than machine code. And 
 one or two freeware Lisp systems only run interpreted code, but they’re the exception. So there’s part one 
 of the answer: if you’re not running a Lisp 
 compiler
 , you should get one.
  
 Your Lisp coding style affects execution speed. Unfortunately, you won’t recognize inefficient Lisp code 
 until you’ve had some experience with the language. You’ll need to think about how Lisp works in order 
 to understand what makes Lisp code run slowly. This is not hard to do, but the issues are different from 
 those for languages which expose more of the underlying machine to you.
  
 Lisp gives you incremental compilation. This means that you can compile one function at a time and be 
 ready to run your program instantly -- there is no linkage step. This means that you can make lots of 
 changes quickly and evaluate them for their effect on the program. Lisp also has built-in instrumentation 
 to help you tune the performance of your program.
  
 30",NA
No one else writes programs in Lisp.,"What? I’m the only one left? I don’t think so...
  
 Seriously, though, there are quite a few people who write Lisp code every day. They write programs that 
 solve tough problems, and give their employers a strategic advantage. It’s hard to find good Lisp 
 programmers who are willing to move to a new employer; those companies who are using Lisp guard their 
 strategic advantage, and their Lisp programmers, quite jealously.
  
 Now, it’s mostly true that you won’t find Lisp in consumer products like spreadsheets, databases, word 
 processors, and games. But then, that’s not the kind of work that Lisp does best. You 
 will
  find Lisp in 
 products that must reason about and control complex systems and processes, where the ability to reliably 
 arrive at useful conclusions based upon complex relationships among multiple sources and kinds of data is 
 more important than lightning-fast numerical calculations or spiffy graphics (although modern Lisp 
 systems come pretty close to the leaders even in the latter two categories).
  
 Lisp is also used as an extension language because of its simple, consistent syntax and the ability for 
 system designers to add new functions to Lisp without writing an entire new language. The Emacs editor 
 and the AutoCAD drafting program are two of the best examples of this use of Lisp.
  
 And of course Lisp is 
 still
  the language most often used for research in artificial intelligence and advanced 
 computer language design, but we won’t touch on either of those subjects in this book. When you’ve 
 finished this book, you’ll have the knowledge needed to recognize what problems you should solve using 
 Lisp, and how to approach the solution’s design.
  
 Oh, and one more thing: It’s not quite true that no mass market product uses Lisp. Microsoft’s ""Bob"" 
 environment for naive computer users was developed (and delivered) in Lisp.",NA
Lisp doesn’t let me use graphical interfaces.,"This is ironic. Some of the first graphical user interfaces appeared on Lisp machines in the early 1970s. In 
 fact, in 1995 you can still buy a DOS adaptation of one of these early Lisp environments -- with the same 
 GUI it had twenty years ago.
  
 The leading Lisp development environments for Windows and Macintosh support only a subset of their 
 host platform’s GUI. It’s possible to add support for the missing features, but easier to do it using 
 Microsoft’s and Apple’s preferred language: C++.
  
 If you want to have the same graphical user interface on your Lisp program when it runs on Windows or 
 Macintosh hosts, you can find at least two Lisp windowing environments that let you do this. The problem 
 is that the Lisp GUI will be familiar to neither Macintosh nor Windows users.
  
 31",NA
I can’t call other people’s code from Lisp.,"This is mostly untrue. Most Lisp environments give you a way to call external routines using either C or 
 Pascal calling conventions. You can also call back into Lisp from the external program. But if you want to 
 call C++ from Lisp, you’ll probably have to write a C wrapper around the C++ code.",NA
Lisp’s garbage collector causes unpredictable pauses ,NA,NA
when my program runs.,"This should probably be covered in the ""Lisp is slow"" discussion, but there are enough interesting 
 digressions for this to warrant its own topic. Lisp programs create garbage by destroying all references to 
 some object in memory. In a program written in some other language, the programmer must arrange to 
 release the memory occupied by the object at the same time when the last reference is destroyed. If the 
 program fails to do this reliably, the program has a 
 memory leak
  -- eventually the program’s memory 
 space could fill up with these unreachable objects and not leave enough free memory for the program to 
 continue. If you’ve ever written a complex program that allocates and manually recycles a lot of dynamic 
 memory, you know how difficult a problem this can be.
  
 Lisp finesses the memory leakage problem by 
 never
  allowing the programmer to release unused memory. 
 The idea here is that the computer can determine when a block of memory is unreachable with complete 
 accuracy. This unreachable block is said to be garbage because it is no longer useful to any part of the 
 program. The garbage collector runs automatically to gather all these unused blocks of memory and prepare 
 them for reuse. The algorithms that do this are very tricky, but they come built into your Lisp system.
  
 Historically, garbage collection 
 has been
  slow. The earliest garbage collectors could literally lock up a 
 system for hours. Performance was so poor that early Lisp programmers would run with garbage 
 collection turned off until they completely ran out of memory, then start the garbage collection manually 
 and go home for the rest of the day.
  
 Over the past twenty years, a lot of good software engineering techniques have been applied to improving 
 the performance of garbage collectors. Modern Lisp systems collect garbage almost continuously, a little 
 bit at a time, rather than waiting and doing it all at once. The result is that even on a very slow desktop 
 machine a pause for garbage collection will rarely exceed a second or two in duration.
  
 Later in this book I’ll discuss garbage collection in greater detail and show you techniques to avoid 
 generating garbage; the less garbage your program creates, the less work the garbage collector will have to 
 do.
  
 32",NA
Lisp is a huge language.,"If you look at the book 
 Common Lisp: The Language
 , weighing in at about a thousand pages, or the recent 
 (and bulkier) 
 ANSI Standard X3.226: Programming Language Common Lisp
 , it’s easy to form that 
 opinion. When you consider that the Lisp language has almost 
 no
  syntax, and only a couple of dozen 
 primitive language elements (called special forms), then Lisp starts to look like a 
 very small
  language.
  
 In fact, the manuals cited above are mostly concerned with descriptions of what most other languages 
 would call 
 library
  functions and, to a lesser degree, development tools. Take the language manual for your 
 favorite language. Add the manuals for three or four third-party libraries -- development utilities, fancy 
 data structures, generalized I/O, etc. Take all the manuals for your development tools -- browsers, 
 inspectors, debuggers, etc. and toss them onto the growing pile. Now count the pages. Does a thousand 
 pages still seem like a lot?
  
 By the time you’ve finished this book, you’ll know how to find what you need in Lisp, with or without a 
 manual.",NA
Lisp is only for artificial intelligence research.,"Just not true. Lisp gets used for big projects that have to be tackled by one or a few programmers. Lisp is 
 also good for tasks that are not well defined, or that require some experimentation to find the proper 
 solution. As it turns out, artificial intelligence meets all of these criteria. So do a lot of other applications: 
 shop job scheduling, transportation routing, military logistics, sonar and seismological echo feature 
 extraction, currency trading, computer and computer network configuration, industrial process diagnosis, 
 and more. These aren’t mass market applications, but they still make lots of money (often by avoiding 
 cost) for the organizations that develop them.",NA
Lisp doesn’t have any good programming tools.,"I hope to convince you otherwise. Several chapters of this book are devoted to introducing you to the many 
 useful tools provided by a Lisp development environment.",NA
Lisp uses too much memory.,"The Lisp development systems on both my Mac and my PC run comfortably in anywhere from 4 to 8 
 megabytes of RAM. Less in a pinch. The integrated C++ development environments take anywhere from 
 12 to 20 megabytes. Both have comparable tools and facilities.
  
 33",NA
Lisp uses too much disk space.,"The Lisp development systems on both my Mac and my PC use considerably less disk space than the C++ 
 environments. Lisp space on my hard disk runs from a low of about 5 megabytes for one system to a high 
 of about 30 megabytes for another system that is a total programming environment, including a built in 
 file manager, WYSIWYG word processor, graphics program, appointment calendar, and (almost forgot) 
 Lisp development environment. The C++ systems run from a low of about 20 megabytes to a high of 
 about 150 megabytes.",NA
I can’t find a good Lisp compiler.,"Depending on what kind of computer you use, this was a problem as recently as a year or two ago. And 
 it’s true that there isn’t a lot of competition for the Lisp marketplace -- you can count vendors on the 
 fingers of one hand. The vendors who support the Lisp marketplace tend to have been around for a long 
 time and have good reputations. As desktop computers increase in speed and storage capacity, Lisp 
 vendors are increasingly turning their attention to these platforms. Appendix B of this book lists not only 
 the current players in the field, but also their corporate lineage.
  
 34",NA
Chapter 2 - Is this Book for Me?,"Depending upon your background, interest, and experience, your need for the information offered in this 
 book is best met by following the material in a certain way. I think that most readers will place themselves 
 in one of the following categories: professional programmer [p 35] , student [p 35] , hobbyist [p 36] , 
 former Lisp user [p 36] , or merely curious [p 37] . No matter which category you fit, I’ve described what I 
 think you can gain by reading this book. As you read through this book, you may decide that you no longer 
 fit your original category. This is fine -- there are no strong dependencies between chapters. If you get 
 stuck on a particular concept, the detailed Table of Contents will help you locate the information you need.",NA
The Professional Programmer,"This book tells you what you need to know about Lisp in order to write good programs, and to read Lisp 
 code in journals, magazines, or other people’s programs. Beyond that, I will introduce you to some 
 important concepts that you may not have encountered in your use of other languages, or you may find that 
 the Lisp approach to a familiar concept gives you a new perspective on an old idea. Even if you never have 
 occasion to use Lisp on the job, the concepts you’ll learn in this book may give you a fresh insight to help 
 solve a tough problem in your favorite language. You’ll probably want to skim up through Chapter 6 to 
 make sure you’ve covered the basics. Then slow down and take a closer look at what interests you in 
 Chapter 7 [p 117] through Chapter 9 [p 129] , Chapter 11 [p 137] through Chapter 15 [p 165] , Chapter 17 
 [p 174] through Chapter 21 [p 198] , Chapter 23 [p 205] , and Chapter 24 [p 215] ; these chapters cover 
 concepts that are either unique to, or best expressed in, the Lisp language.
  
 Beyond all else, I hope to impress upon you the dynamic nature of Lisp program development. Lisp usually 
 is a pleasant surprise to someone accustomed (or resigned) to the usual edit, compile, link, and debug cycle. 
 The biggest change is compilation of functions rather than files. You can change and recompile just one 
 function at a time, even from within the debugger. This is really handy if you’ve spent hours of testing to 
 find a problem that can be easily fixed with one small change to your program. This is just one example of 
 how the Lisp programming environment supports your programming efforts. You’ll find additional 
 examples throughout this book. Chapter 10 [p 133] , Chapter 16 [p 169] , Chapter 22 [p 203] , and Chapter 
 26 [p 222] through Chapter 28 [p 230] will give you an appreciation of how Lisp supports dynamic 
 program development.
  
 Professional Track",NA
The Student,"If you’ve learned Lisp in a typical classroom setting, you may have come to believe that the language is 
 nothing but lists and recursion. This book will show you that Lisp has a rich assortment of data types and 
 control structures. Lists and recursion are only the tip of the iceberg. Chapter 3 [p 38] through Chapter 24 
 [p 215] should fill in the details on the rest of Lisp. Skim the remaining chapters so you know where to 
 look when you have access to a commercial Lisp development environment, for when you begin your first 
 Lisp project outside of an academic setting.
  
 35",NA
The Hobbyist,"To me, a hobbyist is someone who pursues programming for the challenge, for the learning experience, or 
 as a pastime. The hobbyist is largely self taught. If you fit that mold, I’ll warn you now that Lisp can be 
 very challenging, and can teach you a lot about programming.
  
 You can go quite a long way toward learning Lisp with one of the freeware systems available for 
 Macintosh and DOS computers. But if you have aspirations to turn your hobby into a money making 
 venture, you need to ask yourself whether Lisp is appropriate for your anticipated product or service. If 
 you think in terms of databases or scripts or multimedia, you’ll probably be happier with a tool that 
 directly addresses your area of interest. If you have dreams of writing the next great videogame, you’ve 
 probably already discovered that you need a language that lets you program ""close to the machine"" -- If so, 
 Lisp will disappoint you. But if you want to give your game characters complex interactions, or even the 
 appearance of intelligent behavior, Lisp is a wonderful vehicle in which to design and test prototypes of 
 these behaviors.
  
 No matter what your interest in programming as a hobby, this book will give you the understanding you 
 need to explore Lisp without getting bogged down in the parentheses. Read through all of the chapters, 
 spending more time on those which interest you the most. If you have access to a Lisp development system, 
 spend time on Chapter 10 [p 133] , Chapter 16 [p 169] , Chapter 22 [p 203] , and Chapter 28 [p 230] 
 through Chapter 30 [p 241] ; these chapters will give you the background you need in order to find your 
 way when you get lost -- you’ll find this more helpful than trying to develop an encyclopedic knowledge of 
 the language.
  
 Hobbyist Track",NA
The Former Lisp Acquaintance,"If you’ve had a prior experience with Lisp, perhaps in a college or university programming class, this book 
 will update your knowledge. This book will teach you things that a one semester class could never cover 
 due to time constraints. You’ll also see how commercial Lisp development systems provide tools and 
 features missing from the freeware Lisp system that your educational institution probably used.
  
 If you’ve worked on (or have attempted) a Lisp project before, you may not have had the benefit of a 
 mentor to show you how to use Lisp effectively. This book will introduce you to the skills that you need to 
 become a successful Lisp programmer. It is important that you understand what the language does; this
  
 36",NA
The Curious,"If you have no immediate intentions of writing a Lisp program (perhaps you’re a student of programming 
 languages), this book is still a good choice. You can learn a lot about Lisp, its development environment, 
 and its use by reading through the chapters in order and working out an occasional bit of code on paper, to 
 check your understanding. I’ve tried hard to introduce the fundamentals of Lisp in a way that doesn’t 
 belabor the details of internal representation.
  
 Curious Reader Track
  
 37",NA
Chapter 3 - Essential Lisp in Twelve Lessons,"This chapter will teach you everything you need to know to get started with Lisp. I’ll cover all of the core 
 features of the language. I encourage you to think of this core as the Lisp language itself, and everything 
 else as a very large standard library. With this background, you’ll be much better equipped to learn the rest 
 of Lisp, either by reading the rest of the book or via a reference manual such as 
 Common Lisp: The 
 Language, 2nd Edition
 .
  
 You should read this chapter all the way through. At times, I mention other chapters and later sections of 
 this chapter, but you shouldn’t have to follow these references to understand this chapter. When you finish 
 this chapter, you should work through Chapter 4 [p 84] while sitting at the keyboard of your Lisp system.
  
  
  
  
  
  
  
  
  
  
  
  
  
 Lesson 1 [p 39] - Essential Syntax 
  
 Lesson 2 [p 41] - Essential Evaluation 
  
 Lesson 3 [p 46] - Some Examples of Special Forms and Macros 
 Lesson 4 [p 51] - Putting things together, and taking them apart 
 Lesson 5 [p 53] - Naming and Identity 
  
 Lesson 6 [p 56] - Binding versus Assignment 
  
 Lesson 7 [p 59] - Essential Function Definition 
  
 Lesson 8 [p 61] - Essential Macro Definition 
  
 Lesson 9 [p 63] - Essential Multiple Values 
  
 Lesson 10 [p 65] - A Preview of Other Data Type 
  
 Lesson 11 [p 77] - Essential Input and Output 
  
 Lesson 12 [p 82] - Essential Reader Macros
  
 38",NA
Chapter 3 - Essential Lisp in Twelve Lessons,NA,NA
Lesson 1 - Essential Syntax,"Lists are surrounded by parentheses 
  
 This is the first thing you need to know about Lisp: anything surrounded by parentheses is a list. Here 
 are some examples of things that are lists:
  
 (1 2 3 4 5) 
  
 (a b c) 
  
 (cat 77 dog 89)
  
 As I said, anything surrounded by parentheses is a list. When you hear a statement like that, you 
 probably want to ask two questions:
  
 1.  What if I put parentheses around 
 nothing
 ? 
  
 2.  What if I put parentheses around 
 another list
 ?
  
 In both cases the answer is the same. You still have a list. So the following are also lists:
  
 () 
  
 (()) 
  
 ((())) 
  
 ((a b c)) 
  
 ((1 2) 3 4) 
  
 (mouse (monitor 512 342) (keyboard US)) 
  
 (defun factorial (x) (if (eql x 0) 1 (* x (factorial (- x 1)))))
  
 The only time you don’t have a list is when you have a right parenthesis without a matching left 
 parenthesis or vice versa, as in the following four examples:
  
 (a b c( 
  
 ((25 g) 
 34 
  
 ((()) 
  
 (()))
  
 This is nothing to lose sleep over -- Lisp will tell you when there’s a mismatch. Also, the editor that 
 you use for writing Lisp programs will almost certainly give you a way to automatically find 
 matching parentheses. We’ll look at editors in Chapter 27 [p 227] .
  
 A list can be a lot of things in Lisp. In the most general sense, a list can be either a program or data. 
 And because lists can themselves be made of other lists, you can have arbitrary combinations of data 
 and programs mixed at different levels of list structure -- this is what makes Lisp so flexible for those 
 who understand it, and so confusing for those who don’t. We’ll work hard to remove that confusion 
 as this chapter continues.
  
 39",NA
Chapter 3 - Essential Lisp in Twelve Lessons,NA,NA
Lesson 2 - Essential Evaluation,NA,NA
A form is meant to be evaluated,"A form can be either an atom or a list. The important thing is that the form is meant to be evaluated. 
 Evaluation has a fairly technical definition that we’ll gradually expose in this section.
  
 Evaluation is simple if the form is an atom. Lisp treats the atom as a name, and retrieves the value for the 
 name (if a value exists). You probably wonder why I’m avoiding the more direct explanation of calling the 
 atom a variable. The reason is that the atom can have either a variable value or a constant value. And the 
 atom’s value can be constant for a couple of reasons.
  
 A number is an atom. (Its value is constant for obvious reasons.) Lisp does not 
 store
  a value for a number-- 
 the number is said to be self-evaluating.
  
 We’re going to introduce a new term without a complete definition. For now, think of a 
 symbol
  as an 
 atom that can have a value. We’ll look at symbols in greater detail when we get to Lesson 5 [p 53] .
  
 A symbol defined in a 
 defconstant
  form has a constant value. Lisp will store the value as if the atom 
 had a variable value, and add a note to the effect that the value is not allowed to change.
  
 A symbol in the 
 KEYWORD
  package is self-evaluating. We’ll look at packages in detail in Chapter 31 [p 
 247] . For now, all you need to know is that a symbol beginning with the 
 :
  character (called the package 
 prefix) is a keyword symbol. Keyword symbols have themselves as their values.
  
 A symbol can get a variable value in many different ways. Lisp actually keeps several different values for 
 a symbol. One has the traditional meaning as the value of the symbol taken as a variable. Another has 
 meaning as the symbol’s function. Still others keep track of the symbol’s documentation, its printed 
 representation, and properties that the programmer chooses to associate with the symbol. We’ll explore 
 some of these in more detail in Lesson 5 [p 53] , Lesson 6 [p 56] , and Lesson 7 [p 59] .
  
 If a form is a list, then the first element must be either a symbol or a special form called a lambda 
 expression. (We won’t look at lambda expressions for a while.) The symbol must name a function. In Lisp, 
 the 
 symbols
 +
 , 
 -
 , 
 *
 , and 
 /
  name the four common arithmetic operations: addition, subtraction, 
 multiplication, and division. Each of these symbols has an associated function that performs the arithmetic 
 operation.
  
 So when Lisp evaluates the form 
 (+ 2 3)
 , it applies the function for addition to the arguments 
 2
  and 
 3
 , 
 giving the expected result 
 5
 . Notice how the function symbol, 
 +
 , precedes its arguments. This is 
 prefix 
 notation. Any time you see a list, look to its first element to find out what Lisp will do to evaluate the list 
 as a form.
  
 41",NA
A function is applied to its arguments,"Lisp, when given a list to evaluate, treats the form as a function call. We’ll be looking a lot at Lisp 
 evaluation from now on, so we’ll use some visual aids to identify the input to Lisp and its responses:
  
  
  
  the Lisp prompt precedes input to Lisp 
 result of Lisp evaluation
  
 For example:
  
  
  
  
  
  
  
  
  
  (+ 4 9)
  
  13
  
  (- 5 7)
  
  -2
  
  (* 3 9)
  
  27
  
  (/ 15.0 2)
  
  7.5
  
 In each case above, the evaluated form is a list. Its first element is a symbol, which names a function. The 
 remaining elements are 
 arguments
  of the function. Here, the arguments are all numbers, and we know that 
 numbers are self-evaluating.
  
 Here are a few more examples:
  
  
  
  
  
  
  
  
  
  (atom 123)
  
  T
  
  (numberp 123)
  
  T
  
  (atom :foo)
  
  T
  
  (numberp :foo)
  
  NIL
  
 ATOM
  and 
 NUMBERP
  are predicates. Predicates return a true or false value. 
 NIL
  is the only false value in 
 Lisp -- everything else is true. Unless a predicate has a more useful value to return, it conventionally 
 returns 
 T
  to mean true. 
 ATOM
  returns 
 T
  if its one argument is a Lisp atom. 
 NUMBERP
  returns 
 T
  if its 
 argument is a number.
  
 To evaluate each of the above forms, Lisp first evaluates the arguments (from left to right), then evaluates 
 the first element to get its function, then applies the function to the arguments. With only a handful of 
 exceptions, which we’ll learn about at the end of this lesson, Lisp always does the same thing to evaluate a 
 list form:
  
 42",NA
A function can return any number of values,"Sometimes you’d like to have a function return several values. For example, a function which looks up a 
 database entry might return both the desired result and a completion status code. One way to do this is to 
 pass to the function a location for one of the results; this is possible, but 
 very
  uncommon for a Lisp 
 program.
  
 Another approach creates a single return value to combine both the result and the status code. Lisp gives 
 you several different ways to do this, including structures [p 72] . Experienced Lisp programmers don’t do 
 this when the created value will just be taken apart into its components and then forgotten, since the 
 composite value then becomes garbage (see Chapter 29 [p 238] ) that eventually slows down the operation 
 of the program.
  
 The right way to return multiple values from a function is to use the 
 VALUES
  form. We’ll see 
 VALUES 
 used in the context of a function [p 63] in a little while. For now, let’s see what happens when Lisp 
 evaluates a 
 VALUES
  form:
  
 43",NA
Arguments are usually not modified by a function,"I mentioned earlier that you can pass a location to a function, and have the function change the location’s 
 value. This is a 
 very
  uncommon practice for a Lisp program, even though other languages make it part of 
 their standard repertoire.
  
 You could specify the location to be modified as either a non-keyword symbol or a composite value --
 obviously, you can’t modify a constant. If you provide a symbol, then your function must execute code to 
 give the symbol a new value. If you provide a composite data structure, your function must execute code 
 to change the correct piece of the composite value. It’s harder to write Lisp code to do this, and it’s harder 
 to understand programs written this way. So Lisp programmers usually write functions that get their inputs 
 from parameters, and produce their outputs as the function result.",NA
Arguments are usually evaluated before function application,"When Lisp evaluates a function, it always evaluates all the arguments first, as we saw earlier [p 42] . 
 Unfortunately, every rule has exceptions, and this rule is no exception (as we’ll soon see)... The problem is 
 not that Lisp doesn’t always evaluate a function’s arguments, but that not every list form is a function call.",NA
Arguments are evaluated in left-to-right order,"When a list form 
 is
  a function call, its arguments are always evaluated in order, from left to right. As in 
 other programming languages, it’s in poor taste to rely on this, but if you absolutely have to rely on the 
 order, it’s good to know that Lisp defines it for you.",NA
Special forms and macros change argument evaluation,"So if a list form isn’t always a function call, what else can it be? There are two cases, but the result is the 
 same: some arguments are evaluated, and some aren’t. Which is which depends upon the form and nothing 
 else. You’ll just have to learn the exceptions. Fortunately, most Lisp systems will show you the online 
 documentation for any form with just a keystroke or two.
  
 There are two kinds of forms that don’t evaluate all of their arguments: special forms and macros. Lisp 
 predefines a small number of special forms. You can’t add your own special forms -- they’re primitive 
 features of the language itself. Lisp also defines quite a few macros. You can also define your own 
 macros. Macros in Lisp let you use the full power of the language to add your own features. Later in this 
 chapter we’ll look briefly at how to define simple macros [p 61] . In Chapter 20 [p 188] we’ll cover topics
  
 44",NA
Chapter 3 - Essential Lisp in Twelve Lessons,NA,NA
Lesson 3 - Some Examples of Special Forms and Macros,"Now we’ll look at several special forms and macros. Over the next four lessons, we’ll build up a repertoire 
 that will let you write simple functions using the most elementary Lisp data type, the list. Later chapters 
 will cover more complex program structures and data types.",NA
SETQ,"Earlier, I told you that Lisp evaluates a symbol form by retrieving its variable value. 
 SETQ
  gives you a way 
 to set that value:
  
  
  
  
  
  
  
  
  
  
  
  (setq my-name ""David"")
  
  ""David""
  
  my-name
  
  ""David""
  
  (setq a-variable 57)
  
  57
  
  a-variable
  
  57
  
  (setq a-variable :a-keyword)
  
  :A-KEYWORD
  
 SETQ
 ’s first argument is a symbol. This is not evaluated. The second argument is assigned as the variable’s 
 value. 
 SETQ
  returns the value of its last argument.
  
 SETQ
  doesn’t evaluate its first argument because you want to assign a value to the symbol itself. If 
 SETQ
  evaluated its first argument, the 
 value
  of that argument would have to be a symbol. The 
 SET 
 form does this: 
  
  
  
  
  
  
  
  
  
  
  
  
  
  (setq var-1 ’var-2)
  
  VAR-2
  
  var-1
  
  VAR-2
  
  var-2
  
  Error: Unbound variable
  
  (set var-1 99)
  
  99
  
  var-1
  
  VAR-2
  
  VAR-2
  
  99
  
 46",NA
LET,"The 
 LET
  form looks a little more complicated that what we’ve seen so far. The 
 LET
  form uses nested lists, 
 but because it’s a special form, only certain elements get evaluated.
  
  
  
  
  
  
  
  
  
  (let ((a 3)
  
   
  (b 4)
  
   
  (c 5))
  
   
  (* (+ a b) c))
  
  35
  
  a
  
  Error: Unbound variable
  
  b
  
  Error: Unbound variable
  
  c
  
  Error: Unbound variable
  
 The above 
 LET
  form defines values for the symbols 
 A
 , 
 B
 , and 
 C
 , then uses these as variables in an 
 arithmetic calculation. The calculation’s result is also the result of the 
 LET
  form. Note that none of the 
 variables defined in the 
 LET
  have a value after Lisp has finished evaluating the form.
  
 In general, 
 LET
  looks like this:
  
 47",NA
COND,"The 
 COND
  macro lets you evaluate Lisp forms conditionally. Like 
 LET
 , 
 COND
  uses parentheses to delimit 
 different parts of the form. Consider these examples:
  
  
  
  (let ((a 1)
  
   
  (b 2)
  
   
  (c 1)
  
   
  (d 1))
  
   
  (cond ((eql a b) 1)
  
    
  ((eql a c) ""First form"" 2)
  
   
  ((eql a d) 3)))
  
  2
  
 In the above 
 COND
  form we defined three clauses. Each clause is a list beginning with a test form and 
 followed by as many body forms as desired. The body forms are simply code that you want to execute if 
 the test succeeds. The clauses are selected in order -- as soon as one test succeeds, the corresponding body 
 forms are evaluated and the value of the last body form becomes the value of the 
 COND
  form.
  
 COND
  is more general than the special form, 
 IF
 , which only allows one test and one form each for 
 the 
 then
  and 
 else
  parts.
  
 Let’s look at what happened in the example. 
 EQL
  returns 
 T
  if its two arguments are identical, or the same 
 number (there’s a subtle difference that we’ll cover in Chapter 17 [p 174] ). Only two of the three tests 
 executed. The first, 
 (EQL A B)
 , returned NIL. Therefore, the rest of that clause (containing the number 
 1
  
 as its only form) was skipped. The second clause tested 
 (EQL A C)
 , which was true. Because this test 
 returned a non-
 NIL
  value, the remainder of the clause (the two atomic forms, 
 ""First form""
  and 
 2
 ) was 
 evaluated, and the value of the last form was returned as the value of the 
 COND
 , which was then returned as 
 the value of the enclosing 
 LET
 . The third clause was never tested, since an earlier clause had already been 
 chosen -- clauses are tested in order.
  
 Conventional use of 
 COND
  uses 
 T
  as the test form in the final clause. This guarantees that the body forms 
 of the final clause get evaluated if the tests fail in all of the other clauses. You can use the last clause to 
 return a default value or perform some appropriate operation. Here’s an example:
  
 49",NA
QUOTE,"Sometimes we’d like to suppress Lisp’s normal evaluation rules. One such case is when we’d like a symbol 
 to stand for itself, rather than its value, when it appears as an argument of a function call:
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  (setq a 97)
  
  97
  
  a
  
  97
  
  (setq b 23)
  
  23
  
  (setq a b)
  
  23
  
  a
  
  23
  
  (setq a (quote b))
  
  B
  
  a
  
  B
  
 The difference is that 
 B
 ’s 
 value
  is used in 
 (SETQ A B)
 , whereas 
 B
 stands for itself
  in 
 (SETQ A 
 (QUOTE B))
 .
  
 The 
 QUOTE
  form is so commonly used that Lisp provides a shorthand notation:
  
 (QUOTE 
 form
 )   ’
 form
  
 The  symbol means that the two Lisp forms are equivalent. Lisp arranges the equivalence of 
 ’
  and 
 QUOTE
  
 through a reader macro. We’ll take a brief look at how you can define your own reader macros in Lesson 
 12 [p 82] .
  
 50",NA
Chapter 3 - Essential Lisp in Twelve Lessons,NA,NA
"Lesson 4 - Putting things together, and taking them apart",NA,NA
CONS,"CONS
  is the most basic 
 cons
 tructor of lists. It is a function, so it evaluates both of its arguments. The 
 second argument must be a list or 
 NIL
 .
  
  
  
  
  
  
  
  (cons 1 nil)
  
  (1)
  
  (cons 2 (cons 1 nil))
  
  (2 1)
  
  (cons 3 (cons 2 (cons 1 nil))) 
 (3 2 1)
  
 CONS
  adds a new item to the beginning of a list. The empty list is equivalent to 
 NIL
 ,
  
 ()   NIL
  
 so we could also have written:
  
  
  
  
  
  
  
  (cons 1 ())
  
  (1)
  
  (cons 2 (cons 1 ()))
  
  (2 1)
  
  (cons 3 (cons 2 (cons 1 ()))) 
 (3 2 1)
  
 In case you’re wondering, yes, there’s something special about 
 NIL
 . 
 NIL
  is one of two symbols in 
 Lisp that isn’t a keyword but still has itself as its constant value. 
 T
  is the other symbol that works like 
 this.
  
 The fact that 
 NIL
  evaluates to itself, combined with 
 () NIL
 , means that you can write 
 ()
  rather 
 than 
 (QUOTE ())
 . Otherwise, Lisp would have to make an exception to its evaluation rule to 
 handle the empty list.",NA
LIST,"As you may have noticed, building a list out of nested 
 CONS
  forms can be a bit tedious. The 
 LIST
  form 
 does the same thing in a more perspicuous manner:
  
  
  
  (list 1 2 3)
  
  (1 2 3)
  
 51",NA
FIRST and REST,"If you think of a list as being made up of two parts -- the first element and everything else -- then you can 
 retrieve any individual element of a list using the two operations, 
 FIRST
  and 
 REST
 .
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  (setq my-list (quote (1 2 3 4 5))) 
 (1 2 3 4 5)
  
  (first my-list)
  
  1
  
  (rest my-list)
  
  (2 3 4 5)
  
  (first (rest my-list))
  
  2
  
  (rest (rest my-list))
  
  (3 4 5)
  
  (first (rest (rest my-list)))
  
  3
  
  (rest (rest (rest my-list)))
  
  (4 5)
  
  (first (rest (rest (rest my-list)))) 
 4
  
 Clearly, chaining together 
 FIRST
  and 
 REST
  functions could become tedious. Also, the approach can’t 
 work when you need to select a particular element when the program runs, or when the list is of 
 indeterminate length. We’ll look at how to solve these problems in Chapter 4 [p 84] by defining recursive 
 functions. Later, in Chapter 13 [p 150] , we’ll see the functions that Lisp provides to perform selection on 
 the elements of lists and other sequences.
  
 FIRST
  and 
 REST
  are fairly recent additions to Lisp, renaming the equivalent functions 
 CAR
  and 
 CDR
 , 
 respectively. 
 CAR
  and 
 CDR
  got their names from an implementation detail of one of the earliest Lisp 
 implementations, and the names persisted for decades despite the fact that the underlying 
 implementation had long since changed.
  
 52",NA
Chapter 3 - Essential Lisp in Twelve Lessons,NA,NA
Lesson 5 - Naming and Identity,NA,NA
A symbol is just a name,"A symbol is just a name. It can stand for itself. This makes it easy to write certain kinds of programs in 
 Lisp. For example, if you want your program to represent relationships in your family tree, you can make 
 a database that keeps relationships like this:
  
 (father John Barry) 
  
 (son John Harold) 
  
 (father John Susan) 
  
 (mother Edith Barry) 
  
 (mother Edith Susan) 
  
 ...
  
 Each relationship is a list. 
 (father John Barry)
  means that John is Barry’s father. Every element of 
 every list in our database is a symbol. Your Lisp program can compare symbols in this database to 
 determine, for example, that Harold is Barry’s grandfather. If you tried to write a program like this in 
 another language -- a language without symbols -- you’d have to decide how to represent the names of 
 family members and relationships, and then create code to perform all the needed operations -- reading, 
 printing, comparison, assignment, etc. This is all built into Lisp, because symbols are a data type distinct 
 from the objects they might be used to name.",NA
A symbol is always unique,"Every time your program uses a symbol, that symbol is 
 identical
  to every other symbol with the same 
 name. You can use the 
 EQ
  test to compare symbols:
  
  
  
  
  
  
  
  
  
  
  
  (eq ’a ’a)
  
  T
  
  (eq ’david ’a)
  
  NIL
  
  (eq ’David ’DAVID)
  
  T
  
  (setq zzz ’sleeper)
  
  SLEEPER
  
  (eq zzz ’sleeper)
  
  T
  
 Notice that it doesn’t matter whether you use uppercase or lowercase letters in your symbol names. 
 Internally, Lisp translates every alphabetic character in a symbol name to a common case -- usually upper, 
 but you can control this by setting a flag in the Lisp reader.
  
 53",NA
A symbol can name a value,"Although the ability for a Lisp symbol to stand for itself is sometimes useful, a more common use is for 
 the symbol to name a value. This is the role played by variable and function names in other programming 
 languages. A Lisp symbol most commonly names a value or -- when used as the first element of a function 
 call form -- a function.
  
 What’s unusual about Lisp is that a symbol can have a value as a function and a variable at the same time:
  
  
  
  
  
  
  
  (setq first ’number-one)
  
  NUMBER-ONE
  
  (first (list 3 2 1))
  
  3
  
  first
  
  NUMBER-ONE
  
 Note how 
 FIRST
  is used as a variable in the first and last case, and as a function (predefined by Lisp, in 
 this example) in the second case. Lisp decides which of these values to use based on where the symbol 
 appears. When the evaluation rule requires a value, Lisp looks for the variable value of the symbol. When 
 a function is called for, Lisp looks for the symbol’s function.
  
 A symbol can have other values besides those it has as a variable or function. A symbol can also have 
 values for its documentation, property list, and print name. A symbol’s documentation is text that you 
 create to describe a symbol. You can create this using the 
 DOCUMENTATION
  form or as part of certain 
 forms which define a symbol’s value. Because a symbol can have multiple meanings, you can assign 
 documentation to each of several meanings, for example as a function and as a variable.
  
 A property list is like a small database with a single key per entry. We’ll look at this use of symbols in 
 Lesson 10 [p 65] .
  
 The print name is what Lisp uses to print the symbol. You normally don’t want to change this; if you do, 
 Lisp will print the symbol with a different name than it originally used to read the symbol, which will 
 create a different symbol when later read by Lisp.",NA
A value can have more than one name,"A value can have more than one name. That is, more than one symbol can share a value. Other languages 
 have pointers that work this way. Lisp does not expose pointers to the programmer, but does have shared 
 objects. An object is considered identical when it passes the 
 EQ
  test. Consider the following:
  
  
  
  
  (setq L1 (list ’a ’b 
 ’c))
  
  (A B C)
  
  (setq L2 L1)
  
 54",NA
Chapter 3 - Essential Lisp in Twelve Lessons,NA,NA
Lesson 6 - Binding versus Assignment,NA,NA
Binding creates a new place to hold a value,"Lisp often ""creates a binding"" for a variable by allocating a piece of storage to hold the variable’s value 
 and putting the value into the newly allocated memory. Binding is a very general mechanism for 
 implementing lexical scope for variables, but it has other uses depending upon the lifetime of the binding. 
 We’ll revisit this in Chapter 8 [p 126] when we study lifetime and visibility.
  
 Yes, Lisp allocates storage for new bindings. While this sounds like it could be horribly inefficient, 
 we’ve said nothing yet about 
 where
  Lisp allocated the storage. For example, Lisp binds function 
 parameters to actual values, but allocates the storage on the stack just like any other programming 
 language. Lisp creates bindings in the heap if it can’t determine that the binding has a lifetime which 
 ends when the binding form finishes executing.",NA
Bindings have names,"Lisp gives each binding a name. Otherwise, how would your program refer to the binding? Simple, eh? 
 Hold on...",NA
A binding can have different values at the same time,"It is quite common for multiple bindings to share the same name. For example:
  
 (let ((a 1))
  
  (let ((a 2))
  
   
  (let ((a 3))
  
   
  
  ...)))
  
 Here, 
 A
  has three distinct bindings by the time the body (marked by 
 ...
 ) executes in the innermost 
 LET
 .
  
 This is not to say that the above example is representative of typical Lisp code, however.",NA
One binding is innermost,";; Here, A has no binding. 
  
 (let ((a 1))
  
  
 ;; Here, the innermost binding of A has the value 1.
  
 (let ((a 2))
  
  
 ;; Here, the innermost binding of A has the value 2.
  
 (let ((a 3))
  
 ;; Here, the innermost binding of A has the value 3.
  
 ...)))
  
 56",NA
The program can only access bindings it creates,"When a binding form binds a new value to an existing symbol, the previous value becomes shadowed. The 
 value of the outer binding is hidden (but not forgotten) while your program code executes inside the inner 
 binding form. But as soon as your program leaves the inner binding form, the value of the outer binding is 
 restored. For example:
  
 (let ((z 1)) 
  
  
 ;; Here, the innermost binding of Z has the value 1.
  
  (let ((z 2)) 
  
  
 ;; Here, the innermost binding of Z has the value 2.
  
   
  ...) 
  
  
 ;; Now we’re outside the inner binding form, ;; 
 and we again see the binding with the value 1.
  
  ...)",NA
Assignment gives an old place a new value,"The 
 SETQ
  form changes the value of an existing binding:
  
 (let ((z 1)) 
  
  
 ;; Here, the innermost binding of Z has the value 1.
  
  (setq z 9) 
  
  
 ;; Now the value of Z is 9.
  
  (let ((z 2)) 
  
  
 ;; Here, the innermost binding of Z has the value 2.
  
   
  ...) 
  
  
 ;; Now we’re outside the inner binding form,
  
  ;; and we again see the outer binding of Z with the value 9.
  
  ...)
  
 57",NA
Chapter 3 - Essential Lisp in Twelve Lessons,NA,NA
Lesson 7 - Essential Function Definition,NA,NA
DEFUN defines named functions,"You can define a named function using the 
 DEFUN
  form:
  
  
  
  (defun secret-number (the-number)
  
  
  (let ((the-secret 37))
  
   
  (cond ((= the-number the-secret) ’that-is-the-secret-number)
  
   
  ((< the-number the-secret) ’too-low)
  
    
  ((> the-number the-secret) ’too-high))))
  
  SECRET-NUMBER
  
 We described 
 LET
 , 
 COND
 , and 
 ’
  (a.k.a. 
 QUOTE)
  in Lesson 3. The numeric comparison functions 
 have the obvious meaning.
  
 The 
 DEFUN
  form has three arguments:
  
 1.  the name of the function: 
 SECRET-NUMBER
 , 
  
 2.  a list of argument names: 
 (THE-NUMBER)
 , which will be bound to the function’s parameters when 
 it is called, and 
  
 3.  the body of the function: 
 (LET ...)
 .
  
 Since all three of these should stand for themselves, 
 DEFUN
  does not evaluate any of its arguments. (If it 
 did, you’d face the inconvenience of having to quote each argument.)
  
 DEFUN
  returns the name of the defined function, and installs a global definition using the name, parameter 
 list, and body that you supplied. Once you create a function using 
 DEFUN
 , you can use it right away:
  
  
  
  
  
  
  
  (secret-number 11)
  
  TOO-LOW
  
  (secret-number 99)
  
  TOO-HIGH
  
  (secret-number 37)
  
  THAT-IS-THE-SECRET-NUMBER
  
 When you call the function, its parameter (e.g. 
 99
  in the second example) is bound to the argument name 
 (i.e. 
 THE-NUMBER
 ) you supplied in the definition. Then, the body of the function (i.e. 
 (LET ...)
 ) is 
 evaluated within the context of the parameter binding. In other words, evaluating 
 (SECRET-NUMBER 99)
  
 causes the body of the 
 SECRET-NUMBER
  function definition to be executed with the variable 
 THE-
 NUMBER
  bound to 
 99
 .
  
 Of course, you can define a function of more than one argument:
  
 59",NA
LAMBDA defines anonymous functions,"At times you’ll need a function in only one place in your program. You could create a function with 
 DEFUN
  
 and call it just once. Sometimes, this is the best thing to do, because you can give the function a descriptive 
 name that will help you read the program at some later date. But sometimes the function you need is so 
 trivial or so obvious that you don’t want to have to invent a name or worry about whether the name might 
 be in use somewhere else. For situations like this, Lisp lets you create an unnamed, or anonymous, function 
 using the 
 LAMBDA
  form. A 
 LAMBDA
  form looks like a 
 DEFUN
  form without the name:
  
 (lambda (a b c x)
  
  (+ (* a (* x x)) (* b x) c))
  
 You can’t evaluate a 
 LAMBDA
  form; it must appear only where Lisp expects to find a function -- normally 
 as the first element of a form:
  
  
  
  
  
  (lambda (a b c x)
  
  
  (+ (* a (* x x)) (* b x) c)) 
 Error
  
  ((lambda (a b c x)
  
   
  (+ (* a (* x x)) (* b x) c)) 
 3 2 7 5)
  
  92
  
 60",NA
Chapter 3 - Essential Lisp in Twelve Lessons,NA,NA
Lesson 8 - Essential Macro Definition,NA,NA
DEFMACRO defines named macros,"A 
 DEFMACRO
  form looks a lot like a 
 DEFUN
  form (see Lesson 7) -- it has a name, a list of argument 
 names, and a body:
  
 (defmacro 
 name
  (
 argument
  ...) 
  
  
 body
 )",NA
"Macros return a form, not values","The macro body returns a form to be evaluated. In other words, you need to write the body of the macro 
 such that it returns a form, not a value. When Lisp evaluates a call to your macro, it first evaluates the 
 body of your macro definition, then evaluates the result of the first evaluation. (By way of comparison, a 
 function’s body is evaluated to return a value.)
  
 Here are a couple of simple macros to illustrate most of what you need to know:
  
  
  
  
  
  
  
  
  
  
  
  (defmacro setq-literal (place literal)
  
  
 ‘(setq ,place ’,literal))
  
  SETQ-LITERAL
  
  (setq-literal a b)
  
  B
  
  a
  
  B
  
  (defmacro reverse-cons (rest first)
  
  ‘(cons ,first ,rest))
  
  REVERSE-CONS
  
  (reverse-cons nil A)
  
  (B)
  
 SETQ-LITERAL
  works like 
 SETQ
 , except that 
 neither
  argument is evaluated. (Remember that 
 SETQ 
 evaluates its second argument.) The body of 
 SETQ-LITERAL
  has a form that begins with a 
 ‘
 (pronounced 
 ""backquote""). Backquote behaves like quote -- suppressing evaluation of all the enclosed forms -- except 
 where a comma appears within the backquoted form. A symbol following the comma is evaluated.
  
 So in our call to 
 (SETQ-LITERAL A B)
  above, here’s what happens:
  
 1.  bind 
 PLACE
  to the symbol 
 A
 . 
  
 2.  bind 
 LITERAL
  to the symbol 
 B
 . 
  
 3.  evaluate the body 
 ‘(SETQ ,PLACE ’,LITERAL)
 , following these steps: 
  
 61",NA
Chapter 3 - Essential Lisp in Twelve Lessons,NA,NA
Lesson 9 - Essential Multiple Values ,NA,NA
Most forms create only one value ,"A form typically returns only one value. Lisp has only a small number of forms which create or receive 
 multiple values.",NA
VALUES creates multiple (or no) values ,"The 
 VALUES
  form creates zero or more values:
  
  
  
  
  
  
  
  (values)
  
  (values :this)
  
  :THIS
  
  (values :this :that)
  
  :THIS
  
  :THAT
  
 We show how many values are returned by the number of  lines produced by the evaluation of the form. 
 The three 
 VALUES
  forms in the example above produced zero, one, and two values, respectively.
  
 VALUES
  is a function, and so evaluates its arguments.",NA
A few special forms receive multiple values ,"What might you want to do with multiple values in a program? The most basic operations are to:
  
 1.  bind each value to a separate symbol, or 
  
 2.  collect the values into a list.
  
 Use 
 MULTIPLE-VALUE-BIND
  to bind each value to a separate symbol:
  
  
  
  (multiple-value-bind (a b c) (values 2 3 5)
  
  (+ a b c))
  
  10
  
 If you provide more values than symbols, the excess values are ignored:
  
  
  
  (multiple-value-bind (a b c) (values 2 3 5 ’x ’y)
  
  (+ a b c))
  
  10
  
 If you provide fewer values than symbols, the excess symbols are bound to 
 NIL
 :
  
 63",NA
Some forms pass along multiple values,"Some forms pass along the last value in their body, rather than creating a new value. Examples include the 
 bodies of 
 LET
 , 
 COND
 , 
 DEFUN
 , and 
 LAMBDA
 .
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  (let ((a 1)
  
   
  (b 2))
  
  
  (values a b))
  
  1
  
  2
  
  (cond (nil 97)
  
  
  (t (values 3 4)))
  
  3
  
  4
  
  (defun foo (p q)
  
  
  (values (list :p p) (list :q q))) 
 FOO
  
  (foo 5 6)
  
  (:P 5)
  
  (:Q 6)
  
  ((lambda (r s)
  
    
  (values r s))
  
  
  7 8)
  
  7
  
  8
  
 In the case of the function and lambda bodies, the multiple values are actually returned by something 
 called an ""
 implicit
 PROGN
 ."" This is a fancy way of saying that the bodies can contain multiple forms, 
 and only the value of the last form is returned.
  
 You can use the 
 PROGN
  special form when you want this behavior. 
 (PROGN form1 form2 ... 
 formN)
  evaluates 
 form1
  through 
 formN
  in order, and returns the value of 
 formN
 .
  
 64",NA
Chapter 3 - Essential Lisp in Twelve Lessons,NA,NA
Lesson 10 - A Preview of Other Data Types,NA,NA
Lisp almost always does the right thing with numbers,"This sounds like a strange thing to say. Don’t computers always do the right thing with numbers? Well, 
 no... Not usually.
  
 Numeric calculations can break in lots of different ways. One of the biggest trouble spots is in calculations 
 with floating point numbers (your language may call them 
 real
  numbers, but that’s a lie). There are 
 probably half as many books written on proper use of floating point calculations as there are on visual- or 
 object-oriented-anything -- and that’s a lot.
  
 The problem with floating point numbers is that they’re not mathematically accurate real numbers, but are 
 often (mis)used as if they are. The main problem is that floating point numbers have a limited accuracy --
 only so many digits to the right of the decimal point. Now, if all of the numbers in a calculation are of 
 approximately the same magnitude, then the calculation won’t lose accuracy. But if the numbers are of 
 very different magnitude, then a floating point calculation sacrifices accuracy.
  
 Suppose that a floating point number on your computer can accurately represent 7 decimal digits. 
 Then you can add 1897482.0 to 2973225.0 and get a completely accurate answer. But if you try to 
 add 1897482.0 to 0.2973225, the accurate answer has fourteen digits, while your computer will 
 answer with 1897482.0.
  
 The other problem with floating point numbers is more subtle. When you write a program, you write 
 numbers in base 10. But the computer does all arithmetic in base 2. The conversion from base 10 to base 2 
 does funny things to certain ""obviously exact"" numbers. For example, the decimal number 0.1 is a 
 repeating fraction when translated into binary. Because the computer can’t store the infinite number of 
 digits required by a repeating fraction, it can’t store the number 0.1 accurately.
  
 Integer (whole number) arithmetic poses another problem in most computer languages -- they tend to 
 impose a limit on the maximum positive or negative value that an integer can hold. So, if you try to add the 
 number one to the largest integer your language lets the computer handle, one of two things will happen:
  
 1.  your program will terminate with an error, or 
  
 2.  you’ll get a wildly incorrect answer (the largest positive number plus one yields the largest negative 
 integer in at least one computer language).
  
 So how does Lisp manage to do the right thing with numbers? After all, it seems like these problems are 
 inherent in computer arithmetic. The answer is that Lisp doesn’t do use just the built-in computer 
 arithmetic operations -- it adds certain mathematically accurate numeric data types:
  
 65",NA
Characters give Lisp something to read and write,"Basic Lisp I/O uses characters. The 
 READ
  and 
 WRITE
  functions turn characters into Lisp objects and vice
  
 versa. 
 READ-CHAR
  and 
 WRITE-CHAR
  read and write single characters.
  
  (read)
  
  a
  
  A
  
  (read)
  
  #\a
  
  a
  
  (read-char)
  
  a
  
  #\a
  
  (write ’a)
  
  A
  
  A
  
  (write #\a)
  
  #\a
  
  #\a
  
  (write-char #\a)
  
  a
  
  #\a
  
  (write-char ’a)
  
  Error: Not a character
  
 We’ve introduced some new notation in the above examples. The  symbol means that Lisp expects input
  
 in response to an input function such as 
 READ
 . This is different from  , which accepts input to be
  
 evaluated and printed. The  symbol indicates a newline character, generated by the 
 return
  or 
 enter
  
 key.
  
 The  indicates output that is printed rather than returned as a value.
  
 You should notice that newline terminates 
 READ
  input. This is because 
 READ
  collects characters trying to
  
 form a complete Lisp expression. We’ll see more of this in Lesson 11 [p 77] . In the example, 
 READ
  
 collects a symbol, which is terminated by the newline. The symbol could also have been terminated by a
  
 space, a parenthesis, or any other character that can’t be part of a symbol.
  
 In contrast, 
 READ-CHAR
  reads exactly one character from the input. As soon as that character is
  
 consumed, 
 READ-CHAR
  completes executing and returns the character.
  
 Some Lisp systems systems may require you to press the 
 return
  key before any input is
  
 recognized. This is unusual, and can often be fixed by a configuration parameter -- consult your Lisp 
  
 vendor.
  
 67",NA
Arrays organize data into tables,"If you need to organize data in tables of two, three, or more dimensions, you can create an array:
  
  (setq a1 (make-array ’(3 4)))
  
  #2A((NIL NIL NIL NIL) 
  
 (NIL NIL NIL NIL) 
  
 (NIL NIL NIL NIL))
  
  (setf (aref a1 0 0) (list ’element 0 0))
  
  (ELEMENT 0 0)
  
  (setf (aref a1 1 0) (list ’element 1 0))
  
  (ELEMENT 1 0)
  
 68",NA
Vectors are one-dimensional arrays,"Vectors are one-dimensional arrays. You can create a vector using 
 MAKE-ARRAY
 , and access its elements
  
 using 
 AREF
 .
  
  (setq v1 (make-array ’(3)))
  
  #(NIL NIL NIL)
  
  (make-array 3)
  
  #(NIL NIL NIL)
  
  (setf (aref v1 0) :zero)
  
  :ZERO
  
  (setf (aref v1 1) :one)
  
  :ONE
  
 69",NA
Strings are vectors that contain only characters,"You already know how to write a string using the 
 ""...""
  syntax. Since a string is a vector, you can apply
  
 the array and vector functions to access elements of a string. You can also create strings using the 
  
 MAKE-STRING
  function or change characters or symbols to strings using the 
 STRING
  function.
  
  (setq s1 ""hello, there."")
  
  ""hello, there.""
  
  (setf (elt s1 0) #\H))
  
  #\H
  
  (setf (elt s1 12) #\!)
  
  #\!
  
  s1
  
  ""Hello, there!""
  
  (string ’a-symbol)
  
  ""A-SYMBOL""
  
  (string #\G)
  
  ""G""
  
 70",NA
"Symbols are unique, but they have many values","We saw in Lesson 5 that a symbol has a unique identity, but this bears repeating: A symbol is 
 identical
  to
  
 any other symbol spelled the same way (including its package designation, which we’ll learn more about
  
 at the end of this lesson). This means that you can have Lisp read a program or data, and every occurrence
  
 of a symbol with the same spelling is the same symbol. Since Lisp supplies the mechanism to do this, it’s
  
 one less thing you have to worry about when you write a program that manipulates 
 symbolic
  information.
  
 We also learned in Lesson 5 that a symbol can have values as a variable and a function, and for
  
 documentation, print name, and properties. A symbol’s property list is like a miniature database which
  
 associates a number of key/value pairs with the symbol. For example, if your program represented and
  
 manipulated objects, you could store information about an object on its property list:
  
  (setf (get ’object-1 ’color) ’red)
  
  RED
  
  (setf (get ’object-1 ’size) ’large)
  
  LARGE
  
  (setf (get ’object-1 ’shape) ’round)
  
  ROUND
  
  (setf (get ’object-1 ’position) ’(on table))
  
  (ON TABLE)
  
  (setf (get ’object-1 ’weight) 15)
  
  15
  
  (symbol-plist ’object-1)
  
  (WEIGHT 15 POSITION (ON TABLE) SHAPE ROUND SIZE LARGE 
  
 COLOR RED)
  
  (get ’object-1 ’color)
  
  RED
  
  object-1
  
  Error: no value
  
 Note that 
 OBJECT-1
  doesn’t have a value -- all of the useful information is in two places: the 
 identity
  of
  
 the symbol, and the symbol’s properties.
  
 This use of properties predates modern object programming by a few decades. It provides two of the
  
 three essential mechanisms of an object: identity and encapsulation (remember that property values
  
 could just as well be a function). The third mechanism, inheritance, was sometimes simulated by
  
 links to other ""objects.""
  
 Properties are less often used in modern Lisp programs. Hash tables (see below) [p 73] , structures
  
 (described in the next section), and CLOS objects (see Chapter 7 [p 117] and Chapter 14 [p 157] ) provide
  
 all of the capabilities of property lists in ways that are easier to use and more efficient. Modern Lisp
  
 development systems often use properties to annotate a program by keeping track of certain information
  
 such as the file and file position of the defining form for a symbol, and the definition of a function’s
  
 argument list (for use by informational tools in the programming environment).
  
 71",NA
Structures let you store related data,"A Lisp structure gives you a way to create an object which stores related data in named slots.
  
  (defstruct struct-1 color size shape position weight)
  
  STRUCT-1
  
  (setq object-2 (make-struct-1
  
 :size ’small 
  
 :color ’green 
  
 :weight 10 
  
 :shape ’square))
  
  #S(STRUCT-1 :COLOR GREEN :SIZE SMALL :SHAPE SQUARE 
  
 :POSITION NIL :WEIGHT 10)
  
  (struct-1-shape object-2)
  
  SQUARE
  
  (struct-1-position object-2)
  
  NIL
  
  (setf (struct-1-position object-2) ’(under table))
  
  (UNDER TABLE)
  
  (struct-1-position object-2)
  
  (UNDER-TABLE)
  
 In the example, we defined a structure type named 
 STRUCT-1
  with slots named 
 COLOR
 , 
 SHAPE
 , 
 SIZE
 , 
  
 POSITION
 , and 
 WEIGHT
 . Then we created an instance of a 
 STRUCT-1
  type, and assigned the instance
  
 to the variable 
 OBJECT-2
 . The rest of the example shows how to access slots of a struct instance using
  
 accessor functions named for the structure type and the slot name. Lisp generates the make-
 structname
  
 and 
 structname
 -
 slotname
  functions when you define a structure using 
 DEFSTRUCT
 .
  
 We’ll look at 
 DEFSTRUCT
 ’s optional features in Chapter 6 [p 112] .",NA
Type information is apparent at runtime,"A symbol can be associated with any type of value at runtime. For cases where it matters, Lisp lets you
  
 query the type of a value.
  
  (type-of 123)
  
  FIXNUM
  
  (type-of 123456789000)
  
  BIGNUM
  
  (type-of ""hello, world"")
  
  (SIMPLE-BASE-STRING 12)
  
  (type-of ’fubar)
  
  SYMBOL
  
  (type-of ’(a b c))
  
  CONS
  
 72",NA
Hash Tables provide quick data access from a lookup key,"A hash table associates a value with a unique key. Unlike a property list [p 71] , a hash table is well suited
  
 to a large number of key/value pairs, but suffers from excessive overhead for smaller sets of associations.
  
  (setq ht1 (make-hash-table))
  
  #<HASH-TABLE>
  
  (gethash ’quux ht1)
  
  NIL
  
  NIL
  
  (setf (gethash ’baz ht1) ’baz-value)
  
  BAZ-VALUE
  
  (gethash ’baz ht1)
  
  BAZ-VALUE
  
  T
  
  (setf (gethash ’gronk ht1) nil)
  
  NIL
  
  (gethash ’gronk ht1)
  
  NIL
  
  T
  
 You create a hash table using 
 MAKE-HASH-TABLE
 , and access values using 
 GETHASH
 . 
 GETHASH
  
 returns two values. The first is the value associated with the key. The second is 
 T
  if the key was found, and 
  
 NIL
  otherwise. Notice the difference between the first and last 
 GETHASH
  form in the examples above.
  
 By default, a hash table is created so that its keys are compared using 
 EQ
  -- this works for symbols, but
  
 not numbers or lists. We’ll learn more about equality predicates in Chapter 17 [p 174] . For now, just
  
 remember that if you want to use numbers for keys, you must create a hash table using the form:
  
 (make-hash-table :test #’eql)
  
 If you want to use lists for keys, create your hash table with: 
  
 (make-hash-table :test #’equal)
  
 If you want to remove a key, use the form 
 (REMHASH 
 keyhash-table
 )
 . And if you want to change
  
 the value for a key, use 
 GETHASH
  with 
 SETF
 , just as if you were adding a new key/value pair.
  
 73",NA
Packages keep names from colliding,"One of the things that’s hard about writing programs is naming parts of your program. On one hand, you 
 want to use names that are easy to remember and evocative of the role or purpose of the named object. On 
 the other hand, you don’t want to use a name that someone else has already used (or is likely to use) in a 
 different program that you may someday have to make work with your program.
  
 One way to avoid naming conflicts is to give every name in your program a unique prefix that no one else 
 is likely to use. You see this done all the time with libraries -- the prefix is typically one to three 
 characters. Unfortunately, this still leaves a lot of room for two software developers to choose the same 
 prefix; especially since some prefixes are more evocative than others. If you have control over all the 
 software that will be developed for your product, you can choose all of the prefixes and avoid problems. If 
 you’re going to buy third-party software that uses a prefix naming scheme, you’ll have to work around the 
 names chosen by your vendors and hope that two different vendors don’t stumble upon the same prefix.
  
  
 Another way to avoid naming conflicts is to use qualified names. To do this, the language must provide 
 support for separate namespaces defined and controlled by the programmer. To understand how this 
 works, imagine that all the names you create for your program get written on a sheet of paper with your 
 name written at the top as a title -- this is the 
 qualifier
  for all of your names. To see whether a name is safe 
 to use, you only have to check the list of names you’ve written on this page. When someone else’s 
 software needs the services of your program, they refer to your names by using both your qualifier and 
 name. Because the other person’s software has a different qualifier, and their qualifier is implicit (that is, it 
 doesn’t need to be written) for their own names, there’s no chance of a name conflict.
  
 You might think that a qualifier is no more than a complicated way to add a prefix to a name. However, 
 there’s a subtle but important difference. A prefix is part of the name; it cannot be changed once written. A 
 qualifier is separate from the names it qualifies, and is ""written down"" in exactly one place. Furthermore, 
 you can point to the ""sheet of paper"" upon which names are written and refer to it as ""those names."" If you 
 happen to choose the same qualifier as another programmer, you can still refer to ""those names"" by a 
 qualifier of your own choosing -- In other words, you can change the qualifier 
 after the software has been 
 delivered for your use
 .
  
 74",NA
Chapter 3 - Essential Lisp in Twelve Lessons,NA,NA
Lesson 11 - Essential Input and Output,NA,NA
READ accepts Lisp data,"As we saw in Lesson 10, 
 READ
  turns characters into Lisp data. So far, you’ve seen a printed representation 
 of several kinds of Lisp data:
  
  
  
  
 symbols and numbers, 
  
 strings, characters, lists, arrays, vectors, and structures, 
 and hash tables.
  
 The Lisp reader does its job according to a classification of characters. The standard classifications are 
 shown below. As we’ll see in Lesson 12 [p 82] , you can alter these classifications for your own needs.
  
 Standard Constituent Characters
  
 -------------------------------
  
  a b c d e f g h i j k l m n o p q r s t u v w x y z 
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
 0 1 2 3 4 5 6 7 8 9
  
  ! $ % & * + - . / : < = > ? @ [ ] ^ _ { } ~
  
  <backspace> <rubout>
  
 Standard 
 Terminating 
 Macro 
 Characters
  
 ------------------------------------
 -
  
  "" ’ ( ) , ; ‘
  
 Standard 
 Non-Terminating 
 Macro 
 Characters
  
 ----------------------------------------
 -
  
  #
  
 Standard 
 Single 
 Escape 
 Characters
  
 --------------------------------
 -
  
  \
  
 Standard 
 Multiple 
 Escape 
 Characters
  
 ----------------------------------
 -
  
  |
  
 Standard 
 Whitespace 
 Characters
  
 ------------------------------
  
  <tab> 
 <space> 
 <page> 
 <newline> 
 <return> 
 <linefeed>
  
 If 
 READ
  starts with a 
 constituent
  character, it begins accumulating a symbol or number. When 
 READ 
 encounters a terminating macro character or a whitespace character, it tries to interpret the collected 
 constituent characters first as a number, then as a symbol. If a numeric interpretation is possible, 
 READ",NA
PRINT writes Lisp data for you and for READ,"The 
 PRINT
  function changes a Lisp object into the sequence of characters that 
 READ
  would need to 
 reconstruct it:
  
  
  
  
  
  
  
  
  
  
  
  (print ’abc)
  
  ABC  
  
  ABC
  
  (print (list 1 2 3))
  
  (1 2 3)  
  
  (1 2 3)
  
  (print ""A String"")
  
  ""A string""  
  
  ""A string""
  
  (print 387.9532)
  
  387.9532  
  
  387.9532
  
  (print (make-hash-table))
  
  #<HASH-TABLE>  
  
  #<HASH-TABLE>
  
 PRINT
  always begins its output with a newline character (  ), and follows its output with a space (  ). This 
 ensures that the 
 PRINT
  output stands apart from any surrounding output, since newline and space are both 
 treated as whitespace, and cannot be part of the printed representation of a Lisp object (unless escaped).
  
 Other variations of 
 PRINT
  have different uses. 
 PRIN1
  behaves as 
 PRINT
 , but does not surround its 
 output with whitespace. This might be useful if you are building up a name from successive pieces, for 
 example. 
 PRINC
  behaves as 
 PRIN1
 , but generates output intended for display, rather than 
 READ
 ; for 
 example, 
 PRINC
  omits the quotes around a string, and does not print escape characters.
  
 78",NA
OPEN and CLOSE let you work with files,"Normally, 
 READ
  reads from the keyboard and 
 PRINT
  prints to the screen. Both of these functions take an 
 optional argument; the argument specifies an input stream for 
 READ
 , and an output stream for 
 PRINT
 . 
 What’s a stream? A stream is a source or sink of data, typically -- but not necessarily -- characters. For 
 now, we’ll look at how text files can be the source or sink of a character stream. In Chapter 19 [p 183] 
 we’ll look at some of the other possibilities.
  
 You can attach a stream to a file using the 
 OPEN
  function, which takes as parameters a file name and a 
 keyword argument to specify the direction (input or output) of the stream. To finish operations on the 
 stream and close the associated file, use the 
 CLOSE
  function.
  
  
  
  
  
  
  
  
  
  
  
  
  
  (setq out-stream (open ""my-temp-file"" :direction :output)) 
 #<OUTPUT-STREAM ""my-temp-file"">
  
  (print ’abc out-stream)
  
  ABC
  
  (close out-stream)
  
  T
  
  (setq in-stream (open ""my-temp-file"" :direction :input)) 
 #<INPUT-STREAM ""my-temp-file"">
  
  (read in-stream)
  
  ABC
  
  (close in-stream)
  
  T
  
 In the example, we create an output stream to the file named 
 my-temp-file
 , and print the symbol 
 ABC 
 to that stream. Notice how 
 PRINT
  returns its argument as usual, but doesn’t print it -- the printed result 
 has gone to the file, instead.
  
 Next, we close the output stream and open an input stream on the same file. We then read the symbol that 
 we printed to the file, and finish by closing the input stream.
  
 79",NA
Variations on a PRINT theme,"Lisp also provides a 
 WRITE
  function to give you control over more details of printing, using keyword 
 arguments to control these options:
  
 Keyword Argument   Default Value           Action
  
 ----------------   -------------           ------
  
  :stream           t                       set output stream
  
  :escape           *print-escape*          include escape characters 
 :radix            *print-radix*           include radix (base) prefix 
 :base             *print-base*            set number base (rationals) 
 :circle           *print-circle*          print circular structures 
 :pretty           *print-pretty*          add whitespace for readability 
 :level            *print-level*           limit nesting depth
  
  :length           *print-length*          limit items per nesting level 
 :case             *print-case*            :upper, :lower, or :mixed 
 :gensym           *print-gensym*          prefix uninterned symbols 
 :array            *print-array*           print arrays readably
  
  :readably         *print-readably*        force printing to be readable 
 :right-margin     *print-right-margin*    controls pretty-printing 
 :miser-width      *print-miser-width*                ""
  
  :lines            *print-lines*                      ""
  
  :pprint-dispatch  *print-pprint-dispatch*            ""
  
 Coincidentally, the variables named above as the default values of the keyword arguments also control the 
 operation of 
 PRINT
 . You can get the effect of 
 WRITE
  with non-default keyword arguments by binding 
 these variables in a 
 LET
  form around a 
 PRIN1
 :
  
 (write foo                    (let ((*print-pretty* t)
  
  :pretty t                        (*print-right-margin* 60) 
 :right-margin 60                 (*print-case* :downcase)) 
 :case :downcase)             (prin1 foo))
  
 We used 
 PRIN1
  rather than 
 PRINT
  because we don’t want the preceding newline and following blank that 
 PRINT
  adds.
  
 If your program changes the 
 *PRINT-...*
  variables, but you need to ensure the default values at some 
 point in your program, you can wrap that part of the program inside a 
 WITH-STANDARD-IO-SYNTAX 
 form:
  
 ;Define printer control for the program.
  
 (setq *print-circle* t) 
  
 (setq *print-array* nil) 
  
 (setq *print-escape* nil) 
  
 ...
  
 ;Print with the settings established above.
  
 (print ...) 
  
 ...
  
 ;Change back to default printer control settings 
 (with-standard-io-syntax
  
  ...
  
  
 ;Print with the standard settings,
  
  ;overriding those established above.
  
  (print ...)
  
 80",NA
Chapter 3 - Essential Lisp in Twelve Lessons,NA,NA
Lesson 12 - Essential Reader Macros,NA,NA
The reader turns characters into data,"We saw in Lesson 11 that the Lisp reader gathers constituent characters into symbols and numbers, and
  
 that macro characters control the reader to handle lists, strings, quoted forms, and comments. In all of
  
 these cases, the reader turns characters into data. (For reasons that will become clear shortly, a comment is
  
 just ""no data."")",NA
Standard reader macros handle built-in data types,"So far, we’ve seen just the 
 standard syntax
  for Lisp. This is implemented by the reader, and controlled by
  
 the 
 readtable
 . The reader works by processing characters according to information stored in the readtable.",NA
User programs can define reader macros,"Lisp exposes the readtable through the 
 *readtable*
  variable, and provides several functions to
  
 manipulate entries in readtables. You can use these to alter the behavior of the Lisp reader. In the
  
 following example, we change the syntax so we can write quoted (i.e. unevaluated) lists using 
 [
  and 
 ]
 .
  
 ;This is wrong:
  
  
  (1 2 3 4 5 6)
  
  
  Error: 1 is not a function
  
 ;Should have done this, instead:
  
  
  ’(1 2 3 4 5 6)
  
  
  (1 2 3 4 5 6)
  
 ;Define new syntax so we can write something like
  
 ; [1 2 3 4 5 6]
  
 ;instead of
  
 ; ’(1 2 3 4 5 6)
  
  
  (defun open-bracket-macro-character (stream char)
  
  ‘’,(read-delimited-list #\] stream t))
  
  
  OPEN-BRACKET-MACRO-CHARACTER
  
  
  (set-macro-character #\[ #’open-bracket-macro-character)
  
  
  T
  
  
  (set-macro-character #\] (get-macro-character #\)))
  
  
  T
  
 ;Now try it:
  
  
  [1 2 3 4 5 6]
  
  
  (1 2 3 4 5 6)
  
 82",NA
Chapter 4 - Mastering the Essentials,"We’ve explored the fundamental concepts of Lisp through the twelve lessons of Chapter 3. If you feel that 
 you have a very strong grasp of these fundamentals, or if you’ve worked with Lisp before, you may want 
 to skim the remainder of this chapter.
  
 We’ll review some of the material from Chapter 3 using a hands-on approach. Along the way, you’ll learn 
 some new techniques that have had to wait until all of the fundamentals had been introduced; if you’re a 
 beginner and haven’t read Chapter 3, go back and read it before you try to do the exercises in this chapter.
  
 You should have access to a Lisp development system as you work through this chapter. As you read this 
 chapter, please take the time to run the examples using your Lisp system. This will give you a chance to 
 learn how your Lisp system responds to input, including any mistakes you may make. (If you don’t make 
 any mistakes in transcribing the examples, you should get adventurous and try to modify some of the 
 examples.) Appendix A [p 260] lists several commercial, shareware, and free Lisp systems for Macintosh, 
 DOS, and Windows computers.",NA
"Hands-on! The ""toploop""","You interact with the Lisp system through a built-in piece of code called the toploop, which repeats three 
 simple steps for as long as you run the Lisp system:
  
 1. Read an expression (you provide the expression).
  
 2. Evaluate the expression just read. 
  
 3. Print the result(s) of the evaluation.
  
 This is also called the ""read-eval-print"" loop. Some Lisp systems evaluate the expression using a Lisp 
 interpreter; modern systems use a compiling evaluator, which first compiles the expression to machine 
 code then executes the code. A compiling evaluator is also an incremental compiler, so named because it 
 can compile a program in increments of one expression.
  
 The toploop also provides a minimal user interface -- a prompt to indicate that it’s ready to read a new 
 expression -- and a way to gracefully catch any errors you might make.
  
 If you were to write the Lisp code for a toploop, it would look something like this:
  
 (loop
  
  (terpri)
  
  (princ ’ready>)
  
  (print (eval (read))))
  
 NOTE 1: (terpri) prints a blank line.
  
 NOTE 2: (loop ...) executes its forms in order, then repeats -- we’ll see more of 
 LOOP
  in Chapter 5 [p 
 108] .
  
 84",NA
Spotting and avoiding common mistakes,"""I entered a Lisp expression, but nothing happened."" The most common cause of this problem is missing a 
 matching delimiter -- typically a right parenthesis or double-quote -- somewhere in your expression. 
 Unlike some development systems which process your input each time you enter a line of code, Lisp waits 
 for you to enter a complete expression before attempting to process anything. What happens if you enter 
 the following code in your system?
  
 ? (defun bad-1 ()
  
  (print ""This is a bad function definition) 
 (print ""But I’ll try it anyway...""))
  
 Looks good, huh? All the parentheses match, and you press the 
 ENTER
  key that one last time, and... 
 Nothing. The string argument to the first print statement is missing a closing double-quote, turning the rest 
 of your input into part of the string. You’ll do this more than once (trust me), so the best thing to do is to 
 consult your Lisp system manual to find out how to edit the pending input so you can add the missing
  
 85",NA
Defining simple functions,"We’ve already seen a few function definitions: the 
 FACTORIAL
  function (above) and a function or two in 
 Chapter 3, Lesson 7. To review, a function is defined as follows:
  
 (defun 
 function-name
  (
 argument-names
  ...) 
  
  
 function-body
  )
  
 The 
 (
 argument-names
 ...)
  is called a 
 lambda list
 . Names in this list are bound to values when the 
 function is called. The body of the function may refer to these names; identical names appearing elsewhere 
 in your program (that is, outside the function body) are irrelevant to the function. Also, if your function 
 changes the binding of an argument inside the function, the caller 
 does not
  receive the changed value. The 
 proper way to return values from a Lisp function is to return them as the value of the function.
  
 For example:
  
 ? (defun quadratic-roots (a b c)
  
  
  ""Returns the roots of a quadratic equation aX^2 + bX + c = 0""
  
  (let ((discriminant (- (* b b) (* 4 a c))))
  
  
  
  (values (/ (+ (- b) (sqrt discriminant)) (* 2 a))
  
  
  
  (/ (- (- b) (sqrt discriminant)) (* 2 a))))) 
  
 QUADRATIC-ROOTS
  
 ? (quadratic-roots 1 2 4) 
  
 #c(-1.0 1.7320508075688772) 
  
 #c(-1.0 -1.7320508075688772)
  
 ? (quadratic-roots 2 -16 36) 
  
 #c(4.0 1.4142135623730951) 
  
 #c(4.0 -1.4142135623730951)
  
 ? (quadratic-roots 1 4 4)
  
 -2
  
 -2
  
 ? (quadratic-roots 1 -14 49) 
  
 7 
  
 7
  
 ? (quadratic-roots 1 8 4)
  
 -0.5358983848622456
  
 -7.464101615137754
  
 ? (quadratic-roots 1 4 -5) 
  
 1
  
 -5
  
 The 
 QUADRATIC-ROOTS
  function shows how to use a documentation string. The first form in the 
 function body is a string. This does not affect the function result, but it 
 is
  recorded by the Lisp system for 
 later reference:
  
 87",NA
Using global variables and constants ,"In Lesson 3, we used 
 SETQ
  to define global variables. You can do this using a top-level form, as in Lesson 
 3, or from within a function, such as this:
  
 ? (defun set-foo-globally (x)
  
  
  (setq foo x)) 
  
 SET-FOO-GLOBALLY
  
 ? foo 
  
 Error: unbound variable FOO
  
 ? (set-foo-globally 3) 
  
 3
  
 ? foo 
  
 3
  
 Depending upon your Lisp system, you may have seen a warning message when you defined 
 SET-FOO-
 GLOBALLY
 :
  
 ? (defun set-foo-globally (x)
  
  
  (setq foo x)) 
  
 Warning: undeclared free variable FOO, in SET-FOO-GLOBALLY.
  
 SET-FOO-GLOBALLY
  
 This is not an error -- the function does what we want. But 
 FOO
  is said to be free because the function does 
 not create a binding for 
 FOO
 . Variable bindings are created by lambda lists (the function’s argument list) 
 and by 
 LET
  forms (see Lesson 6), among others.
  
 My Lisp system warns me about free variables in function definitions because they could be a symptom of 
 a typographical error:
  
 ? (setq *olympic-year* 1996) 
  
 1996
  
 ? (defun set-next-olympic-year ()
  
  
  (setq *olympic-year* (+ *olmpic-year* 2))) 
  
 Warning: undeclared free variable *OLMPIC-YEAR*, in SET-NEXT-OLYMPIC-YEAR.
  
 SET-NEXT-OLYMPIC-YEAR
  
 Here, I misspelled the second instance of my global variable 
 *OLYMPIC-YEAR*
 , and the compiler 
 warned me. Notice that I didn’t get a warning for the correctly spelled 
 *OLYMPIC-YEAR*
  because I had 
 defined it globally in a top-level 
 SETQ
  form.
  
 There are two more ways to define global variables in Lisp:
  
 ? *var1* 
  
 Error: unbound variable
  
 ? (defvar *var1* 1) 
  
 *VAR1*
  
 ? *var1*
  
 91",NA
Defining recursive functions,"A function that calls itself is 
 recursive
 . The recursive call may be direct (the function calls itself) or 
 indirect (the function calls another function which -- perhaps after calling still more functions -- calls the 
 original function).
  
 You need to follow two simple rules of thumb to make recursive functions work. These rules suggest the 
 structure of a recursive function -- it must behave appropriately according to its current inputs:
  
 1.  One case must 
 not
  make a recursive call. 
  
 2.  Other cases must 
 reduce
  the amount of work to be done in a recursive call.
  
 Let’s dig up the 
 FACTORIAL
  function that we’ve already used in several examples, and see how it follows 
 these rules: 
  
 (defun factorial (n)
  
  
  (cond ((zerop n) 1)
  
   
  (t (* n (factorial (1- n))))))
  
 This function has two cases, corresponding to the two branches of the 
 COND
 . The first case says that the 
 factorial of zero is just one -- no recursive call is needed. The second case says that the factorial of some 
 number is the number multiplied by the factorial of one less than the number -- this is a recursive call 
 which reduces the amount of work remaining because it brings the number closer to the terminating 
 condition of the first 
 COND
  clause. (For clarity, I’ve assumed that the number initially given to 
 FACTORIAL
  is non-negative.)
  
 Let’s work through another simple recursive definition. The length of an empty list is zero. The length of a 
 non-empty list is one plus the length of the list reduced by one element. These two statements state exactly 
 what is required by our rules of thumb, above. The first statement gives the answer for a list of known 
 length -- the trivial case of an empty list. The second statement gives the answer for a list of unknown 
 length 
 in terms of the answer for a list of reduced length
 . Here’s how it translates into code:
  
 ? (defun my-length (list)
  
  
  (cond ((null list) 0)
  
  
  (t (1+ (my-length (rest list)))))) 
  
 MY-LENGTH
  
 ? (my-length ’(a b c d)) 
  
 4
  
 NULL
  is true for an empty list, so the first 
 COND
  clause returns zero for the empty list. The second 
 COND 
 clause gets evaluated (if the first clause if skipped) because its condition is 
 T
 ; it adds one to the result of 
 the recursive call on a list which is one element shorter (a list consists of its 
 FIRST
  element and the 
 REST 
 of the list.)
  
 Note the similarities between 
 FACTORIAL
  and 
 MY-LENGTH
 . The base case is always the first in the 
 COND
  because it must be tested 
 before
  the recursive case -- otherwise, the recursive function calls would 
 never end.
  
 93",NA
Tail recursion,"A function that calls itself as its very last action is said to make a tail-recursive call. Here are two versions 
 of the factorial function to illustrate the difference between a tail-recursive call and an ordinary recusive 
 call:
  
 ; Normal recursive call
  
 (defun factorial (n)
  
  (cond ((zerop n) 1)
  
   
  (t (*      
 ; * is the last function called
   
  
  n
  
   
  
  (factorial (- n 1))))))
  
 ; Tail-recursive call
  
 (defun factorial-tr (n)
  
  (factorial-tr-helper n 1))
  
 (defun factorial-tr-helper (n product)
  
  (cond ((zerop n) product)
  
   
  (t 
  
   
  
 ; factorial-tr-helper is the last function called
   
  
  (factorial-tr-helper (- n 1) (* product n)))))
  
 FACTORIAL-TR
  calls 
 FACTORIAL-TR-HELPER
 , passing the original argument, 
 N
 , plus an additional 
 argument used as the initial value of an accumulator for the product which will become the value of the
  
 94",NA
Exercises in naming,"A name in Lisp can be made of any non-whitespace characters except for certain characters reserved as 
 reader macro characters (see Chapter 3, Lesson 11), namely 
 ""
 , 
 ’
 , 
 (
 , 
 )
 , 
 ,
 , 
 ;
 , 
 ‘
 , and 
 #
 . Furthermore, the 
 name can’t be a number in the current number base, as set by 
 *READ-BASE*
 . Thus, FACE is a name 
 when 
 *READ-BASE*
  is 10, but a number when 
 *READ-BASE*
  is 16 (or higher).
  
 Most Lisp programmers follow a few naming conventions to identify the names that certain roles. Global 
 variables are almost always written with a leading and trailing 
 *
 , for example:
  
 *next-id* 
  
 *home-directory* 
  
 *software-version*
  
 96",NA
"Lexical binding, and multiple name spaces","The following piece of code illustrates how you can use the same name for different purposes. Take a 
 minute to read this, and see how many separate uses you can count for the name 
 FUNNY
 .
  
 (defun funny (funny)
  
  
  ""funny...""
  
  
  (if (zerop funny)
  
   
  :funny
  
   
  (list
  
   
  (cons funny 
  
     
  (let ((funny funny))
  
     
  
  (setq funny (1- funny))
  
     
  
  (funny funny))) 
  
   
  funny)))
  
 Here are the five roles played by this one name:
  
 97",NA
"Reading, writing, and arithmetic","Your programs usually need to get input and produce output. If you’re working with a system that 
 supports windows and dialogs, you can certainly use these graphical devices. Relying instead on Lisp’s 
 built-in facilities for reading and writing strings of characters will ensure that your program is useful (or at 
 least usable) on all kinds of computers.
  
 Most elementary programming texts include a simple program to demonstrate the ""input, process, output"" 
 approach. Our example in Lisp reads a series of numbers, adds them, and prints the sum when we enter a 
 special token instead of a number:
  
 99",NA
Other data types,"Let’s put together an extended example to show how we might use several of Lisp’s built-in data types. 
 We’ll build a simple application to keep track of bank checks as we write them. For each check, we’ll 
 track the check number, payee, date, amount, and memo. We’ll support queries to display an individual 
 check, to list all checks paid to a payee, to list all the payees, to sum all of the check amounts, and to list 
 all of the checks we’ve paid. We’ll also provide a way to void a check once written.
  
 Here’s the code:
  
 (defvar *checks* (make-array 100 :adjustable t :fill-pointer 0) 
 ""A vector of checks."")
  
 (defconstant +first-check-number+ 100 
  
  ""The number of the first check."")
  
 (defvar *next-check-number* +first-check-number+  
 ""The number of the next check."")
  
 (defvar *payees* (make-hash-table :test #’equal)  
 ""Payees with checks paid to each."")
  
 (defstruct check
  
  number date amount payee memo)
  
 (defun current-date-string ()
  
  ""Returns current date as a string.""
  
  (multiple-value-bind (sec min hr day mon yr dow dst-p tz)
  
   
  (get-decoded-time)
  
   
  (declare (ignore sec min hr dow dst-p tz))
  
   
  (format nil ""~A-~A-~A"" yr mon day)))
  
 (defun write-check (amount payee memo)
  
  ""Writes the next check in sequence.""
  
  (let ((new-check (make-check 
  
   
  :number *next-check-number*
   
  :date (current-date-string)
   
  :amount amount
  
   
  :payee payee
  
   
  :memo memo)))
  
 102",NA
Simple macros,"The one important feature missing from our check writing program is the ability to save and restore its
  
 state. 
  
 Since 
  
 the 
  
 state 
  
 is 
  
 completely 
  
 contained 
  
 in 
  
 three 
  
 global 
  
 variables, 
  
 *CHECKS*
 , 
  
 *NEXT-CHECK-NUMBER*
 , and 
 *PAYEES*
 , all we really have to do is to use 
 PRINT
  to write the values
  
 of these variables to a file, and 
 READ
  to reload them at a later time.
  
 But with a little more work we can write a macro that will write our save and restore functions. Then we
  
 can use this macro not only for our check writing program, but also for any program which keeps its state
  
 in global variables.
  
 First take a look at the finished macro, then we’ll dissect it:
  
 (defmacro def-i/o (writer-name reader-name (&rest vars))
  
  (let ((file-name (gensym))
  
  (var (gensym))
  
  (stream (gensym)))
  
  ‘(progn
  
  (defun ,writer-name (,file-name)
  
  (with-open-file (,stream ,file-name
  
  :direction :output :if-exists :supersede)
  
  (dolist (,var (list ,@vars))
  
 104",NA
Reader macros,"Our check-writing application has one small problem. If we use floating point numbers to represent dollars 
 and cents, our sums could be off by a penny in some cases. What we should really do is to represent all 
 currency in terms of whole pennies. We can make a reader macro to help with the input of dollar and cent 
 amounts, converting input like 
 $10.95
  into the corresponding number of pennies.
  
 Here’s the code:
  
 (set-macro-character #\$
  
  
  #’(lambda (stream char)
  
  
  
  (declare (ignore char))
  
  
  
  (round (* 100 (read stream)))))
  
 The rounding step ensures that the amount is a whole number. Binary floating point numbers can not 
 precisely 
  
 represent 
  
 all 
  
 decimal 
  
 fractions. For 
  
 example, 
  
 (* 
  
 100 
  
 9.95) 
  
 yields 
 994.9999999999999
  and 
 (* 100 1.10)
  yields 
 110.00000000000001
  on my Lisp system.
  
 This says to set 
 $
  to be a macro character which, when encountered by the reader, calls 
 READ
  to get a 
 number and return the nearest whole number after multiplying by 100. It’s used like this:
  
 ? $9.95 
  
 995
  
 ? $-7.10
  
 -710
  
 Now that you can enter dollar amounts directly, you may want to modify the check-writing application to 
 print amounts in whole cents as dollars and cents. To do this, you would redefine the 
 CHECK
  structure 
 with a custom print function, as follows:
  
 106",NA
Chapter 5 - Introducing Iteration,"Lisp has several ways to do iteration. In this section we’ll look at the most common looping constructs. 
 Later, in Chapter 12 [p 144] , we’ll look at mapping, then we’ll take a brief look at 
 series
  in Chapter 32 [p 
 250] ; both of these are closely related to iteration.",NA
Simple LOOP loops forever...,"The simplest loop in Lisp is just a 
 LOOP
  form wrapped around whatever you want to repeat. Before you 
 try this next bit of code, know how to interrupt execution of your Lisp system; normally this is Command-
 period on a Macintosh or Control-Break on a PC. 
  
 ? (loop
  
  
  (print ""Look, I’m looping!"")) 
  
 ""Look, I’m looping!"" 
  
 ""Look, I’m looping!"" 
  
 ""Look, I’m looping!"" 
  
 ""Look, I’m looping!"" 
  
 ""Look, I’m looping!"" 
  
 ""Look, I’m looping!"" 
  
 ""Look, I’m looping!"" 
  
 ""Look, I’m looping!"" 
  
 ... and so on, until you interrupt execution...
  
 Aborted 
  
 ?
  
 This kind of endless loop has legitimate applications. You’re already familiar with one: 
 (LOOP (PRINT 
 (EVAL (READ))))
 , Lisp’s read-eval-print loop.
  
 Actually, your Lisp system does some extra things in its read-eval-print loop: 
  
  
 it catches all errors to prevent you from inadvertently breaking out of the loop 
  
  
 it provides a controlled way to exit the loop 
  
  
 it keeps track of the most recently entered expressions, results, and printed output",NA
But there’s a way out!,"Most of the time you write a 
 LOOP
  form, you’d like to have a way out. Fortunately, a 
 RETURN
  form 
 anywhere inside will cause control to leave the 
 LOOP
 ; any value you specify becomes the value of the 
 LOOP
  form:
  
 ? (loop
  
  
  (print ""Here I am."")
  
  
  (return 17)
  
  
  (print ""I never got here."")) 
  
 ""Here I am."" 
  
 17
  
 RETURN
  is normally used in a conditional form, like this: 
  
 108",NA
Use DOTIMES for a counted loop,"To simply loop for some fixed number of iterations, the 
 DOTIMES
  form is your best choice. The previous 
 example simplifies to:
  
 ? (dotimes (n 11)
  
  
  (print n) (prin1 (* n n))) 
  
 0 0 
  
 1 1 
  
 2 4 
  
 3 9 
  
 4 16 
  
 5 25 
  
 6 36 
  
 7 49 
  
 8 64 
  
 9 81 
  
 10 100 
  
 NIL 
  
 ?
  
 DOTIMES
  always returns NIL.",NA
Use DOLIST to process elements of a list,"Another common use for iteration is to process each element of a list. 
 DOLIST
  supports this:
  
 109",NA
"DO is tricky, but powerful","The 
 DO
  form lets you iterate over multiple variables at the same time, using arbitrary forms to step each 
 variable to its next value. Here’s an example which both iterates over the elements of a list and runs a 
 counter at the same time:
  
 ? (do ((which 1 (1+ which))
  
  
   
  (list ’(foo bar baz qux) (rest list)))
  
  
  
  ((null list) ’done)
  
  
  (format t ""~&Item ~D is ~S.~%"" which (first list))) 
 Item 1 is FOO.
  
 Item 2 is BAR.
  
 Item 3 is BAZ.
  
 Item 4 is QUX.
  
 DONE 
  
 ?
  
 110",NA
Chapter 6 - Deeper into Structures,"Structures were introduced in Chapter 3. In this chapter, we’ll look at the most useful optional features of 
 structures.",NA
"Default values let you omit some initializers, sometimes","Normally, if you create a new structure without specifying a value for some slot, that slot will default to 
 NIL
 .
  
 ? (defstruct foo-struct a b c) 
  
 FOO-STRUCT
  
 ? (let ((foo-1 (make-foo-struct :a 1 :b ""two"")))
  
  (print (foo-struct-b foo-1))
  
  
  (print (foo-struct-c foo-1))
  
  
  (values)) 
  
 ""two"" 
  
 NIL
  
 NOTE: We use the 
 (values)
  form to suppress the return value from the 
 LET
  form. Otherwise, we 
 would have seen one more 
 NIL
  printed.
  
 In cases where 
 NIL
  is a reasonable default value, this behavior is acceptable. But if the normal value of a 
 slot is numeric, for example, you’d really like to start with a reasonable default value rather than having to 
 add a test in all of the code which uses a structure. The full form of a slot specification is a list of the slot 
 name, its default value, and additional options; specifying a bare name instead of the complete list is 
 shorthand for ""default value of NIL, and no options.""
  
 ? (defstruct ship
  
  
  (name ""unnamed"")
  
  
  player
  
  
  (x-pos 0.0)
  
  
  (y-pos 0.0)
  
  
  (x-vel 0.0)
  
  
  (y-vel 0.0)) 
  
 SHIP
  
 When we instantiate this structure using 
 (MAKE-SHIP)
 , the 
 NAME
  slot defaults to 
 ""unnamed""
 , the 
 PLAYER
  slot defaults to 
 NIL
 , and the position and velocity slots all default to 
 0.0
 .
  
 Of course, we can still specify slot values to override the defaults:
  
 ? (make-ship :name ""Excalibur"" :player ""Dave"" :x-pos 100.0 :y-pos 221.0) 
  
 #S(SHIP :NAME ""Excalibur"" :PLAYER ""Dave"" :X-POS 100.0 :Y-POS 221.0 :X-VEL 0.0 :Y-VEL 0.0)
  
 Lisp’s default printer for structures makes it easy to see the slots and their values. We’ve given explicit 
 values to all of the slots except the two velocity slots, which have their default values.
  
 112",NA
Change the way Lisp prints your structures,"To print a structure using other than the default printer, you may define a new print function as a structure 
 option.
  
 ? (defstruct (ship
  
  
  (:print-function
  
  
  
  
  (lambda (struct stream depth)
  
  
  
   
  (declare (ignore depth))
  
  
  
   
  (format stream ""[ship ~A of ~A at (~D, ~D) moving (~D, ~D)]""
  
  
    
  (ship-name struct)
  
  
  
    
  (ship-player struct)
  
  
  
    
  (ship-x-pos struct)
  
  
  
    
  (ship-y-pos struct)
  
  
  
    
  (ship-x-vel struct)
  
  
  
    
  (ship-y-vel struct)))))
  
  
  (name ""unnamed"")
  
  
  player
  
  
  (x-pos 0.0)
  
  
  (y-pos 0.0)
  
  
  (x-vel 0.0)
  
  
  (y-vel 0.0)) 
  
 SHIP
  
 ? (make-ship :name ""Proud Mary"" :player ’CCR) 
  
 [ship Proud Mary of CCR at (0.0, 0.0) moving (0.0, 0.0)]
  
 Actually, it’s considered bad practice to print something the reader can’t interpret. Our use of the brackets 
 around the printed ship description is not necessarily good or bad, it depends upon how the current read 
 table is specified (we first saw reader macros in Chapter 3, Lesson 12.
  
 One way to ensure that the reader doesn’t get confused is to deliberately print something so as to be 
 unreadable. By convention, Lisp prints such objects beginning with 
 #<
 . You could change your format 
 string to read 
 ""#<ship ~A of ~A at (~D, ~D) moving (~D, ~D)>""
 , so the prior 
 MAKE-
 SHIP
  example would print 
 #<ship Proud Mary of CCR at (0.0, 0.0) moving (0.0, 
 0.0)>
 . However, since 1990 Lisp systems have had a 
 PRINT-UNREADABLE-OBJECT
  macro which 
 should be used for this purpose. If the printer control variable 
 *PRINT-READABLY*
  is true, 
 PRINT-
 UNREADABLE-OBJECT
  will signal an error.
  
 ;; Use PRINT-UNREADABLE-OBJECT macro -- changes in 
 boldface 
  
 ? (defstruct (ship
  
  
  (:print-function
  
  
  
  
  (lambda (struct stream depth)
  
  
  
   
  (declare (ignore depth)) 
  
  
  
    
 (print-unreadable-object (struct stream)
  
  
  
    
  (format stream ""ship ~A of ~A at (~D, ~D) moving (~D, ~D)""
  
  
      
  (ship-name struct)
  
  
  
      
  (ship-player struct)
  
  
  
      
  (ship-x-pos struct)
  
  
  
      
  (ship-y-pos struct)
  
  
  
      
  (ship-x-vel struct)
  
  
  
      
  (ship-y-vel struct))
 )
 )))
  
  
  (name ""unnamed"")
  
  
  player
  
 113",NA
Alter the way structures are stored in memory,"Lisp stores structures in an implementation-dependent manner unless you specify otherwise using a 
 structure option. You have two choices if you decide to specify structure storage: store it as a vector 
 (possibly with a particular type for all of the elements) or as a list. Here, we use the untyped vector option-
 - the list option is similar:
  
 ? (defstruct (bar
  
  
  
  (:type vector))
  
  
  a b c) 
  
 BAR
  
 ? (make-bar) 
  
 #(NIL NIL NIL)
  
 Note that the slot names are not stored when you specify the storage type. This is probably the biggest 
 advantage for using this option -- it can save storage in the amount of a machine word per slot per 
 instance. The disadvantage is that Lisp does not recognize such a structure as a distinct type, and does not 
 create a 
 <structure-name>-P
  predicate for you.
  
 If you are satisfied with being able to retrieve the name of the structure, but still want the storage savings 
 associated with specifying the structure’s representation, you can do this:
  
 ? (defstruct (bar
  
  
  
  (:type vector)
  
  
  
  :named)
  
  
  a b c) 
  
 BAR
  
 ? (make-bar) 
  
 #(BAR NIL NIL NIL)
  
 Using the list representation option has the drawbacks noted above, but none of the advantages; the 
 backbone of the list typically 
 adds
  a machine word of storage per slot when compared to the default 
 representation, which is usually a vector. The only time it would make sense to explicitly specify a list 
 representation is when the default structure representation is list-based or when the Lisp implementation 
 imposes some artificial limit on the space reserved for storage of vectors; neither case applies in modern 
 implementations.",NA
Shorten slot accessor names,"Slot accessor names are constructed from the name of the structure and the slot. If the structure and the 
 slot both have lengthy names, the accessor names can get unwieldy. You can abbreviate names somewhat 
 by using the 
 :CONC-NAME
  structure option to specify a name to use instead of the structure name. 
  
 114",NA
Allocate new structures without using keyword ,NA,NA
arguments,"For certain structures, it may be more convenient to make a new instance using just a list of arguments 
 instead of keywords and arguments. You can redefine a structure constructor’s argument list using the 
 :CONSTRUCTOR
  option.
  
 ? (defstruct (3d-point
  
  
  (:constructor
  
  
  
  
  create-3d-point (x y z)))
  
  
  x y z) 
  
 3D-POINT
  
 ? (create-3d-point 1 -2 3) 
  
 #S(3D-POINT :X 1 :Y -2 :Z 3)
  
 NOTE: The slot values do 
 not
  default to 
 NIL
  if you use a 
 :CONSTRUCTOR
  option!
  
 Most lambda-list options are available to the constructor function -- consult a Lisp reference manual for 
 details.",NA
Define one structure as an extension of another,"We use inheritance to define one object in terms of another. Structures permit a very simple form of 
 inheritance using the 
 :INCLUDE
  option.
  
 ? (defstruct employee
  
  
  name department salary social-security-number telephone) 
  
 EMPLOYEE
  
 ? (make-employee) 
  
 #S(EMPLOYEE :NAME NIL :DEPARTMENT NIL :SALARY NIL :SOCIAL-SECURITY-NUMBER NIL :TELEPHONE NIL)
  
 ? (defstruct (manager
  
  
  
  (:include employee))
  
  
  bonus direct-reports) 
  
 MANAGER
  
 ? (make-manager) 
  
 #S(MANAGER :NAME NIL :DEPARTMENT NIL :SALARY NIL :SOCIAL-SECURITY-NUMBER NIL :TELEPHONE NIL :BONUS NIL :DIRECT-REPORTS NIL)
  
 All accessors which apply to an 
 EMPLOYEE
  also apply to a 
 MANAGER
 , and a 
 MANAGER
  instance is also an 
 EMPLOYEE
  instance. Notice in the following example how the 
 ...-NAME
  accessors for both 
 MANAGER
  
 and 
 EMPLOYEE
  reference the same slot.
  
 115",NA
Chapter 7 - A First Look at Objects as Fancy ,NA,NA
Structures,"We first encountered structures in Chapter 3, then learned about some of their optional behavior in Chapter 
 6. In this chapter we’ll start to learn about objects in the Common Lisp Object System (CLOS). For now, 
 we’ll look at just the ways objects can be used to structure data. Later, in Chapter 14 [p 157] , we’ll learn 
 more about CLOS.",NA
Hierarchies: Classification vs. containment,"When you program with objects you will attempt, in some way, to create a model of some portion of the 
 real world. When you do this, you’ll probably notice that some objects are made up of smaller parts. Each 
 part has its own identity; the part is identifiable by itself, separate from any object that it may be a part of. 
 Furthermore, a part may be made from smaller parts. If you drew a picture of the component relationships 
 among all the parts of some complex object, you’d find that they formed a hierarchy. The fully-assembled 
 object will be at the top of the hierarchy (the first level), all of its pieces will be at the second level, all of 
 the pieces that make up the second-level parts will be at the third level, and so on. This hierarchy is a 
 containment hierarchy
 ; each level represents an object, and the next lowest level represents the objects that 
 are parts of the object at the higher level. An object at a higher level contains (or has as parts) some objects 
 at a lower level in the hierarchy, and an object at a lower level is contained by (or is part of) some object at 
 a higher level. 
  
 Containment hierarchies are important because they model ""has-a"" and ""is-a-part-of"" relationships among 
 objects. These relationships simplify your program’s model of the real world by letting you think in terms 
 of relatively small component parts, rather than having to model a single, highly complex object. 
 Modeling by containment also pays off when you can model a similar object in terms of a different 
 combination of components. 
  
 An object may have certain characteristics which can not be separated from the object. For example, 
 an object may have color, size, mass, velocity, and temperature. These characteristics are 
 not 
 component parts of the object; they can not be separated from the object, nor can they be combined to 
 create new objects. These characteristics are 
 attributes
  of the object. 
  
 The other kind of hierarchy you’ll work with as an object programmer is a 
 classification hierarchy
 . In a 
 classification hierarchy, objects are connected by ""is-a-kind-of"" (or more concisely, ""is-a"" or ""a-k-o"") 
 relationships. These relationships also have different names depending upon our point of view: if A is a 
 kind of B then A is a specialization of B, while B is a generalization of A. 
  
 With the explosion of interest in object programming, many specialized lexicons have grown up to 
 support specific methods and languages. After you eliminate the terms that describe special features 
 of a particular methodology or language implementation, what’s left is usually a renaming of 
 containment and classification hierarchies (and the relationships supported by each) and some way to 
 specify object attributes. In fact, the most common renaming is to refer to a classification hierarchy as 
 a ""class"" hierarchy.
  
 117",NA
Use DEFCLASS to define new objects,"A CLOS object is defined by a 
 DEFCLASS
  form. 
 DEFCLASS
  only 
 describes
  an object. To create an 
 instance of an object, you can use a 
 MAKE-INSTANCE
  form. 
  
 Here’s how you would define a trivial object: 
  
 ? (defclass empty-object () ())
  
 #<STANDARD-CLASS EMPTY-OBJECT>
  
 This class is not very interesting; the 
 ()
  are placeholders for things to come. Also, note that this particular 
 Lisp system prints 
 #<STANDARD-CLASS EMPTY-OBJECT>
  in response to the 
 DEFCLASS
  form. This 
 is unreadable -- the reader signals an error whenever it reads a form that begins with 
 #<
  -- but it lets you 
 know that something useful happened. 
  
 Once you’ve defined a class, you can use it to make objects. Most forms that require a class will accept the 
 name of the class, or you can use 
 FIND-CLASS
  to retrieve the actual class, given its name. 
  
 MAKE-INSTANCE
  creates a new object, given a class name or a class: 
  
 ? (make-instance ’empty-object)
  
 #<EMPTY-OBJECT #x3CA1206>
  
 ? (make-instance ’empty-object)
  
 #<EMPTY-OBJECT #x3CA1DFE>
  
 ? (find-class ’empty-object)
  
 #<STANDARD-CLASS EMPTY-OBJECT>
  
 ? (make-instance (find-class ’empty-object))
  
 #<EMPTY-OBJECT #x3CB397E>
  
 Again, the Lisp system responds with an unreadable object. This time, the response includes the storage 
 address of the object. Most Lisp systems have a default printer for CLOS objects that works like this, even 
 though the details may differ slightly. The important thing to note is that 
 MAKE-INSTANCE
  creates a new 
 object each time it is called. 
  
 Even though the object printer shows a different address for each object, you should 
 not
  depend upon 
 the printed representation to identify an object. Lisp systems can (and do) change the address of 
 objects at runtime. The only way to reliably compare the identity of an object is with an identity test 
 such as 
 EQ
  (see Chapter 17 [p 174] ).",NA
"Objects have slots, with more options than structures","Our first 
 DEFCLASS
  form defined an object that wasn’t good for much of anything. Now we’ll see how to 
 expand a class definition so that our objects will have named slots. These serve the same purpose as slots 
 in structures (Chapter 3), they simply store data. The data could be attributes of the object, or contained 
 objects, or references to related objects. 
  
 To define a class for an object with slots, we start with a 
 DEFCLASS
  form and add slot definitions, like 
 this: 
  
 118",NA
Controlling access to a slot helps keep clients honest,"Getting and setting slots with 
 SLOT-VALUE
  forms is slightly cumbersome when compared to the 
 accessors created automatically for slots in a structure. Fortunately, you can specify accessors for each slot 
 when you define a class. 
  
 (defclass 3d-point ()
  
  
  ((x :accessor point-x)
  
  
  (y :accessor point-y)
  
  
  (z :accessor point-z)))
  
 Then, object slot access looks just like structure slot access. 
  
 ? (let ((a-point (make-instance ’3d-point)))
  
  
  (setf (point-x a-point) 0)
  
  
  (point-x a-point)) 
  
 0
  
 You can also specify separate accessor names for reading and writing a slot. 
  
 ? (defclass 3d-point ()
  
  
  ((x :reader get-x :writer set-x)
  
  
  (y :reader get-y :writer set-y)
  
  
  (z :reader get-z :writer set-z))) 
  
 #<STANDARD-CLASS 3D-POINT> 
  
 ? (let ((a-point (make-instance ’3d-point)))
  
  
  (set-z 3 a-point)
  
  
  (get-z a-point)) 
  
 3
  
 119",NA
Override a slot accessor to do things that the client can’t,"In this section we’ll see how to define special-purpose accessors that do more than just read and write slot 
 values. Think of this as a sneak preview of Chapter 14 [p 157] . 
  
 Let’s define a sphere. A sphere is defined by its position in 3-space and by its radius. We’d like to query 
 the sphere for its volume. Finally, we’d like to be able to move -- or translate -- the sphere’s position by a 
 specified amount without having to explicitly calculate its new coordinates. We start with this class 
 definition: 
  
 ? (defclass sphere ()
  
  
  (x :accessor x)
  
  
  (y :accessor y)
  
  
  (z :accessor z)
  
  
  (radius :accessor radius)
  
  
  (volume :reader volume)
  
  
  (translate :writer translate)) 
  
 #<STANDARD-CLASS SPHERE>
  
 The accessors for 
 X
 , 
 Y
 , 
 Z
 , and 
 RADIUS
  need no further explanation, but the accessors for 
 VOLUME
  and 
 TRANSLATE
  aren’t yet useful; the 
 VOLUME
  reader will fail because its slot is unbound and the 
 TRANSLATE
  writer won’t do anything except to set its slot. 
  
 We’ll finish the definition of our sphere by first having 
 VOLUME
  return a value calculated from the sphere’s 
 radius. There are two ways to do this: have 
 VOLUME
  read the sphere’s radius and calculate the 
 corresponding volume, or have 
 RADIUS
  calculate the volume and set the volume slot for later use by the 
 VOLUME
  accessor. Here are both solutions -- if you try this out, pick just one: 
  
 120",NA
Define classes with single inheritance for specialization,"Specialization is one of the most important concepts in object programming. Specialization allows you to 
 define an object in terms of another object by describing features that are new or different; the base 
 functionality of the object is 
 inherited
  from the definition of the parent. 
  
 In the simplest kind of specialization, single inheritance, a child inherits traits from just one parent. As an 
 example, we’ll define some basic two dimensional objects using a single inheritance hierarchy. 
  
 (defclass 2d-object () ())
  
 (defclass 2d-centered-object (2d-object)
  
  (x :accessor x)
  
  (y :accessor y)
  
 121",NA
Multiple inheritance allows mix-and-match definition,"CLOS supports multiple inheritance, which lets a class inherit traits from more than one parent. This is 
 useful for a programming style that starts with common functionality and then ""mixes in"" extensions to the 
 basic behavior. 
  
 As an example, let’s suppose that we’d like to write code to render the 2D objects we started to define in 
 the previous section. Let’s say that we’d like to achieve two goals simultaneously: we’d like to render 
 images on either a bitmapped or a Postscript display device, and we’d like to render the objects either on a 
 plane surface or as a projection in a ""2.5D"" space, where each 2D object has a Z depth, and the system 
 provides a choice of view positions. These requirements are not at all interdependent; one deals with the 
 details of rendering objects on a display device, while the other deals with transformations of the objects 
 that must occur prior to rendering. 
  
 One way to address these requirements is by using multiple inheritance. One set of of mixins handles 
 transforms, while another set of mixins handles the details of rendering to a display device. With a 
 carefully designed protocol for sharing information, new combinations of transforms and renderers can be 
 added to our 2D objects without rewriting any existing code. 
  
 We saw in the previous section how single inheritance is written using 
 DEFCLASS
 , by putting the parent’s 
 class name within the first parentheses following the new class name. Classes that inherit from multiple 
 parents simply list all of the parents. Thus to define all the combinations of transform and rendering for 
 our 
 REGULAR-POLYGON
  class, we could do something like this: 
  
 122",NA
Options control initialization and provide documentation,"By default, an object’s slots are unbound in a new object. In many cases it would be more useful to give 
 slots some meaningful initial value. For example, our 
 3D-POINT
  could be initialized to the origin. 
  
 (defclass 3d-point ()
  
  ((x :accessor point-x :initform 0)
  
  (y :accessor point-y :initform 0)
  
  (z :accessor point-z :initform 0)))
  
 The 
 :INITFORM
  slot option provides a value for the slot at the time the object is created. The initialization 
 form is evaluated every time it is used to initialize a slot. 
  
 You might also want to provide specific initialization arguments when an object is created. To do this, use 
 the 
 :INITARG
  slot option. 
  
 (defclass 3d-point ()
  
  ((x :accessor point-x :initform 0 :initarg :x)
  
  (y :accessor point-y :initform 0 :initarg :y)
  
  (z :accessor point-z :initform 0 :initarg :z)))
  
 To create a 
 3D-POINT
  object using explicit initializers, you’d do something like this: 
  
 (make-instance ’3d-point :x 32 :y 17 :z -5)
  
 Because the class definition includes both 
 :INITFORM
  and 
 :INITARG
  options, the slot will still get its 
 default value if you omit an explicit initializer. 
  
 Slot definitions also allow 
 :DOCUMENTATION
  and 
 :TYPE
  options. 
  
 124",NA
This is only the beginning...,"In Chapter 14 [p 157] we’ll examine methods in greater depth and see how to associate behaviors with 
 objects. 
  
 125",NA
Chapter 8 - Lifetime and Visibility,"In this chapter we’ll see how lifetime and visibility affect the values of Lisp variables during execution. 
 This is pretty much like local and global variables in other languages, but Lisp’s special variables change 
 things. This chapter also sets the stage for understanding that lifetime and visibility aren’t just for 
 variables.",NA
Everything in Lisp has both lifetime and visibility,"Every object in Lisp has both lifetime and visibility. We’ll see why this is important in the following 
 sections.",NA
"Lifetime: Creation, existence, then destruction","An object’s lifetime is the period between its creation and destruction. Some objects have fleeting 
 lifetimes, limited to the form in which they appear. Other objects are created as soon as the program 
 begins running, and are not destroyed until the program finishes. And others enter and leave existence 
 according to still other rules.",NA
Visibility: To see and to be seen by,"An object is either visible or not visible at a particular point in your program. Sometimes visibility is 
 controlled by the execution path of the program. But for most objects in Common Lisp, visibility is 
 determined by the textual arrangement of your program; this is good, because you can reason about 
 visibility just by reading a program, without having to first reason about the program’s control flow.",NA
The technical names: Extent and Scope,"When you read language specifications for Common Lisp, you’ll see the technical terms extent and scope 
 used in place of lifetime and visibility. I wanted to introduce these concepts first using the non-technical 
 terms because I believe them to be more evocative. But you should get used to reading about extent and 
 scope. Remember: 
  
 lifetime
  is to 
 extent 
  
 as 
  
 visibility
  is to 
 scope",NA
Really easy cases: top-level defining forms,"Top-level defining forms are easy. The objects so defined have 
 indefinite
  extent and scope. This is a fancy 
 way of saying that objects defined by top level forms ""always"" exist and are visible (or at least potentially 
 accessible, as I’ll explain shortly) everywhere in the program. 
  
 126",NA
Scope and extent of parameters and LET variables,"Objects bound by function parameters and 
 LET
  forms have lexical scope. Their bindings are visible 
 beginning at a certain textual location in the defining form and continuing through the textual end of the 
 defining form. Any reference to a textually identical name from outside of the defining form must refer to 
 a different binding. A nested defining form may declare a binding that shadows an enclosing binding to a 
 textually identical name. 
  
 This is a slightly more rigorous restatement of concepts introduced in Chapter 3, Lesson 6. If you 
 need to refresh your memory, this would be a good time to go back and review the examples in that 
 short passage.",NA
Slightly trickier: special variables,"Special variables (also known by the more technically correct term 
 dynamic variables
 ) have 
 dynamic 
 scope. This means that a binding is created for a special variable as a result of executing some form in 
 your program. The scope of the dynamic binding extends into any form called (directly or indirectly) by 
 the form which established the dynamic binding. 
  
 The extent of a special variable lasts indefinitely, until the form that created the dynamic binding is no 
 longer a site of active program execution -- in other words, until the defining form (and all of the forms 
 called by it) finishes executing. If the dynamic binding is created by a top level form, the extent is the 
 same as described previously for top level defining forms. 
  
 127",NA
Chapter 9 - Introducing Error Handling and ,NA,NA
Non-Local Exits,In this chapter we’ll see some of the specialized control flow forms provided by Common Lisp.,NA
"UNWIND-PROTECT: When it absolutely, positively has to ",NA,NA
run,"One of the challenges of writing robust programs is to make sure that important parts of your code always 
 run, even in the presence of errors. Usually, this is most important when you’re allocating, using and 
 releasing resources such as files and memory, like this: 
  
 ; Setup 
  
 Allocate some resources 
  
 Open some files 
  
 ; Process 
  
 Process using files and storage (may fail) 
  
 ; Cleanup 
  
 Close the files 
  
 Release the resources
  
 If the processing step might fail (or be interrupted by the user) you should make sure that every possible 
 exit path still goes through the cleanup section to close the files and release the storage. Better still, your 
 program should be prepared to handle errors that occur during the setup phase as you allocate storage and 
 open files, since any of these operations might also fail; any partially completed setup should still be 
 undone in the cleanup section. 
  
 Lisp’s 
 UNWIND-PROTECT
  form makes this especially easy to do. 
  
 (let (resource stream)
  
  
  (unwind-protect
  
   
  (progn
  
    
  (setq resource (allocate-resource)
  
     
  stream (open-file))
  
    
  (process stream resource))
  
   
  (when stream (close stream))
  
   
  (when resource (deallocate resource))))
  
 Here’s what happens. The 
 LET
  binds 
 RESOURCE
  and 
 STREAM
  to 
 NIL
  -- we’ll use the 
 NIL
  value to mean 
 that there has been no resource allocated or file opened. The first form in the 
 UNWIND-PROTECT
  is a 
 ""protected"" form; if control leaves the protected form via 
 any
  means, then the rest of the forms -- the 
 ""cleanup"" forms -- are guaranteed to be executed. 
  
 In our example, the protected form is a 
 PROGN
  that calls 
 ALLOCATE-RESOURCE
  and 
 OPEN-FILE
  to set 
 our local variables, then 
 PROCESS
  uses these resources. 
 SETQ
  assigns values sequentially to our local 
 variables: 
 (ALLOCATE-RESOURCE)
  must succeed before a value can be assigned to 
 RESOURCE
 , then 
 OPEN-FILE
  must succeed before its value can be assigned to 
 STREAM
 . A failure (i.e. an interrupt or 
 error) at any point in this sequence will transfer control out of the protected form. 
  
 129",NA
Gracious exits with BLOCK and RETURN-FROM,"The 
 BLOCK
  and 
 RETURN-FROM
  forms give you a structured lexical exit from any nested computation. 
 The 
 BLOCK
  form has a name followed a body composed of zero or more forms. The 
 RETURN-FROM 
 form expects a block name and an optional (the default is 
 NIL
 ) return value. 
  
 ? (defun block-demo (flag)
  
  
  (print ’before-outer)
  
  
  (block outer
  
  
  
  (print ’before-inner)
  
  
  
  (print (block inner
  
  
   
  (if flag
  
  
   
  
  (return-from outer 7)
  
  
   
  
  (return-from inner 3))
  
  
   
  (print ’never-print-this)))
  
  
  
  (print ’after-inner)
  
  
  
  t)) 
  
 BLOCK-DEMO 
  
 ? (block-demo t)
  
 BEFORE-OUTER 
  
 BEFORE-INNER 
  
 7 
  
 ? (block-demo nil)
  
 BEFORE-OUTER 
  
 BEFORE-INNER 
  
 3 
  
 AFTER-INNER 
  
 T
  
 When we call 
 BLOCK-DEMO
  with 
 T
 , the 
 IF
  statement’s consequent -- 
 (return-from outer 7)
  --
 immediately returns the value 7 from the 
 (BLOCK OUTER ...
  form. Calling 
 BLOCK-DEMO
  with 
 NIL 
 executes the alternate branch of the 
 IF
  -- 
 (return-from inner 3)
  -- passing the value 3 to the 
 PRINT
  form wrapped around the 
 (BLOCK INNER ...
  form. 
  
 Block names have lexical scope: 
 RETURN-FROM
  transfers control to the 
 innermostBLOCK
  with a 
 matching name. 
  
 Some forms implicitly create a block around their body forms. When a name is associated with the form, 
 such as with 
 DEFUN
 , the block takes the same name. 
  
 130",NA
Escape from anywhere (but not at any time) with CATCH ,NA,NA
and THROW,"So 
 BLOCK
  and 
 RETURN-FROM
  are handy for tranferring control out of nested forms, but they’re only 
 useful when the exit points (i.e. block names) are lexically visible. But what do you do if you want to 
 break out of a chain of function calls? 
  
 ; WARNING! This won’t work! 
  
 (defun bad-fn-a ()
  
  
  (bad-fn-b))
  
 (defun bad-fn-b ()
  
  
  (bad-fn-c))
  
 (defun bad-fn-c ()
  
  
  (return-from bad-fn-a))  
 ; There is no block BAD-FN-A visible here!",NA
Making sure files only stay open as long as needed,"Opening a file just long enough to process its data is a very common operation. We saw above that 
 UNWIND-PROTECT
  can be used to ensure that the file gets properly closed. As you might expect, such a 
 common operation has its own form in Lisp. 
  
 (with-open-file (stream ""file.ext"" :direction :input) 
 (do-something-with-stream stream))
  
 WITH-OPEN-FILE
  wraps an 
 OPEN
  and 
 CLOSE
  form around the code you provide, and makes sure that 
 the 
 CLOSE
  gets called at the right time. All of the options available to 
 OPEN
  may be used in 
 WITH-OPEN-
 FILE
  -- I’ve shown the options you’d use to open a file for input. 
  
 132",NA
"Chapter 10 - How to Find Your Way Around, Part 1","In this chapter, you’ll learn how to find your way around Common Lisp without resorting so often to the 
 manuals. (You 
 do
  read the fine manuals, don’t you?) 
  
 Oh, there’s one thing you should keep in mind while you’re reading this chapter: all of these tools work 
 equally well for the built-in functionality of your Lisp system and for all of the Lisp programs that you 
 write.",NA
"APROPOS: I don’t remember the name, but I recognize ",NA,NA
the face,"Common Lisp defines 978 symbols. Whatever implementation you use probably defines hundreds of 
 additional symbols for language extensions, additional libraries, a graphical user interface, etc. Are you 
 going to remember the names of all these symbols? Not likely... 
  
 What you 
 can
  do is to remember part of the name. This is pretty easy, because the language and library 
 designers have a limited memory (just like you and me) and they tend to name related objects with similar 
 names. So, most of the mapping functions (see Chapter 12 [p 144] ) will have 
 MAP
  in their names, the GUI 
 library will probably have 
 WINDOW
  in the names of all the functions, macros, and variables having 
 something to do with windows, and so on. 
  
 Once you have a good guess at a part of a name, you can find 
 all
  of the matching names by using a very 
 handy tool named 
 APROPOS
 . 
  
 ? (apropos ""MAP"" :cl) 
  
 MAP, Def: FUNCTION 
  
 MAP-INTO, Def: FUNCTION 
  
 MAPC, Def: FUNCTION 
  
 MAPCAN, Def: FUNCTION 
  
 MAPCAR, Def: FUNCTION 
  
 MAPCON, Def: FUNCTION 
  
 MAPHASH, Def: FUNCTION 
  
 MAPL, Def: FUNCTION 
  
 MAPLIST, Def: FUNCTION
  
 APROPOS
  expects a string or a symbol -- this provides the fragment of the name that you’d like to find. 
 An optional second argument designates a package; use it if you’d like to limit your search to the symbols 
 in a particular package. The package designator can be a string or symbol matching the name or nickname 
 of a package (see Chapter 3, Lesson 10), or it can be the package object itself. If you omit the package 
 designator, then 
 APROPOS
  will search for symbols in 
 all
  packages. 
  
 Your Lisp implementation may produce output that looks somewhat different from that shown here. 
 Generally, you’ll see the symbol names listed with a very brief description of the global object named by 
 the symbol. 
  
 133",NA
DESCRIBE: Tell me more about yourself,"Once you know the name of a symbol, you can get additional information by using the 
 DESCRIBE 
 function. As with 
 APROPOS
 , the output of 
 DESCRIBE
  varies among Lisp implementations. Here’s an 
 example generated using my Lisp system: 
  
 ; Describe a symbol 
  
 ? (describe ’length) 
  
 Symbol: LENGTH 
  
 Function 
  
 EXTERNAL in package: #<Package ""COMMON-LISP""> 
 Print name: ""LENGTH"" 
  
 Value: #<Unbound> 
  
 Function: #<Compiled-function LENGTH #x34C39B6>
  
 134",NA
"INSPECT: Open wide and say ""Ah...""","INSPECT
  is like 
 DESCRIBE
 , but instead of printing the information it presents the information in some 
 kind of interactive display; typically either a command loop in the current listener or a new window with 
 its own user interface. You should experiment with 
 INSPECT
  on your own Lisp system to learn how it 
 behaves. 
  
 INSPECT
  is very handy for exploring complex nested data structures, since you can ""drill down"" to just 
 the information that interests you at the moment. Most 
 INSPECT
 s offer specialized viewers for certain 
 types of data, such as functions and CLOS objects. Many implementations of 
 INSPECT
  also allow you to 
 edit the data being inspected.",NA
DOCUMENTATION: I know I wrote that down somewhere,"Sometimes, you need to know more about a variable than you can discover with 
 INSPECT
 . And for 
 functions, you really need the programmer’s description (unless you’re willing to read assembly language 
 code, see Chapter 16 [p 169] if you have these urges). The 
 DOCUMENTATION
  function gives you access 
 to the programmer’s innermost thoughts (or at least what she was willing to write in a documentation 
 string). 
  
 The 
 DOCUMENTATION
  function expects two arguments. The first is an object for which you wish to 
 retrieve documentation, or a symbol naming that object. The second is a symbol designating the kind of 
 documentation (there are several) you wish to retrieve. 
  
 135",NA
Chapter 11 - Destructive Modification,"Assignment is very different from binding, and in many cases results in programs that are harder to 
 understand. Despite this, there are (sometimes) reasons to prefer assignment. In this chapter, we’ll explore 
 assignment and its relationship to destructive modification of data. We’ll also explore several Lisp 
 functions that implement destructive modification.",NA
Simple assignment is destructive modification,"Any time your program invokes 
 SETQ
  or 
 SETF
 , it is assigning a new value to an existing storage location, 
 destroying the value that was previously in that location. As we’ll see in this chapter, there are both risks 
 and benefits to the use of assignment; you need to understand the tradeoffs in order to write Lisp code that 
 is both correct and efficient.",NA
The risk of assignment,"Any time you define a function that uses variables, the variables are either 
 bound
  or 
 free
 . A bound 
 variable occurs within a binding form that occurs within the function definition. A binding form is just a 
 form that creates a new association between the name of a variable and a place to store its value; the most 
 common binding forms are 
 LET
  and the argument list of a 
 DEFUN
  or 
 LAMBDA
 . 
  
 There’s a slight terminology clash in the use of the word 
 bound
 . The clash is always resolved by the 
 context of the word’s use, but you need to be aware of the two meanings. In this chapter we’re talking 
 exclusively about a variable 
 name
  being bound to a place to store its value; when we say that Lisp 
 creates a binding for a variable, we mean that it creates a 
 new
  place to store a value under a given 
 name. 
  
 The other sense of 
 bound
  -- not otherwise discussed in this chapter -- is the binding of a 
 value
  to a 
 storage location; Lisp supports the notion of an unbound -- or nonexistent -- value.
  
 A variable is 
 free
  within a function if the function provides no binding form for the variable’s name. In the 
 following example, the variable 
 E
  is free in both functions 
 CLOSURE-1
  and 
 CLOSURE-2
 . 
  
 ? (let ((e 1))
  
  
  (defun closure-1 () e)) 
  
 CLOSURE-1 
  
 ? (closure-1) 
  
 1 
  
 ? e 
  
 Error: unbound variable
  
 So, what happens when a function has to reference a free variable? Lisp creates a 
 closure
  that captures the 
 bindings of free variables for the function. Variables that are free within a function really do have 
 bindings, but the bindings are outside of the function definition. When Lisp executes the function, it finds 
 free variables in the closure. (We’ll examine closures in greater detail in Chapter 15 [p 165] .) 
  
 137",NA
Changing vs. copying: an issue of efficiency,"If assignment is so fraught with peril, why not just omit it from the language? There are two reasons: 
 expressiveness and efficiency. Assignment is the clearest way to alter shared data. And assignment is more 
 efficient than binding. Binding creates a new storage location, which allocates storage, which consumes 
 additional memory (if the binding never goes out of scope) or taxes the garbage collector (if the binding 
 eventually does go out of scope).",NA
Modifying lists with destructive functions,"Some operations on lists (and sequences -- see Chapter 12 [p 144] ) have both destructive and 
 nondestructive counterparts. 
  
 Nondestructive    Destructive
  
 --------------    -----------
  
 SUBLIS            NSUBLIS 
  
 SUBST             NSUBST 
  
 SUBST-IF          NSUBST-IF 
  
 SUBST-IF-NOT      NSUBST-IF-NOT 
  
 APPEND            NCONC 
  
 REVAPPEND         NRECONC 
  
 BUTLAST           NBUTLAST 
  
 INTERSECTION      NINTERSECTION 
  
 SET-DIFFERENCE    NSET-DIFFERENCE 
  
 SET-EXCLUSIVE-OR  NSET-EXCLUSIVE-OR 
  
 UNION             NUNION
  
 REVERSE           NREVERSE 
  
 REMOVE            DELETE 
  
 REMOVE-IF         DELETE-IF 
  
 REMOVE-IF-NOT     DELETE-IF-NOT 
  
 SUBSTITUTE        NSUBSTITUTE 
  
 SUBSTITUTE-IF     NSUBSTITUTE-IF 
  
 SUBSTITUTE-IF-NOT NSUBSTITUTE-IF-NOT 
  
 REMOVE-DUPLICATES DELETE-DUPLICATES
  
 All of these pairings have the same relationship: the destructive version may be faster, but may also alter 
 shared structure. Consider, for example, 
 APPEND
  and 
 NCONC
 . Both append the lists supplied as their 
 arguments. 
  
 ? (append (list 1 2 3) (list 4 5 6)) 
  
 (1 2 3 4 5 6) 
  
 ? (nconc (list 1 2 3) (list 4 5 6)) 
  
 (1 2 3 4 5 6)
  
 But 
 NCONC
  may destructively modify all but the final list; it may change the tail of each list to point to the 
 head of the next list. 
  
 ? (defparameter list1 (list 1 2 3)) 
  
 LIST1 
  
 ? (defparameter list2 (list 4 5 6)) 
  
 LIST2
  
 140",NA
"RPLACA, RPLACD, SETF ...; circularity","A list is constructed of 
 CONS
  cells. Each CONS has two parts, a 
 CAR
  and a 
 CDR
  (review Chapter 3, 
 Lesson 4). The CAR holds the data for one element of the list, and the CDR holds the CONS that makes 
 up the head of the rest of the list. 
  
  
 By using 
 RPLACA
  and 
 RPLACD
  to change the two fields of a CONS, we can (destructively) alter the 
 normal structure of a list. For example, we could splice out the second element of a list like this: 
  
 ? (defparameter *my-list* (list 1 2 3 4)) 
  
 *MY-LIST* 
  
 ? (rplacd *my-list* (cdr (cdr *my-list*))) 
  
 (1 3 4) 
  
 ? *my-list* 
  
 (1 3 4)
  
 We can also use these ""list surgery operators"" to create circular lists. 
  
 ? (let ((l (list 1)))
  
  
  (rplacd l l)
  
  
  l) 
  
 (1 1 1 1 1 1 1 1 ... 
 ; Continues until interrupt or stack overflow 
 ? (let ((l (list 2)))
  
  
  (rplaca l l)
  
  
  l) 
  
 (((((((((((((((( ... 
 ; Continues until interrupt or stack overflow
  
 141",NA
Places vs. values: destructive functions don’t always ,NA,NA
have the desired side-effect,"A nondestructive function such as 
 REVERSE
  always returns a freshly constructed result, so there’s never 
 any question but that you need to pay attention to the result. But a destructive function such as 
 NREVERSE 
 sometimes
  modifies its argument in such a way that the changed argument is identical to the function 
 result. This leads some programmers to assume that destructive functions 
 always
  modify the argument to 
 match the result. Unfortunately, this is not true; leading to the second important point about the use of 
 destructive functions: you should use the result of a destructive function the same way that you would use 
 the result of its nondestructive counterpart. 
  
 This also applies to 
 SORT
  and 
 STABLE-SORT
 , which are destructive and do not have a 
 nondestructive counterpart.",NA
Contrast e.g. PUSH and DELETE,"Here’s an example showing why you should not depend upon 
 DELETE
 ’s side-effects. 
  
 ? (defparameter *my-list (list 1 2 3 4)) 
  
 *MY-LIST* 
  
 ? (delete 3 *my-list*) 
  
 (1 2 4) 
  
 ? *my-list* 
  
 (1 2 4) 
  
 ? (delete 1 *my-list*) 
  
 (2 4) 
  
 ? *my-list* 
  
 (1 2 4) 
 ; Not the same as function result
  
 But some macros, for example 
 PUSH
  and 
 POP
 , take a 
 place
  as an argument and arrange to update the place 
 with the correct value. 
  
 142",NA
Shared and constant data: Dangers of destructive ,NA,NA
changes,"When you use destructive functions you should be sure to only modify data that your program has 
 constructed at runtime. Here’s an example of what can happen if you destructively modify a constant list. 
  
 ? (defun stomp-a-constant ()
  
  
  (let ((l ’(1 2 3))) 
 ; compile-time constant data
  
  
  (print l)
  
  
  
  (setf (second l) nil) 
 ; destructive modification
  
  
  l)) 
  
 STOMP-A-CONSTANT 
  
 ? (stomp-a-constant) 
  
 (1 2 3) 
  
 (1 NIL 3) 
  
 ? (stomp-a-constant) 
  
 (1 NIL 3) 
  
 (1 NIL 3)
  
 This function is effectively modifying itself, as it changes the constant data which is bound to the variable 
 L
 . The effects of this change show up in the first line of output on the second run (and all subsequent runs). 
  
 If you replace 
 ’(1 2 3)
  (which may be compiled into constant data) with 
 (list 1 2 3)
  (which 
 always creates a fresh list at run time) then the function’s behavior will be identical on the first and all 
 subsequent runs. 
  
 143",NA
Chapter 12 - Mapping Instead of Iteration,"In this chapter we’ll survey of a group of functions collectively known as mapping functions. You can 
 think of a mapping function as a kind of special purpose iterator. Every mapping function expects you to 
 supply a function. A typical mapping function applies your function to every element of the supplied 
 list(s). One variation on this theme applies your function to successive sublists. 
  
 A sequence is a generalization of the list data type. Vectors (one-dimensional arrays) and lists are 
 specializations of the sequence data type. Some mapping functions work only with lists as inputs, while 
 others accept sequences.",NA
"MAPCAR, MAPC, and MAPCAN process successive list ",NA,NA
elements,"The first group of mapping functions processes successive elements of lists. The mapping functions in this 
 group differ in how they construct a return value. 
  
 MAPCAR
  processes successive elements of one or more supplied lists. You must supply a function that 
 accepts as many arguments as the number of lists you supply to 
 MAPCAR
 , which applies your function to 
 successive elements and combines the function’s results into a freshly constructed list. The mapping stops 
 upon reaching the end of the shortest list; 
 MAPCAR
 ’s result has as many elements as the shortest input list. 
  
 MAPC
  does not combine the results of applying your function to successive elements of the input list(s). 
 Instead, it processes the inputs just for effect, and returns the first input list as the result of 
 MAPC
 . 
  
 MAPCAN
  combines results using the destructive function 
 NCONC
 . Since 
 NCONC
  -- like its nondestructive 
 counterpart 
 APPEND
  -- expects its arguments to be lists, the function you supply to 
 MAPCAN
  must always 
 return a list. 
  
 ? (mapcar #’atom (list 1 ’(2) ""foo"" nil)) 
  
 (T NIL T T) 
  
 ? (mapcar #’+ (list 1 2 3) (list 4 5 6)) 
  
 (5 7 9) 
  
 ? (mapc #’(lambda (x y) (print (* x y))) (list 1 0 2) (list 3 4 5))
  
 3 
  
 0 
  
 10 
  
 (1 0 2) 
  
 ? (mapcan #’list (list 1 2 3) (list 4 5 6)) 
  
 (1 4 2 5 3 6) 
  
 ? (mapcan #’(lambda (a b) (list (cons a b))) (list 1 2 3) (list 4 5 6)) 
 ((1 . 4) (2 . 5) (3 . 6))
  
 144",NA
"MAPLIST, MAPL, and MAPCON process successive ",NA,NA
sublists,"MAPLIST
  processes successive sublists of one or more supplied lists. You must supply a function that 
 accepts as many arguments as the number of lists you supply to 
 MAPLIST
 , which applies your function to 
 successive sublists and combines the function’s results into a freshly constructed list. The mapping stops 
 upon reaching the end of the shortest list; 
 MAPLIST
 ’s result has as many elements as the shortest input 
 list. 
  
 MAPL
  does not combine the results of applying your function to successive sublists of the input list(s). 
 Instead, it processes the inputs just for effect, and returns the first input list as the result of 
 MAPL
 . 
  
 MAPCON
  combines results using the destructive function 
 NCONC
 . Since 
 NCONC
  -- like its nondestructive 
 counterpart 
 APPEND
  -- expects its arguments to be lists, the function you supply to 
 MAPCON
  must always 
 return a list. 
  
 ? (maplist #’list (list 1 2 3) (list 4 5 6)) 
  
 (((1 2 3) (4 5 6)) ((2 3) (5 6)) ((3) (6))) 
  
 ? (mapl #’(lambda (x y) (print (append x y))) (list 1 0 2) (list 3 4 5))
  
 (1 0 2 3 4 5) 
  
 (0 2 4 5) 
  
 (2 5) 
  
 (1 0 2) 
  
 ? (mapcon #’list (list 1 2 3) (list 4 5 6)) 
  
 ((1 2 3) (4 5 6) (2 3) (5 6) (3) (6))",NA
"MAP and MAP-INTO work on sequences, not just lists","A sequence is either a list or a vector (a one-dimensional array). The previous group of mapping functions 
 (
 MAPCAR
  et al) processes successive CARs or CDRs of their input lists. 
 MAP
  and 
 MAP-INTO
  process 
 successive elements of their input sequences. 
  
 MAP
  requires that you specify the type of its result using one of the following designators: 
  
 Designator   Result
  
 ----------   ------
  
 NIL          NIL
  
 ’LIST        a list
  
 ’VECTOR      a vector
  
 Note that you can also specify subtypes of 
 LIST
  or 
 VECTOR
  -- your Lisp implementation may be able to 
 optimize the storage of the result based on the type you specify. 
  
 145",NA
Mapping functions are good for filtering,"A filter passes some of its inputs through to its output, and drops others. We can use mapping functions to 
 implement filters by taking note of the behavior of 
 APPEND
 : 
  
 ? (append ’(1) nil ’(3) ’(4)) 
  
 (1 3 4)
  
 146",NA
It’s better to avoid mapping if you care about efficiency,"Most Lisp systems will generate more efficient code to call a function that is known during compilation 
 than a function that can change at run time. Mapping functions accept a functional argument, and most 
 compilers will generate code that supports run time function binding -- even if you specify a ""constant"" 
 function, such as 
 #’+
 . Also, the run time call may incur extra overhead to generate a list of arguments for 
 the function’s application. 
  
 Therefore, if you are concerned about efficiency you should write map-like functions using iteration 
 instead of mapping functions. But do this only when you are sure that efficiency is an issue for the portion 
 of the program you intend to rewrite. See Chapter 28 [p 230] for a discussion of profiling, which can help 
 you find your program’s performance bottlenecks. 
  
 147",NA
Predicate mapping functions test sequences,"Sometimes you may need to apply a test to some input sequences and return a truth value based upon what 
 the test returned for all of the inputs. For example, you might want to know whether any number in a 
 sequence is outside of a specified range, or whether every word is at least five letters long. You could 
 construct these tests from the mapping functions described above, but that would be more verbose (and 
 less efficient) than using the predicate mapping functions provided by Lisp.",NA
"SOME, EVERY, NOTANY, NOTEVERY","The built in predicate mapping functions expect you to supply a test function (a.k.a. predicate) and one or 
 more input sequences. The predicate is applied to successive elements of the input sequences until the the 
 result of the mapping function can be determined. 
  
 Function   Condition
  
 --------   ---------
  
 SOME       user-supplied predicate succeeds on at least one input 
 EVERY      user-supplied predicate succeeds on every input 
  
 NOTANY     complement of SOME 
  
 NOTEVERY   complement of EVERY
  
 For example, 
 SOME
  examines inputs so long as the predicate is false; the tests stop -- and 
 SOME
  returns a 
 true value -- as soon as the predicate is true for some input(s). If the predicate is false for every input, 
 SOME
  
 returns a false value. 
  
 Similarly, 
 EVERY
  examines inputs so long as the predicate is true; the tests stop -- and 
 EVERY
  returns a 
 false value -- as soon as the predicate is false for some input(s). If the predicate is true for every input, 
 EVERY
  returns a true value. 
  
 ? (some #’(lambda (n) (or (< n 0) (> n 100))) (list 0 1 99 100)) 
  
 NIL 
  
 ? (some #’(lambda (n) (or (< n 0) (> n 100))) (list -1 0 1 99 100)) T 
  
 ? (every #’(lambda (w) (>= (length w) 5)) (list ""bears"" ""bulls"" ""racoon"")) 
 T 
  
 ? (every #’(lambda (w) (>= (length w) 5)) (list ""bears"" ""cat"" ""racoon"")) 
 NIL
  
 And of course, the predicate mapping functions handle multiple sequences as you’d expect. 
  
 ? (some #’> (list 0 1 2 3 4 5) (list 0 0 3 2 6)) 
 T",NA
REDUCE combines sequence elements,"While we’re on the subject of mapping, wouldn’t it be nice to be able to combine all of the elements of a 
 sequence using some function? 
 REDUCE
  does just that, accepting a function (of two or zero arguments) 
 and a sequence. If the sequence is longer than one element, 
 REDUCE
  combines the results of applying the 
 function to successive elements of the sequence. For example: 
  
 148",NA
Chapter 13 - Still More Things You Can Do with ,NA,NA
Sequences,"In this chapter we’ll meet the most useful sequence functions, and see how to use them. We’ll also reprise 
 earlier admonitions about proper use of destructive functions.",NA
CONCATENATE: new sequences from old,"CONCATENATE
  always creates a new sequence from (of course) the concatenation of zero or more 
 argument sequences. You must specify the type of the result, and the argument types must be proper 
 subtypes of the sequence type. 
  
 ? (concatenate ’list) 
 ; no argument sequences 
  
 NIL 
  
 ? (concatenate ’vector) 
 ; no argument sequences 
  
 #() 
  
 ? (concatenate ’list ’(1 2 3) (4 5)) 
  
 (1 2 3 4 5) 
  
 ? (concatenate ’vector #(1 2 3) #(4 5)) 
  
 #(1 2 3 4 5) 
  
 ? (concatenate ’list #(1 2 4) ’(4 5)) 
  
 (1 2 3 4 5) 
  
 ? (concatenate ’vector ’(1 2 3) #(4 5)) 
  
 #(1 2 3 4 5) 
  
 ? (concatenate ’list ""hello"") 
 ; string is a subtype of sequence 
 (#\h #\e #\l #\l #\o)",NA
ELT and SUBSEQ get what you want from any sequence ,NA,NA
"(also, COPY-SEQ)","If you need to pick out one element (or a range of elements) from a sequence, you can use 
 ELT
  (to pick 
 out one element) or 
 SUBSEQ
  (to pick out a range of elements). But don’t use these unless you’re really 
 sure you can’t narrow down the sequence type to a vector or list; there are more specific (hence more 
 efficient) accessors for the less general types. 
  
 SUBSEQ
  makes a copy of a specified portion of a sequence. 
 COPY-SEQ
  is closely related to 
 SUBSEQ
 , 
 except that it copies 
 all
  of the elements of a sequence. 
  
 ? (elt ’(1 2 3 4 5) 1) 
 ; zero-based indexing 
  
 2 
  
 ? (subseq ’(1 2 3 4 5) 2) 
 ; 3rd element through end 
  
 (3 4 5) 
  
 ? (let ((l ’(1 2 3 4 5)))
  
  
  (subseq l 2 (length l))) 
 ; same effect as previous 
  
 ? (subseq ’(1 2 3 4 5) 0 3) 
 ; element at ending index is not copied 
 (1 2 3)
  
 150",NA
"REVERSE turns a sequence end-for-end (also, ",NA,NA
NREVERSE),"REVERSE
  makes a copy of a sequence, with the order of elements reversed. 
 NREVERSE
  is the destructive 
 counterpart of 
 REVERSE
 ; it is more efficient, but it modifies its input argument. 
  
 REVERSE
  is commonly used in code similar to the following. 
  
 (defun collect-even-numbers (number-list)
  
  
  (let ((result ()))
  
   
  (dolist (number number-list)
  
    
  (when (evenp number)
  
     
  (push number result)))
  
   
  (nreverse result)))
  
 The 
 DOLIST
  and 
 PUSH
  collect even numbers on the result list, but they are in the reverse order of their 
 original positions on the input list. The final 
 NREVERSE
  puts them back into their original order. This is a 
 safe use of the destructive function 
 NREVERSE
  because the 
 RESULT
  variable can not be shared; it is 
 forgotten as soon as control leaves the 
 LET
  form.",NA
LENGTH: size counts after all,"There’s not much to say about 
 LENGTH
 . Just remember that for lists, 
 LENGTH
  counts only the elements of 
 the top-level list, and not those of any nested lists. 
  
 ? (length ’((1 2 3) (4 5) (6) 7 () 8 9)) 
  
 7",NA
COUNT: when it’s what’s inside that matters,"If you find your program filters a sequence only to get the length of the result, use 
 COUNT
  (and related 
 functions 
 COUNT-IF
  and 
 COUNT-IF-NOT
 ) instead. 
  
 ? (count 3 ’(1 3 3 4 2 5 9 8 3 1 9)) 
 ; count occurrences 
  
 3 
  
 ? (count-if #’oddp ’(1 3 3 4 2 5 9 8 3 1 9)) 
 ; count matches to predicate 
  
 8 
  
 ? (count-if-not #’evenp ’(1 3 3 4 2 5 9 8 3 1 9)) 
 ; count mismatches using predicate 
 8
  
 These functions accept keyword arguments: 
  
 151",NA
"REMOVE, SUBSTITUTE, and other sequence changers","REMOVE
  removes all occurrences of a specified element from a sequence. 
  
 ? (remove 7 ’(1 2 3 a b c t nil 7 0 7 7)) 
  
 (1 2 3 A B C T NIL 0)
  
 Keyword arguments are handled in the same way as for 
 COUNT
 . 
 REMOVE-IF
  and 
 REMOVE-IF-NOT
  are 
 also available; their keyword arguments are handled in the same way as for 
 COUNT-IF
  and 
 COUNT-IF-
 NOT
 . 
  
 A 
 :COUNT
  keyword argument lets you limit the number of matching elements to remove. 
  
 SUBSTITUTE
  changes all occurrences of a specified element in a sequence to another value. 
  
 ? (substitute ’(q) 7 ’(1 2 3 a b c t nil 7 0 7 7)) 
 (1 2 3 A B C T NIL (Q) 0 (Q) (Q))
  
 152",NA
"DELETE, REMOVE-DUPLICATES, DELETE-DUPLICATES, ",NA,NA
and NSUBSTITUTE.,"Many of the functions in the preceeding section have destructive counterparts. The result of the destructive 
 functions is identical, but the input sequence may be destructively modified. 
  
 Nondestructive    Destructive
  
 --------------    -----------
  
 REMOVE            DELETE 
  
 REMOVE-IF         DELETE-IF 
  
 REMOVE-IF-NOT     DELETE-IF-NOT 
  
 SUBSTITUTE        NSUBSTITUTE 
  
 SUBSTITUTE-IF     NSUBSTITUTE-IF 
  
 SUBSTITUTE-IF-NOT NSUBSTITUTE-IF-NOT 
  
 REMOVE-DUPLICATES DELETE-DUPLICATES
  
 Remember that you 
 must not
  depend upon the modification of the input sequences. The only result 
 guaranteed to be correct is the return value of the function.",NA
FILL and REPLACE,"FILL
  destructively modifies a sequence, replacing every element with a new value. It accepts keyword 
 arguments for 
 :START
  and 
 :END
  positions; these have the same meaning as described earlier in this 
 chapter. The modified sequence is returned as the value of 
 FILL
 . 
  
 ? (fill (list 1 1 2 3 5 8) 7) 
  
 (7 7 7 7 7 7) 
  
 ? (fill (list 1 1 2 3 5 8) ’(a b)) 
  
 ((A B) (A B) (A B) (A B) (A B) (A B)) 
  
 ? (fill (list 1 1 2 3 5 8) 7 :start 2 :end 4) 
  
 (1 1 7 7 5 8)
  
 153",NA
"Locating things in sequences: POSITION, FIND, SEARCH, ",NA,NA
and MISMATCH,"POSITION
  searches a sequence for a matching element, and returns the index of the first match or 
 NIL
  if 
 no matching element is in the sequence. 
  
 ? (position #\a ""This is all about you, isn’t it?"") 
 8 
  
 ? (position #\! ""This is all about you, isn’t it?"") 
 NIL
  
 POSITION
  accepts the same keyword arguments as 
 COUNT
  (described earlier in this chapter) and has (the 
 by now familar) variants 
 POSITION-IF
  and 
 POSITION-IF-NOT
 . 
  
 FIND
  is similar to 
 POSITION
  except that the matching element -- rather than its index in the sequence --is 
 returned if there is a match. As with 
 POSITION
 , you’ll find the usual keyword arguments (
 :FROM-END
 , 
 :START
 , 
 :END
 , 
 :KEY
  -- and for the ""base"" function, 
 :TEST
  and 
 :TEST-NOT
 ) and function variants (i.e. 
 FIND-IF
  and 
 FIND-IF-NOT
 ). 
  
 ? (find #\a ""This is all about you, isn’t it?"") 
 #\a 
  
 ? (find #\! ""This is all about you, isn’t it?"") 
 NIL
  
 154",NA
SORT and MERGE round out the sequence toolkit,"SORT
  destructively sorts a sequence; the order is determined by a predicate which you supply. 
  
 ? (sort (list 9 3 5 4 8 7 1 2 0 6) #’>) 
  
 (9 8 7 6 5 4 3 2 1 0) 
  
 ? (sort (list 9 3 5 4 8 7 1 2 0 6) #’<) 
  
 (0 1 2 3 4 5 6 7 8 9)
  
 The input sequence is destructively modified -- you must use the function result. 
  
 STABLE-SORT
  preserves the original order of identical elements; 
 SORT
  may not. 
  
 You can sort structured elements (e.g. lists, structures) by using the 
 :KEY
  keyword argment to specify a 
 key extraction function. 
  
 MERGE
  combines 
 two
  input sequences into a single result. Elements are interleaved according to the 
 predicate. Either input sequence may be destructively modified. You must designate the type of the result. 
  
 ? (merge ’vector (list 1 3 5 9 8) (vector 2 6 4 7 0) #’>) 
 #(2 6 4 7 1 3 5 9 8 0) 
  
 ? (merge ’list (list 1 3 5 9 8) (vector 2 6 4 7 0) #’<) 
 (1 2 3 5 6 4 7 0 9 8) 
  
 ? (merge ’vector (list 1 3 5 8 9) (vector 0 2 4 6 7) #’>) 
 #(1 3 5 8 9 0 2 4 6 7) 
  
 ? (merge ’list (list 1 3 5 8 9) (vector 0 2 4 6 7) #’<) 
 (0 1 2 3 4 5 6 7 8 9)
  
 155",NA
Chapter 14 - Can Objects Really Behave ,NA,NA
Themselves?,"This chapter continues the treatment of CLOS (the Common Lisp Object System) that we began in Chapter 
 7, in which we saw how objects store data. In this chapter we’ll learn about how objects get their behaviors.",NA
Generic functions give objects their behaviors,"A generic function provides behavior based upon the type of an object. The behavior is selected according 
 to the types of the arguments to the generic function. The generic function dispatches control to a 
 particular method that provides the best match to the argument types that you use to invoke the generic 
 function. 
  
  
 You define a method using Lisp’s 
 DEFMETHOD
  macro. In its simplest form, 
 DEFMETHOD
  expects a name 
 and a 
 specialized
  lambda list. The specialized lambda list is similar to the list of formal parameters you 
 supply for a 
 LAMBDA
  or 
 DEFUN
  form; the difference is that you can specify the type of each parameter. 
 The method will only be invoked when the generic function call (which looks 
 exactly
  like a function call) 
 specifies parameters that are of matching types. To specialize a parameter in a 
 DEFMETHOD
  form, simply 
 name the parameter and its type in a list. For example: 
  
 (defmethod method1 ((param1 number) (param2 string)) ...) 
 (defmethod method2 ((param2 float) (param2 sequence)) ...)
  
 You can also leave the type of a parameter unspecified by just giving its name; this kind of parameter will 
 match 
 any
  data type. In this example, the first parameter is not specialized: 
  
 (defmethod method3 (param1 (param2 vector)) ...)
  
 Note that the parameter types do not 
 have
  to be CLOS class types. If you 
 want
  to specialize a method to 
 one particular CLOS class, you can specialize one of the arguments to that class, as we saw in the first 
 figure in this chapter. If you have specialized one parameter to a CLOS class, and leave the other
  
 157",NA
The line between methods and objects blurs for ,NA,NA
multimethods,"A multimethod is a method that is selected based upon the types of two or more of its arguments. When 
 you have a method that is selected for two or more classes, then we can’t really say that a class (or an 
 object, which is an instance of that class) ""has"" a particular method.",NA
Methods on non-objects? So where does the method ,NA,NA
live?,"The association of methods to classes gets even more tenuous when we consider that one or more of a 
 method’s arguments may specialize on an object that is not a class. If we expect to find some convenient 
 way to say that a method ""belongs to"" a particular class, we’re simply not going to find it. 
  
 Simpler (and less capable) object systems than CLOS 
 do
  associate a method with a particular class. CLOS 
 does not. This is an important point, so let me rephrase it: CLOS methods are 
 not
  a part of any class for 
 which they may provide services. 
  
 A method is a part of a generic function. The generic function analyzes the actual parameters and selects a 
 method to invoke based upon a match between actual parameters and specialized lambda lists in the 
 method definitions. And, to reiterate the point made in the previous paragraph, generic functions are 
 not a 
 part of
  of any classes upon which the generic function’s methods operate.",NA
Generic functions work by dispatching on argument ,NA,NA
specializers,"When you define a method, the types of its parameters (in the specialized lambda list) declare that the 
 method may be invoked only by parameters of the same, or more specific, types. For example, if a 
 parameter is specialized on the type 
 NUMBER
 , it can match 
 INTEGER
 , 
 FIXNUM
 , 
 FLOAT
 , 
 BIGNUM
 , 
 RATIONAL
 , 
 COMPLEX
 , or any other proper subtype of 
 NUMBER
 . 
  
 158",NA
Object inheritance matters after all; finding the applicable ,NA,NA
method,NA,NA
Method combinations offer further choices,"If you define methods as we’ve seen throughout this chapter, the generic function that gets created will 
 offer a capability called 
 standard
  method combination. The methods that we’ve so far used have all been 
 primary
  methods. Under standard method combination, we can also define 
 before
 , 
 after
 , and 
 around 
 methods which get combined with the primary method. 
  
 To define a 
 before
 , 
 after
 , or 
 around
  method we add a corresponding keyword (a 
 method qualifier
 ) to our 
 DEFMETHOD
  form, like this: 
  
 (defmethod 
 madness 
 :before 
 (...) 
 ...) 
  
 (defmethod madness :after  (...) 
 ...) 
  
 (defmethod 
 madness 
 :around 
 (...) 
 ...)
  
 Let’s take a look at standard method combination in action. We’ll begin with the 
 :BEFORE
  and 
 :AFTER 
 methods. 
  
 ; Define a primary method 
  
 ? (defmethod combo1 ((x number)) (print ’primary) 1) 
  
 #<STANDARD-METHOD COMBO1 (NUMBER)> 
  
 ; Define before methods 
  
 ? (defmethod combo1 :before ((x integer)) (print ’before-integer) 2) 
 #<STANDARD-METHOD COMBO1 :BEFORE (INTEGER)> 
  
 ? (defmethod combo1 :before ((x rational)) (print ’before-rational) 3) 
 #<STANDARD-METHOD COMBO1 :BEFORE (RATIONAL)> 
  
 ; Define after methods 
  
 ? (defmethod combo1 :after ((x integer)) (print ’after-integer) 4) 
 #<STANDARD-METHOD COMBO1 :AFTER (INTEGER)> 
  
 ? (defmethod combo1 :after ((x rational)) (print ’after-rational) 5) 
 #<STANDARD-METHOD COMBO1 :AFTER (RATIONAL)>",NA
Nothing is cast in stone; a peek at the metaobject ,NA,NA
protocol,"The metaobject protocol (MOP) is a collection of functions that expose much of the underlying workings 
 of CLOS. We’ve already seen one function that belongs to the MOP: 
 CLASS-PRECEDENCE-LIST
 . 
 Some MOP functions, like 
 CLASS-PRECEDENCE-LIST
 , give you visibility into the inner workings of 
 CLOS. Here are some examples: 
  
 Function                    Argument   Returns
  
 --------                    --------   -------
  
 CLASS-DIRECT-SUBCLASSES     a class    a list of the immediate subclasses 
 CLASS-DIRECT-SUPERCLASSES   a class    a list of the immediate superclasses 
 CLASS-DIRECT-SLOTS          a class    a list of non-inherited slots CLASS-
 DIRECT-METHODS        a class    a list of non-inherited methods
  
 Other MOP functions let you change the underlying behavior of CLOS. You can use this capability to 
 extend CLOS -- perhaps to implement a persistent object store -- or to alter the behavior to more closely 
 correspond to a different kind of object system. Such changes are far beyond the scope of this book. Also, 
 you should be aware that the MOP is 
 not
  (yet, as of early 1999) a standard part of CLOS, and there is no 
 definition of the MOP recognized by any national or international standards body. 
  
 So far, the defining document for the MOP is The Art of the Metaobject Protocol [p 255] . Most Lisp 
 vendors provide at least a partial MOP implementation; you should probably start with the vendor’s 
 documentation if you’re interested in the MOP. 
  
 164",NA
Chapter 15 - Closures,"In this chapter we’ll expand upon the discussion of closures that we started in Chapter 11. We’ll see again 
 how (and why) closures capture free variables for use in other execution contexts, then we’ll see some 
 practical applications. We’ll close this chapter with a look at functions that return functions.",NA
"Is it a function of the lifetime, or the lifetime of a function?","Common Lisp does not expose closures per se. Recall from Chapter 11 that a closure is a collection of 
 closed-over variables retained by a function. (A closed-over variable is a variable found ""free"" in the 
 function; this gets ""captured"" by the closure. We saw some examples of this in Chapter 11; we’ll review 
 the details in the next section, in case you’ve forgotten.) For this reason, Lisp programmers tend to refer to 
 ""a function having closed-over variables"" as simply ""a closure."" Or maybe they call it that because it saves 
 them nine syllables. 
  
 A closure has to be associated with a function, so it must have the same lifetime -- or extent -- as the 
 function. But all of the closed-over variables come along for the ride -- a closed-over variable has the same 
 extent as the closure. This means that you can close over a lexical variable, which would normally have 
 lexical extent, and give that variable indefinite extent. This is a very useful technique, as we’ll see shortly.",NA
"How to spot a free variable, and what to do about it.","A variable is 
 free
  within a function (or within any form, for that matter) if there is no binding occurrence 
 of its name within the lexical scope -- the textual bounds, more or less -- of the function. A binding 
 occurrence is an occurrence of the name that (according to the definition of the form that includes the 
 name) associates storage with the name. 
  
 A free variable must be found in one of two places. Either the function is textually wrapped within a form 
 that provides a binding occurrence of the variable, or the variable is 
 special
  (review Chapter 8) and 
 contained in the global environment. If a free variable is not found in one of these two places, it is 
 unbound
  
 (i.e. has no storage associated with the name) and will cause an error when referenced at runtime.",NA
"Using closures to keep private, secure information.","If you close over a lexical variable, that variable is accessible 
 only
  from within the closure. You can use 
 this to your advantage to store information that is truly private, accessible only to functions that have a 
 closure containing your private variable(s). 
  
 ? (let ((password nil)
  
  
   
  (secret nil))
  
  
  (defun set-password (new-passwd)
  
  
  
  (if password
  
  
   
  ’|Can’t - already set|
  
  
   
  (setq password new-passwd)))
  
  
  (defun change-password (old-passwd new-passwd)
  
  
  (if (eq old-passwd password)
  
  
   
  (setq password new-passwd)
  
 165",NA
"Functions that return functions, and how they differ from ",NA,NA
macros.,"The preceding example is only good for keeping one secret, because every time we evaluate the outer 
 LET 
 form we redefine all of the functions that close over our ""private"" variables. If we want to eliminate our 
 dependence upon the global namespace for functions to manipulate our closed-over variables, we’re going 
 to have to find a way to create new closed-over variables and return a function that we can save and later 
 use to manipulate the variables. Something like this will work: 
  
 ? (defun make-secret-keeper ()
  
  
  (let ((password nil)
  
  
  
  (secret nil))
  
  
  
  #’(lambda (operation &rest arguments)
  
  
  
  (ecase operation
  
  
   
  
  (set-password
  
 166",NA
"Chapter 16 - How to Find Your Way Around, Part 2","It’s once again time to take a break and learn about some more of the tools you can use to grok [1] [p ??] 
 the inner workings of Lisp and your programs. In this chapter, we’ll learn what the Lisp compiler does to 
 your code, and how to watch what your code does as it runs.",NA
DISASSEMBLE: I always wondered what they put inside ,NA,NA
those things...,"If you understand a little about compilers and assembly language -- or if you’re just interminably curious-- 
 you can find out exactly 
 how
  the Lisp compiler translates your Lisp code. 
 DISASSEMBLE
  takes a 
 function name or object and lists the assembly-language instructions that would have been emitted by the 
 Lisp compiler if it actually emitted assembly-language code -- most compilers directly generate machine 
 instructions without invoking an assembler. 
  
 The output of 
 DISASSEMBLE
  is dependent both upon the instruction set architecture of the machine 
 you’re using to run Lisp and upon the Lisp implementation itself. Here’s an example of using 
 DISASSEMBLE
  on a very simple function; this was done using Macintosh Common Lisp on a PowerPC 
 processor. 
  
 ? (defun add1 (n) (1+ n)) 
  
 ADD1 
  
 ? (disassemble ’add1)
  
  
  (TWNEI NARGS 4)
  
  
  (MFLR LOC-PC)
  
  
  (BLA .SPSAVECONTEXTVSP)
  
  
  (VPUSH ARG_Z)
  
  
  (LWZ NARGS 331 RNIL)
  
  
  (TWGTI NARGS 0)
  
  
  (LI ARG_Y ’1)
  
  
  (LWZ ARG_Z 0 VSP)
  
  
  (BLA .SPRESTORECONTEXT)
  
  
  (MTLR LOC-PC)
  
  
  (BA .SPBUILTIN-PLUS)
  
 The first thing you’ll note about this listing is that it looks ""Lisp-ish"" with the parentheses. The second 
 thing you’ll notice -- if you are familiar with the PowerPC instruction set -- is that most of these forms are 
 familiar; it’s as if someone took part of a real PowerPC assembly language program and bracketed each 
 line of text in parentheses. You may also notice that there are no comments in the assembly code, that 
 there are some pseudo-instructions such as 
 VPUSH
 , and that this is not a complete program that you could 
 feed into an assembler (even after you stripped off the parentheses). I’ll explain all of these points. 
  
 Many Lisp systems include an assembler that accepts statements in the form generated by 
 DISASSEMBLE
 . 
 These statements are often named LAP, for Lisp Assembly Program. With the proper documentation, you 
 can write LAP code and have it invoked by your own functions. But you do need the vendor’s 
 documentation for this; you can’t just find the LAP assembler and feed it a list of LAP instructions. You 
 need to know how to use reserved registers, what subroutines to call, what stack protocol to follow, and 
 many other low-level details. You also need to associate the code with a function name so
  
 169",NA
BREAK and backtrace: How did I end up here?,"If you ever need to figure out 
 exactly
  what’s going on at a particular point in your program, you can insert a 
 BREAK
  form at the point of interest; when your program evaluates the 
 BREAK
 , the Lisp system will 
 immediately stop your program (without losing any information), and transfer control to the Lisp debugger. 
 Once in the debugger, you can do things like examine the call stack (sometimes named a backtrace, since 
 the stack frames are a trace of your program’s current call history, backward in time) and look at local 
 variables at any level in the stack. And, of course, you can execute any Lisp code that you like. But wait, 
 there’s more! You can exit the debugger, and your program will continue from where the 
 BREAK
  
 interrupted it. Or you can change the values of some variables before you continue. If you want, you can 
 provide a value to be returned by the interrupted function. You can even redefine and restart functions 
 anywhere in the call stack. 
  
 The fact that 
 BREAK
  is just a Lisp form has its advantages. You can wrap it in a conditional expression of 
 arbitrary complexity, so that your program will trigger the break exactly when it’s needed; this is 
 especially useful in debugging loops or recursive functions. 
  
 171",NA
TRACE and STEP: I’m watching you! ,"When you need to know exactly 
 how
  a function is working at a particular point in your code, 
 BREAK
  and 
 the Lisp debugger are indispensable tools. But they are labor intensive and slow (at least relative to the 
 program’s normal execution) -- nothing happens except when you issue commands to the debugger. 
  
 Sometimes, it’s enough to know that a particular function has been called and returned a value. 
 TRACE 
 gives you this ability. You simply invoke trace with one or more function names, and the Lisp 
 environment arranges to print the name of the function and its arguments upon entry, and the name of the 
 function and its values upon exit. All this happens without changing the source code for the function. 
  
 ? (defun factorial (n)
  
    
  (if (plusp n)
  
      
  (* n (factorial (1- n)))
  
      
  1)) 
  
 FACTORIAL 
  
 ? (factorial 6) 
  
 720 
  
 ? (trace factorial) 
  
 NIL 
  
 ? (factorial 6)
  
  Calling (FACTORIAL 6) 
  
  Calling (FACTORIAL 5) 
  
  
  Calling (FACTORIAL 4) 
  
    
  Calling (FACTORIAL 3) 
  
    
  Calling (FACTORIAL 2) 
  
      
  Calling (FACTORIAL 1) 
  
       
  Calling (FACTORIAL 0) 
  
       
  FACTORIAL returned 1
  
      
  FACTORIAL returned 1
  
    
  FACTORIAL returned 2
  
    
  FACTORIAL returned 6
  
 172",NA
Chapter 17 - Not All Comparisons are Equal,"Up to this point, I’ve shown you various comparison functions without really saying much about the 
 differences between them. In this chapter, I’ll (finally) tell you about how and why the comparison 
 functions differ and offer some guidelines for their proper use.",NA
"The longer the test, the more it tells you","Lisp has a core set of comparison functions that work on virtually any kind of object. These are: 
  
  
 EQ
  
  
 EQL
  
  
 EQUAL
  
  
 EQUALP
  
 The tests with the shorter names support stricter definitions of equality. The tests with the longer 
 implement less restrictive, perhaps more intuitive, definitions of equality. We’ll learn about each of the 
 four definitions in the following sections.",NA
EQ is true for identical symbols,"EQ
  is true for identical symbols. In fact, it’s true for any identical object. In other words, an object is 
 EQ
  to 
 itself. Even a composite object, such as a list, is 
 EQ
  to itself. (But two lists are 
 not
 EQ
  just because they 
 look the same when printed; they must truly be the 
 same
  list to be 
 EQ
 .) Under the covers, 
 EQ
  just 
 compares the memory addresses of objects. 
  
 The reason that symbols are 
 EQ
  when they have the same name (and are in the same package) is that the 
 Lisp reader 
 interns
  symbols as it reads them. The first time the reader sees a symbol, it creates it. On 
 subsequent appearances, the reader simply uses the existing symbol. 
  
 EQ
  is not guaranteed to be true for identical characters or numbers. This is because most Lisp systems 
 don’t assign a unique memory address to a particular number or character; numbers and characters are 
 generally created as needed and stored temporarily in the hardware registers of the processor.",NA
EQL is also true for identical numbers and characters,"EQL
  retains 
 EQ
 ’s notion of equality, and extends it to identical numbers and characters. Numbers must 
 agree in value 
 and
  type; thus 0.0 is 
 not
 EQL
  to 0. Characters must be truly identical; 
 EQL
  is case sensitive.",NA
EQUAL is usually true for things that print the same,"EQ
  and 
 EQL
  are not generally true for lists that print the same. Lists that are not 
 EQ
  but have the same 
 structure will be indistinguishable when printed; they will also be 
 EQUAL
 . 
  
 174",NA
EQUALP ignores number type and character case,"EQUALP
  is the most permissive of the core comparison functions. Everything that is 
 EQUAL
  is also 
 EQUALP
 . But 
 EQUALP
  ignores case distinctions between characters, and applies the (typeless) 
 mathematical concept of equality to numbers; thus 0.0 is 
 EQUALP
  to 0. 
  
 Furthermore, 
 EQUALP
  is true if corresponding elements are 
 EQUALP
  in the following composite data 
 types: 
  
  
  
  
 Arrays 
  
 Structures 
  
 Hash Tables",NA
Longer tests are slower; know what you’re comparing,"The generality of the above longer-named tests comes with a price. They must test the types of their 
 arguments to decide what kind of equality is applicable; this takes time. 
  
 EQ
  is blind to type of an object; either the objects are the same object, or they’re not. This kind of test 
 typically compiles into one or two machine instructions and is very fast. 
  
 You can avoid unnecessary runtime overhead by using the most restrictive (shortest-named) test that meets 
 your needs.",NA
Specialized tests run faster on more restricted data types,"If you know the type of your data in advance, you can use comparisons that are specialized to test that 
 particular type of data. Tests are available for characters, strings, lists, and numbers. And, of course, there 
 are also comparisons for other relationships besides equality. 
  
  
  
 Characters 
  
  
 CHAR=
  
  
 CHAR/=
  
  
 CHAR<
  
  
 CHAR<=
  
  
 CHAR>
  
  
 CHAR>=
  
  
 CHAR-EQUAL
  
  
 CHAR-NOT-EQUAL
  
 Strings 
  
  
 STRING=
  
  
 STRING/=
  
 175",NA
"Chapter 18 - Very Logical, Indeed...","Now it’s time to look at things having to do with boolean (true and false) logic. We’ll learn about common 
 logical functions, and conditional evaluation. If you’re a bit twiddler, this chapter should warm your heart: 
 we’ll introduce bit manipulation functions, bit vectors, and generalized byte manipulation.",NA
AND and OR evaluate only as much as they need,"AND
  and 
 OR
  are macros in Common Lisp. This means that they have control over when (and 
 if
 ) their 
 arguments get evaluated. 
 AND
  and 
 OR
  take advantage of this ability: they stop evaluating their arguments 
 as soon as they determine an answer. 
  
 Consider 
 AND
 : it evaluates its arguments, starting with the leftmost, only as long as each argument 
 evaluates to a true (i.e. not 
 NIL
 ) value. As soon as 
 AND
  evaluates the leftmost false (
 NIL
 ) argument, its 
 work is done -- the result will be 
 NIL
  no matter how many more true arguments it evaluates, so 
 AND
  just 
 returns 
 NIL
  without evaluating any more of its arguments. (Think of this as a ""one strike and you’re out"" 
 policy.) 
 AND
  returns true only if all of its arguments evaluate to a true value. 
  
 In fact, 
 AND
  returns either 
 NIL
  (if one of its arguments evaluates to 
 NIL
 ) or the non-
 NIL
  value of its 
 rightmost argument. Some Lisp programmers take advantage of this to treat 
 AND
  as a simple conditional. 
  
 ? (defun safe-elt (sequence index)
  
  (and (< -1 index (length sequence)) 
 ; guard condition
  
  (values (elt sequence index) t)))
  
 SAFE-ELT
  
 ? (safe-elt #(1 2 3) 3)
  
 NIL
  
 ? (elt #(1 2 3) 3)
  
 Error: index out of bounds
  
 ? (safe-elt #(1 2 3) 2)
  
 3
  
 T
  
 OR
  also evaluates only enough arguments to determine its result: it evaluates arguments, starting with the 
 leftmost, so long as they evaluate to 
 NIL
 . The first non-
 NIL
  result is returned as 
 OR
 ’s value; arguments 
 further to the right are not evaluated. 
  
 One caution is in order about 
 AND
  and 
 OR
 . Because they are macros, and not functions, they can not be 
 used for mapping (see Chapter 12). Use the predicate mapping functions (
 SOME
 , 
 EVERY
 , etc.) instead.",NA
"Bits, bytes, and Boole","Machine languages and low-level programming languages always provide the ability to perform bitwise 
 boolean operations: groups of bits are logically combined on a bit-by-bit basis; adjacent bits have no effect 
 on their neighbors in determining the result. The same languages also let you treat adjacent groupings of 
 bits as a unit; this is commonly called a byte or a bit field. Usually bitwise and bit field operations are 
 constrained by the size of hardware registers. 
  
 177",NA
Bit vectors can go on forever,"A vector composed of only 1s and 0s has a compact representation as a 
 bit vector
 , a special representation 
 for printing and reading, and a set of logical operations. Like all vectors (and arrays) in Common Lisp, the 
 size of a bit vector is limited by the constant 
 ARRAY-TOTAL-SIZE-LIMIT
 ; this can be as small as 
 1,024, but is typically large enough that the size of memory sets a practical limit on the size of bit-vectors. 
  
 The printed representation of a bit vector begins with the 
 #*
  reader macro, followed by 1s and 0s. The bit 
 vector’s length is determined by the 1s and 0s that make up its elements. (The printed representation of an 
 empty bit vector is 
 #*
 .) 
  
 ? #*0010101 
  
 #*0010101 
  
 ? (length #*0010101) 
  
 7
  
 179",NA
Chunks of bits make bytes,"Getting back to integer manipulation as we wrap up this chapter, we’ll see how to manipulate fields of 
 adjacent bits within an integer value. 
  
 The first thing we need when manipulating a field of bits (called a 
 byte
  in Common Lisp) is a way of 
 specifying its bounds. The 
 BYTE
  function constructs a byte specifier from a size (number of bits) and a 
 position (the number of the rightmost bit of the byte within the containing integer, where the LSB is bit 0). 
 The representation of a byte specifier depends upon the Lisp implementation. 
  
 180",NA
Chapter 19 - Streams,"All of the I/O functions in Lisp accept a stream argument. In some cases (e.g. 
 READ
  and 
 PRINT
 ) the 
 stream argument is optional; by default, input comes from the 
 *STANDARD-INPUT*
  stream (normally 
 connected to the keyboard) and output goes to the 
 *STANDARD-OUTPUT*
  stream (normally connected 
 to the display). You can redirect I/O by either providing optional stream arguments to 
 READ
  and 
 PRINT 
 (as well as other I/O functions), or by binding 
 *STANDARD-INPUT*
  and 
 *STANDARD-OUTPUT*
  to 
 different streams. (We’ll see both of these approaches used in the following examples.)",NA
Streams provide a pipe to supply or accept data,"Throughout the preceding chapters of this book, streams have been involved whenever we’ve seen an 
 example that does input or output -- and 
 all
  of the examples do I/O, if you count our interactions with the 
 listener. A Lisp stream can provide (source) or consume (sink) a sequence of bytes or characters.
  
 (Remember the Lisp definition of byte: a byte can contain any number of bits.) 
  
 Some I/O functions accept 
 T
  or 
 NIL
  as a stream designator. 
 T
  is a synonym for 
 *TERMINAL-IO*
 , a 
 bidirectional (input 
 and
  output) stream which conventionally reads from 
 *STANDARD-INPUT*
  and 
 writes to 
 *STANDARD-OUTPUT*
 . 
 NIL
  is a synonym for 
 *STANDARD-INPUT*
  when used in a context 
 which expects an input stream, or for 
 *STANDARD-OUTPUT*
  when used in a context which expects an 
 output stream. 
  
 FORMAT
  (which we’ve already seen in several examples, and will examine in depth in Chapter 24 [p 
 215] ) expects as its first argument a stream, a 
 T
 , a 
 NIL
 , or a string with a fill pointer. In this case, 
 however, the 
 NIL
  designator causes 
 FORMAT
  to return a string, rather than write to 
 *STANDARD-
 OUTPUT*
  as is the case for other I/O functions.
  
 The power of streams comes from the ability to associate a stream with a file, a device (such as keyboard, 
 display, or network), or a memory buffer. Program I/O can be directed at will by simply creating the 
 appropriate type of stream for your program to use. The I/O implementation is abstracted away by the 
 stream so your program won’t have to be concerned with low-level details. 
  
 Lisp also provides a number of special-purpose streams which serve to combine or manipulate other 
 streams in novel ways. A 
 TWO-WAY-STREAM
  combines a separate input stream and output stream into an 
 I/O stream. A 
 BROADCAST-STREAM
  sends output to zero or more output streams; think of this as a bit-
 bucket when used with zero streams, and a broadcaster when used with multiple streams. A 
 CONCATENATED-STREAM
  accepts input requests on behalf of zero or more input streams; when one 
 stream’s input is exhausted, the 
 CONCATENATED-STREAM
  begins reading from its next input stream. An 
 ECHO-STREAM
  is like a 
 TWO-WAY-STREAM
 , with the added feature that anything your program reads 
 from the 
 TWO-WAY-STREAM
 ’s input stream automatically gets echoed to the corresponding output stream. 
 Finally, a 
 SYNONYM-STREAM
  is an alias for another stream; the alias can be changed at runtime without 
 creating a new 
 SYNONYM-STREAM
 . 
  
 Quite a few I/O functions operate directly on streams: 
  
 183",NA
Creating streams on files,"The 
 OPEN
  function creates a 
 FILE-STREAM
 . Keyword arguments determine attributes of the stream 
 (
 :DIRECTION
 , 
 :ELEMENT-TYPE
 , and 
 :EXTERNAL-FORMAT
 ) and how to handle exceptional 
 conditions (
 :IF-EXISTS
  and 
 :IF-DOES-NOT-EXIST
 ). If 
 OPEN
  is successful it returns a stream, 
 otherwise it returns 
 NIL
  or signals an error. 
  
 Keyword      Value     Stream Direction
  
 ----------   -------   -----------------------------
 :DIRECTION   :INPUT    input (default) 
  
 :DIRECTION   :OUTPUT   output 
  
 :DIRECTION   :IO       input & output 
  
 :DIRECTION   :PROBE    none, returns a closed stream
  
 Keyword      Value                Action if File Exists
  
 ----------   ------------------   ---------------------------------------
 :IF-EXISTS   NIL                  return NIL 
  
 :IF-EXISTS   :ERROR               signal an error 
  
 :IF-EXISTS   :NEW-VERSION         next version (or error) 
  
 :IF-EXISTS   :RENAME              rename existing, create new 
  
 :IF-EXISTS   :SUPERSEDE           replace file upon CLOSE 
  
 :IF-EXISTS   :RENAME-AND-DELETE   rename and delete existing, create new 
 :IF-EXISTS   :OVERWRITE           reuse existing file (position at start) 
 :IF-EXISTS   :APPEND              reuse existing file (position at end)
  
 Keyword              Value     Action if File Does Not Exist-
 -----------------   -------   -----------------------------
 :IF-DOES-NOT-EXIST   NIL       return NIL 
  
 :IF-DOES-NOT-EXIST   :ERROR    signal an error 
  
 :IF-DOES-NOT-EXIST   :CREATE   create the file
  
 Keyword         Value               Element Type
  
 -------------   --------------      ------------------------
 :ELEMENT-TYPE   :DEFAULT            character (default) 
 :ELEMENT-TYPE   ’CHARACTER          character 
  
 :ELEMENT-TYPE   ’SIGNED-BYTE        signed byte 
  
 :ELEMENT-TYPE   ’UNSIGNED-BYTE      unsigned byte 
  
 :ELEMENT-TYPE   
 character subtype
    character subtype 
  
 :ELEMENT-TYPE   
 integer subtype
      integer subtype 
  
 :ELEMENT-TYPE   
 other
                implementation-dependent
  
 Keyword            Value      File Format
  
 ----------------   --------   ------------------------
 :EXTERNAL-FORMAT   :DEFAULT   default (default) 
  
 :EXTERNAL-FORMAT   
 other
       implementation-dependent
  
 Once you’ve opened a stream, you can use it with appropriate input or output functions, or with queries 
 that return attributes of either the stream or the file. The following queries can be applied to all kinds of 
 streams. All of these accept a stream argument: 
  
 185",NA
Creating streams on strings,"The data read or written by a stream doesn’t have to be associated with a device -- the data can just as well 
 be in memory. String streams let you read and write at memory speeds, but they can’t provide either file or 
 interactive 
  
 capabilities. 
  
 Lisp 
  
 provides 
  
 constructors 
  
 (
 MAKE-STRING-INPUT-STREAM 
  
 and 
 MAKE-STRING-OUTPUT-STREAM
 ), plus macros to support the ""open, process, close"" pattern. 
  
 186",NA
Binary I/O,"Lisp supports binary I/O via streams whose element types are finite (i.e. bounded) subtypes of 
 INTEGER
 . 
 Some examples of appropriate types are: 
  
  
  
  
 Implementation-dependent 
  
  
 SIGNED-BYTE
  
  
 UNSIGNED-BYTE
  
 Range of values 
  
  
 (INTEGER 0 31)
  
  
 (INTEGER -16 15)
  
 Specific number of bits 
  
  
 (SIGNED-BYTE 8)
  
  
 (UNSIGNED-BYTE 6)
  
  
 BIT
  
 ANSI Common Lisp implementations should support any of these types for binary I/O. However, the 
 implementation is not required to directly map the specified 
 :ELEMENT-TYPE
  onto the underlying file 
 system; an implementation is permitted to alter the external format so long as data read from a binary file 
 is the same as that written using the same 
 :ELEMENT-TYPE
 . 
  
 187",NA
Chapter 20 - Macro Etiquette,"Macros in Lisp are much more capable than macros in other programming languages. Rather than just 
 providing a simple shorthand notation, Lisp macros give you the capability to truly extend the language. In 
 this chapter we’ll learn about the program transforming capabilities of macros as we see how to properly 
 construct macros to solve a wide variety of problems.",NA
Macros are programs that generate programs,"Mention macros to most programmers, perhaps even you, and the first image that comes to mind is string 
 substitution -- you use a macro to glue together a few parameters in a new way, maybe with a bit of 
 compile-time decision making thrown in. And because of the typical (in languages other than Lisp) 
 disparity between the macro language and the programming language, the difficulty of writing a macro 
 increases much faster than its complexity. 
  
 Lisp macros are Lisp programs that generate other Lisp programs. The generated Lisp code has a fully-
 parenthesized notation, as does the macro that generates the code. In the simplest case, a macro substitutes 
 forms within a template, clearly establishing a visual correspondence between the generating code and the 
 generated code. Complex macros can use the full power of the Lisp language to generate code according 
 to the macro parameters; often a template form is wrapped in code that constructs appropriate subforms, 
 but even this approach is just a typical use pattern and not a requirement (or restriction) of the Lisp macro 
 facility. 
  
 In the following sections, we’ll examine the mechanism by which the Lisp system translates code 
 generated by a macro, then we’ll see several increasingly sophisticated examples of macros. We’ll finish 
 this chapter with a comparison of macros versus the use of inline function declarations.",NA
Close up: how macros work,"You define a macro with a 
 DEFMACRO
  form, like this: 
  
 (defmacro 
 name
  (
 arguments
  ...) 
  
 body
 )
  
 DEFMACRO
  is like 
 DEFUN
 , but instead of returning values, the body of the 
 DEFMACRO
  returns a Lisp 
 form. (As we’ll see shortly, there’s a very simple way to generate this form with selected subforms 
 replaced by parameters from the macro call or computed by the macro’s program.) 
  
 Your program ""calls"" a macro the same way it calls a function, but the behavior is quite different. First, 
 none of the macro’s parameters are evaluated. Ever. Macro parameters are bound literally to the 
 corresponding arguments in the macro definition. If you pass 
 (* 7 (+ 3 2))
  to a macro, the argument 
 in the body of the macro definition is bound to the literal list 
 (* 7 (+ 3 2))
 , and 
 not
  the value 35. 
  
 Next, the 
 macro expander
  is invoked, receiving all of the actual parameters bound to their corresponding 
 arguments as named by the 
 DEFMACRO
  form. The macro expander is just the body of the 
 DEFMACRO 
 form, which is just Lisp code; the only catch is that the Lisp system expects the macro expander to return a 
 Lisp form. 
  
 188",NA
Backquote looks like a substitution template,"The simplest way to generate a form in the body of your macro expander is to use the 
 backquote
  (
 ‘
 ) reader 
 macro. This behaves like the 
 quote
  (
 ’
 ) reader macro, except for when a comma (
 ,
 ) appears in the 
 backquoted form. 
  
 A comma is only permitted in a backquoted form. If you use a comma in a quoted form, Lisp will 
 signal an error when it reads the form.
  
 Like quote, backquote suppresses evaluation. But a comma within a backquoted form ""unsuppresses"" 
 evaluation for just the following subform. 
  
 ? ‘(The sum of 17 and 83 is ,(+ 17 83)) 
  
 (THE SUM OF 17 AND 83 IS 100)
  
 Compare the preceding example, which used backquote, with the similar form using quote (and omitting 
 the comma). 
  
 ? ’(The sum of 17 and 83 is (+ 17 83)) 
  
 (THE SUM OF 17 AND 83 IS (+ 17 83))
  
 You can probably imagine how backquote and comma provide a template with substitution capabilities. 
 This is just what we need for our macro expander. Here are a couple of simple examples. 
  
 ; Define the macro 
  
 ? (defmacro swap (a b) 
 ; NOTE: This is a restricted version of ROTATEF
  
  ‘(let ((temp ,a))
  
  
  
  (setf ,a ,b)
  
  
  
  (setf ,b temp))) 
  
 SWAP
  
 ; First invocation 
  
 ? (let ((x 3)
  
  
  
  (y 7))
  
  
  (swap x y) 
 ; macro call
  
  
  (list x y)) 
  
 (7 3) 
  
 ; Let’s see the form generated by SWAP: 
  
 ? (pprint (macroexpand-1 ’(swap x y)))
  
 189",NA
"Beyond the obvious, part 1: compute, then generate","Macros start to get interesting when they do more than a simple textual substitution. In this section, we’ll 
 explore a real-world example of using a macro to extend Lisp into the problem domain. In addition to 
 providing a macro expander, our new macro will automatically generate an environment that will be 
 referenced by the expander. Our example will show how to move computations from run-time to compile-
 time, and how to share information computed at compile-time. 
  
 Let’s say you’re working on an interactive game that makes heavy use of the trigonometric function 
 sine r 
 in computing player motion and interaction. You’ve already determined that calling the Lisp function 
 SIN 
 is too time-consuming; you also know that your program will work just fine with approximate results for 
 the computation of 
 sine r
 . You’d like to define a 
 LOOKUP-SIN
  macro to do the table lookup at runtime; 
 you’d also like to hide the details of table generation, an implementation detail with which you’d rather 
 not clutter your program’s source code. 
  
 Your macro will be invoked as 
 (LOOKUP-SIN
 radiansdivisions
 )
 , where 
 radians
  is always in the range of 
 zero to one-quarter pi, and 
 divisions
  is the number of discrete values available as the result of 
 LOOKUP-
 SIN
 . At runtime, the macro expander will just compute the index into a lookup table, and return the value 
 from the table. The table will be generated at compile-time (on most Lisp systems). Furthermore, only one 
 table will ever be generated for a given value of 
 divisions
  in the macro call. 
  
 Here’s the code. The comments and documentation strings should help you to understand the code as you 
 read it. I’ll provide further explanation below. 
  
 ;; This is where we cache all of the sine tables generated 
 ;; during compilation. The tables stay around at runtime 
 ;; so they can be used for lookups.
  
 (defvar *sin-tables* (make-hash-table)
  
  
  ""A hash table of tables of sine values. The hash is keyed 
 by the number of entries in each sine table."")
  
 ;; This is a helper function for the LOOKUP-SIN macro.
  
 ;; It is used only at compile time.
  
 (defun get-sin-table-and-increment (divisions)
  
  
  ""Returns a sine lookup table and the number of radians quantized 
 by each entry in the table. Tables of a given size are reused.
  
 A table covers angles from zero to pi/4 radians.""
  
  
  (let ((table (gethash divisions *sin-tables* :none))
  
    
  
  (increment (/ pi 2 divisions)))
  
   
  (when (eq table :none) 
  
    
 ;; Uncomment the next line to see when a table gets created.
  
   
 ;;(print ’|Making new table|)
  
  (setq table
  
     
  (setf (gethash divisions *sin-tables*)
  
     
   
  (make-array (1+ divisions) :initial-element 1.0))) 
 (dotimes (i divisions)
  
   
  (setf (aref table i)
  
     
  (sin (* increment i)))))
  
  (values table increment)))
  
 ;; Macro calls the helper at compile time, and returns an 
 ;; AREF form to do the lookup at runtime.
  
 191",NA
"Beyond the obvious, part 2: macros that define macros","Macros that define macros are used infrequently, partly because it’s hard to think of a good use for this 
 technique and partly because it’s difficult to get right. The following macro, based upon an example in Paul 
 Graham’s ""On Lisp"" [p 255] book, can be used to define synonyms for the names of Lisp functions, 
 macros, and special forms. 
  
 ? (defmacro defsynonym (old-name new-name)
  
  
  ""Define OLD-NAME to be equivalent to NEW-NAME when used in 
 the first position of a Lisp form.""
  
  
  ‘(defmacro ,new-name (&rest args)
  
  
  
  ‘(,’,old-name ,@args))) 
  
 DEFSYNONYM 
  
 ? (defsynonym make-pair cons) 
  
 MAKE-PAIR 
  
 ? (make-pair ’a ’b) 
  
 (A . B)
  
 Macros are always a little bit dangerous because code containing a macro call does not automatically get 
 updated if you change the definition of the macro. You can always establish your own convention to help 
 you remember that you need to recompile certain code after you change a macro definition. But there’s 
 always the possibility that you’ll forget, or make a mistake. 
  
 192",NA
Tricks of the trade: elude capture using GENSYM,"You have to be be careful when you define a macro that introduces new variables in its expansion. The 
 REPEAT
  macro, below, offers us a shorthand way of repeating a body of code a certain number of times. 
  
 ? (defmacro repeat (times &body body)
  
  
  ‘(dotimes (x ,times)
  
  
  
  ,@body)) 
  
 REPEAT 
  
 ? (repeat 3 (print ’hi))
  
 HI 
  
 HI 
  
 HI 
  
 NI
 L
  
 This seems to do the right thing, but the variable 
 X
  is going to cause problems. The following example 
 should
  give us the same results as the last example. 
  
 ? (setq x ’hi) 
  
 HI 
  
 ? x 
  
 HI 
  
 ? (repeat 3 (print x))
  
 0 
  
 1 
  
 2 
  
 NI
 L
  
 The variable 
 X
  in the macro expander 
 shadowed
  the global 
 X
  that we tried to reference in the body. 
 Another way to say this is that 
 X
  is 
 free
  in the body of the 
 REPEAT
  form, but it was 
 captured
  by the 
 definition of 
 X
  in the macro expander; this prevents the body form from reaching the intended variable 
 X
 . 
  
 The obvious solution is to use a different variable name in the macro expander -- one that won’t conflict 
 with any name we’ll ever use in our code that calls the 
 REPEAT
  macro. You might think that some kind of 
 naming convention would work, but there’s always the chance that some programmer will come along 
 later and violate the convention. We need a foolproof approach. 
  
 Lisp provides a 
 GENSYM
  function to generate symbols that are 
 guaranteed
  to be unique. No programmer 
 can ever write a symbol name that conflicts with a symbol created by 
 GENSYM
 . Here is how we use 
 GENSYM
  to create a name for the variable needed in the macro expander for the 
 REPEAT
  macro.",NA
Macros vs. inlining,"Lisp allows functions to be inlined by the compiler. In other words, rather than compiling a call to the 
 function, the compiler may substitute the function’s body, thus saving the overhead of a function call. 
 Substituting the function’s body is generally expensive in terms of space, since a function body’s code is 
 usually longer than the code of its calling sequence. 
  
 It’s important to understand that Lisp 
 allows
  functions to be inlined. Like all other declarations -- save the 
 SPECIAL
  declaration -- an 
 INLINE
  declaration may be treated as advisory or ignored entirely by the 
 compiler. 
  
 Here are some examples of how to inline a function. In the first case, function 
 F
  is inlined everywhere it is 
 used (assuming that the compiler supports inlining). In the second case, function 
 P
  is compiled with 
 information to support inlining, but is only inlined in the presence of a declaration, as in function 
 Q
 . 
  
 ; Case 1 -- F may always be inlined 
  
 (declaim (inline f)) 
  
 (defun f (...) ...)
  
 (defun g (...)
  
  (f ...)
  
  ...)
  
 (defun h (...)
  
  (f ...)
  
  ...)
  
 ; Case 2 - P may be inlined only following a declaration 
 (declaim (inline p)) 
  
 (defun p (...) ...) 
  
 (declaim (notinline p))
  
 (defun q (...) 
  
  (declare (inline p))
  
  (p ...) 
 ; inlined
  
  ...)
  
 196",NA
Chapter 21 - Fancy Tricks with Function and Macro ,NA,NA
Arguments,"We’ve already seen (in Chapter 4) how 
 &OPTIONAL
  parameters can reduce the number of arguments that 
 you have to supply for the most common calls of a function. In this chapter we’ll look at additional 
 language features that let you declare named (keyword) parameters and provide default values for 
 unspecified parameters. We’ll also take a look at structured argument lists, which let you group related 
 parameters for clarity.",NA
Keywords let you name your parameters,"Sometimes you’ll want to define a function (or macro) that works just fine with a small list of arguments, 
 but can be extended in useful -- and obvious, I hope -- ways through the addition of extra arguments. But 
 you’d rather not specify 
 all
  of the arguments 
 all
  of the time. We’ve already seen keyword arguments used 
 in Chapter 13 with the sequence functions, and in Chapter 19 with the stream functions. 
  
 You can use keyword arguments for your own functions or macros by adding a 
 &key
  marker to the lambda 
 list. The general form (also used for 
 DEFMACRO
 ) is: 
  
 (defun 
 name
  (
 req-arg
  ... &key 
 key-arg
 )
  
  ...)
  
 All of the required arguments (
 req-arg
 ) must precede the 
 &KEY
  marker. The 
 key-arg
 s name the variable 
 that you’ll reference from within your function’s definition; the same 
 key-arg
  name in the keyword 
 package (i.e. preceded with a colon) is used in the call as a prefix for the keyword value. 
  
 ? (defun keyword-sample-1 (a b c &key d e f)
  
  
  (list a b c d e f)) 
  
 KEYWORD-SAMPLE-1 
  
 ? (keyword-sample-1 1 2 3) 
  
 (1 2 3 NIL NIL NIL) 
  
 ? (keyword-sample-1 1 2 3 :d 4) 
  
 (1 2 3 4 NIL NIL) 
  
 ? (keyword-sample-1 1 2 3 :e 5) 
  
 (1 2 3 NIL 5 NIL) 
  
 ? (keyword-sample-1 1 2 3 :f 6 :d 4 :e 5) 
  
 (1 2 3 4 5 6)
  
 You’ll notice from the last sample that keyword parameters may be listed in any order. However, as in their 
 lambda list declaration, all keyword parameters must follow all required parameters.",NA
Default values for when you’d rather not say,"Any keyword parameter that you don’t specify in a call receives a 
 NIL
  default value. You can change the 
 default using a variation of the keyword argument declaration: instead of just the argument name, specify 
 (
 namedefault
 )
 , like this: 
  
 198",NA
Add some structure to your macros by taking apart ,NA,NA
arguments,"You can use 
 destructuring
  to create groups of parameters for macros. 
  
 ? (defmacro destructuring-sample-1 ((a b) (c d))
  
  ‘(list ’,a ’,b ’,c ’,d)) 
  
 DESTRUCTURING-SAMPLE-1 
  
 ? (destructuring-sample-1 (1 2) (3 4)) 
  
 (1 2 3 4)
  
 You can use all the usual techniques within each group. 
  
 ? (defmacro destructuring-sample-2 ((a &key b) (c &optional d))
  
  ‘(list ’,a ’,b ’,c ’,d)) 
  
 DESTRUCTURING-SAMPLE-2 
  
 ? (destructuring-sample-2 (1) (3)) 
  
 (1 NIL 3 NIL) 
  
 ? (destructuring-sample-2 (1 :b 2) (3)) 
  
 (1 2 3 NIL) 
  
 ? (destructuring-sample-2 (1) (3 4)) 
  
 (1 NIL 3 4)
  
 And the groupings can even be nested. 
  
 ? (defmacro destructuring-sample-3 ((a &key b) (c (d e) &optional f))
  
  ‘(list ’,a ’,b ’,c ’,d ’,e ’,f)) 
  
 DESTRUCTURING-SAMPLE-3 
  
 ? (destructuring-sample-3 (1) (3 (4 5))) 
  
 (1 NIL 3 4 5 NIL)
  
 Destructuring is commonly used to set off a group of arguments or declarations from the body forms in a 
 macro. Here’s an extended example, 
 WITH-PROCESSES
 , that expects a name, a list of a variable name 
 (pid) and a process count (num-processes), and a list of another variable name (work-item) and a list of 
 elements to process (work-queue). All of these arguments are grouped before the body forms. 
  
 200",NA
"Chapter 22 - How to Find Your Way Around, Part 3","In Chapter 10 we learned about two functions you can use to examine Lisp objects: 
 DESCRIBE
  and 
 INSPECT
 . These are available in every implementation, so you should learn how to use them just in case 
 you find yourself sitting at a console in front of a new and unknown Lisp system someday. 
  
 Some Lisp systems offer additional tools that aren’t part of ANSI Common Lisp. Sometimes the extra 
 tools are built in, and other times they’re provided by the vendor but not installed by default. In this 
 chapter I’ll tell you a bit about these tools, so you’ll know what to look for. 
  
 In addition to exploring the structure and relationships of objects, it’s sometimes useful to ""hook in"" to the 
 behavior of certain functions. You might just want to know when -- or whether -- a function is called with 
 certain arguments. 
 TRACE
  is always at your disposal (see Chapter 16), but you may only be interested in 
 one particular call out of thousands; generating the trace output (never mind sifting through it later) can be 
 very time consuming. For cases like this, some Lisp implementations let you 
 advise
  an existing function 
 without changing its source code.",NA
Class and method browsers help you find your way in a ,NA,NA
sea of objects,"When you program a large system using CLOS, especially if the system evolves over time as so many do, 
 you’ll need a tool to help you examine the relationships between classes. Some Lisp systems provide a 
 browser that displays these relationships graphically. Here’s an example of what my system’s browser 
 displays as the subclasses of 
 ARRAY
 : 
  
  
 Another useful tool, the method browser, lets you explore all of the specializations of a particular method. 
 The browser may let you filter on particular qualifiers (we learned about qualifiers in Chapter 14), and will 
 almost certainly give you navigational access to selected method definitions. Here’s a list from the method 
 browser in my Lisp system; I asked for a list of all 
 INITIALIZE-INSTANCE
  methods having the 
 :AROUND 
 qualifier: 
  
  
 203",NA
ADVISE lets you modify a function’s behavior without ,NA,NA
changing the function,"Some Lisp systems include an 
 ADVISE
  capability. This lets you intercept calls to existing functions. You 
 can provide code that examines (and perhaps alters) the function’s arguments and results. 
 ADVISE
  has 
 many uses, most of them invented on the spur of the moment. However, one common use of 
 ADVISE
  is to 
 implement a 
 TRACE
  or 
 BREAK
  that is conditioned upon particular arguments or results. 
  
 The syntax and options for 
 ADVISE
  vary from system to system. Here’s an example of defining advice in 
 one particular implementation: 
  
 (advise fibonacci
  
  (when (zerop (first arglist)) (break))
  
  :when :before
  
  :name :break-on-zero)
  
 This example shows how to advise a 
 FIBONACCI
  function by adding code that breaks into the debugger 
 when 
 FIBONACCI
 ’s first argument is zero. Note that we do not need any knowledge of or access to the 
 source code of 
 FIBONACCI
  in order to add this advice. 
  
 This particular implementation of 
 ADVISE
  binds a list of all of the advised function’s arguments into a 
 variable named 
 ARGLIST
 . The keyword arguments declare that the advice form, 
 (WHEN (ZEROP 
 (FIRST ARGLIST)) (BREAK))
 , is to be executed 
 before
  each call to 
 FIBONACCI
 . The advice has 
 the name 
 :BREAK-ON-ZERO
 ; this name is used when removing advice (typically via an 
 UNADVISE 
 form) or when redefining the behavior of a particular advice.",NA
WATCH lets you open a window on interesting variables,"A 
 watch
  tool, found less commonly on Lisp systems, allows you to display the current state of a variable 
 as your program runs. The details vary widely. Implementations may give you sampled real-time display, 
 or may slow the program down in order to give you an accurate display of each change. Sometimes the 
 watcher is integrated with a debugger or stepper, and other times it is an independent tool. Consult your 
 vendor’s documentation to learn whether your Lisp system has a watch tool. 
  
 204",NA
"Chapter 23 - To Err is Expected; To Recover, Divine","In this chapter you’ll learn how to create your own error detection, reporting and recovery mechanisms. A 
 good error handling strategy can give your program the ability to gracefully handle both expected and 
 unexpected errors without failing or losing critical data.",NA
Signal your own errors and impress your users,"One of the most common failings of computer programs is the failure to report failures in a meaningful 
 way. If some input is out of the expected range, or if a calculation exceeds the capabilities of the program, 
 or if communication does not succeed with some external device, a poorly-written program will simply 
 ""roll over and die"" with a cryptic error message related to hidden details of the program’s implementation. 
 In theory, it’s nice to be able to construct programs without limits; the dynamic nature of Lisp certainly 
 enables this practice. 
  
 But in almost every non-trivial program there will always arise some fatal situation that can be anticipated 
 by the programmer but not addressed by the program. It is precisely for these situations that Lisp provides 
 the 
 ERROR
  function. 
 ERROR
  expects a format string and arguments. (We’ve seen 
 FORMAT
  briefly in 
 Chapter 4, and will examine it in detail in Chapter 24 [p 215] .) 
 ERROR
  gives your program a standard way 
 to announce a fatal error. You simply compose an appropriate message using the format string and 
 (optional) arguments, and 
 ERROR
  takes care of the rest. 
  
 ? (defun divide (numerator denominator)
  
  
  (when (zerop denominator)
  
  
  
  (error ""Sorry, you can’t divide by zero.""))
  
  (/ numerator denominator)) 
  
 DIVIDE 
  
 ? (divide 4 3) 
  
 4/3 
  
 ? (divide 1 0) 
  
 Error: Sorry, you can’t divide by zero.
  
 Your program never returns from the call to 
 ERROR
 . Instead, the Lisp debugger will be entered. You’ll 
 have an opportunity to examine the cause of the error while in the debugger, but you will not be able to 
 resume your program’s execution. This makes 
 ERROR
  a rather extreme response to a problem detected by 
 your program. Later, we’ll see how to report problems 
 and
  give the user an opportunity to correct the 
 problem. We’ll even see how errors can be handled automatically.",NA
Categorize errors using Conditions,"Note: If you have a really old Lisp system, it may not include an implementation of conditions. If so, 
 this section and the following one may not be of much use to you, except to point out what your Lisp 
 system lacks as compared to the current standard.
  
 An error is just a condition that requires some kind of correction before your program may continue. The 
 error may be corrected by having the program’s user interact with the debugger, or through the 
 intervention of a handler (as we’ll see later in this chapter). 
  
 205",NA
Recover from Conditions using Restarts,"In this final section, we’ll see how to recover from errors. The simplest forms involve the use of 
 CERROR 
 or 
 ASSERT
 . 
  
 ? (progn (cerror ""Go ahead, make my day.""
  
  
  
  ""Do you feel lucky?"")
  
  ""Just kidding"") 
  
 Error: Do you feel lucky?
  
 Restart options:
  
  
  1: Go ahead, make my day.
  
  2. Top level
  
 The ""Restart options"" list shown in this and the following examples is typical, but not standard. 
 Different Lisp systems will present restart information in their own ways, and may add other built in 
 options.
  
 207",NA
Chapter 24 - FORMAT Speaks a Different Language,"Throughout this book, we’ve shown some simple uses of 
 FORMAT
  without explanation. In this chapter, 
 we’ll inventory and describe 
 FORMAT
 ’s most useful capabilities, and a few of its more esoteric features.",NA
"FORMAT rhymes with FORTRAN, sort of...","FORMAT
  appears to have been inspired by FORTRAN’s varied and capable function of the same name. 
 But Lisp’s 
 FORMAT
  implements a programming language in its own right, designed expressly for the 
 purposes of formatting textual output. 
 FORMAT
  can print data of many types, using various decorations 
 and embellishments. It can print numbers as words or -- for you movie buffs -- as Roman numerals. 
 Columnar output is a breeze with 
 FORMAT
 ’s facilities for iterating over lists and advancing to specific 
 positions on an output line. You can even make portions of the output appear differently depending upon 
 the formatted variables. This chapter covers a representative portion of what 
 FORMAT
  can do; you should 
 consult a Lisp reference to get the full story.",NA
Formatting,"FORMAT
  expects a destination argument, a format control string, and a list of zero or more arguments to be 
 used by the control string to produce formatted output. 
  
 Output goes to a location determined by the destination argument. If the destination is 
 T
 , output goes to 
 *STANDARD-OUTPUT*
 . The destination can also be a specific output stream. 
  
 There are two ways 
 FORMAT
  can send output to a string. One is to specify 
 NIL
  for the destination: 
 FORMAT
  will return a string containing the formatted output. The other way is to specify a string for the 
 destination; the string must have a fill pointer. 
  
 ? (defparameter *s* 
  
  
  (make-array 0 
  
  
  
  :element-type ’character 
  
  
  
  :adjustable t 
  
  
  
  :fill-pointer 0)) 
  
 """" 
  
 ? (format *s* ""Hello~%"") 
  
 NIL 
  
 ? *s* 
  
 ""Hello 
  
 "" 
  
 ? (format *s* ""Goodbye"") 
  
 NIL 
  
 ? *s* 
  
 ""Hello 
  
 Goodbye"" 
  
 ? (setf (fill-pointer *s*) 0) 
  
 0 
  
 ? *s* 
  
 """"
  
 215",NA
Iteration,"List elements can be formatted using the directive 
 ~{
 format-control
 ~}
 . The argument 
 must
  be a list; 
 format-control
  consumes elements of the list. Iteration terminates when the list is empty before the next 
 pass over 
 format-control
 . Here’s a simple example: 
  
 ? (format t ""~&Name~20TExtension~{~&~A~20T~A~}""
  
  ’(""Joe"" 3215 ""Mary"" 3246 ""Fred"" 3222 ""Dave"" 3232 ""Joseph"" 3212)) Name                
 Extension 
  
 Joe                 3215 
  
 Mary                3246 
  
 Fred                3222 
  
 Dave                3232 
  
 Joseph              3212 
  
 NIL
  
 If your list might end in the middle of the iteration’s 
 format-control
 , you can insert a 
 ~^
  directive at that 
 point. If the argument list is empty when interpreting the 
 ~^
  directive, the iteration 
 ~{
 format-control
 ~} 
 terminates at that point. 
  
 Additional options let you limit the number of iterations and specify different requirements for the 
 arguments. Consult a Lisp reference for details. 
  
 218",NA
Conditionals,"Conditional format directives are introduced by 
 ~[
  and delimited by 
 ~]
 . There are several forms, which 
 I’ll call ordinal, binary, and conditional. The ordinal form is 
 ~[
 format-0
 ~;
 format-1
 ~;
 ...
 ~;
 format-N
 ~]
 , 
 which selects the 
 format-Ith
  clause for an argument value of 
 I
 . 
  
 ? (format t ""~[Lisp 1.5~;MACLISP~;PSL~;Common Lisp~]"" 2) 
 PSL 
  
 NIL
  
 Within 
 ~[
  and 
 ~]
  you can specify a final 
 default
  clause as 
 ~:;
 format-default
 ; this is selected if the 
 argument is outside the range 0 to N. 
  
 The binary form is written 
 ~:[
 format-false
 ~;
 format-true
 ~]
 . The 
 format-false
  clause is interpreted if the 
 argument is 
 NIL
 ; otherwise, the 
 format-true
  clause is interpreted. 
  
 ? (format t ""My computer ~:[doesn’t~;does~] like Lisp."" t) 
 My computer does like Lisp.
  
 NIL 
  
 ? (format t ""My computer ~:[doesn’t~;does~] like Lisp."" nil) 
 My computer doesn’t like Lisp.
  
 NIL
  
 The conditional form, written as 
 ~@[
 format
 ~]
 , first tests its argument. If the argument is not 
 NIL
 , it is not 
 consumed; rather, it is left for 
 format
  to consume. If the argument is 
 NIL
 , then it is consumed and 
 format
  is 
 not interpreted. 
  
 ? (format nil ""~{~@[~A ~]~}"" ’(1 2 nil 3 t nil 4 nil)) 
 ""1 2 3 T 4""",NA
Floobydust,"As you’ve seen, many of the format directives accept optional parameters, such as the field width 
 parameter of the justification, tabbing, and numeric directives. Our examples have encoded these 
 parameters into the format control string. Sometimes it is useful to have a parameter vary during the 
 program’s operation. You can do this by specifying 
 V
  where the parameter would appear; the parameter’s 
 value is then taken from the next argument in the argument list. 
  
 ? (format t ""~{~&~VD~}"" ’(5 37 10 253 15 9847 10 559 5 12)) 
 37
  
   
  253
  
   
  
  9847
  
   
  559
  
  12 
  
 NIL
  
 In this example, the arguments are consumed in pairs, with the first of each pair specifying a field width 
 and the second being the number to print. 
  
 219",NA
Chapter 25 - Connecting Lisp to the Real World,"Lisp provides a wonderful development environment, as we’ll see in the next few chapters. But Lisp 
 would be of little value for some applications without a way to access external programs written in other 
 languages. Fortunately, modern Lisp implementations have a Foreign Function Interface, or FFI for short. 
  
 In this chapter I’ll describe FFI in general terms. Implementations differ in the details since FFI has not 
 (yet) been standardized. Despite the lack of standardization, current implementations seem to have 
 converged on a similar set of features.",NA
Foreign Function Interfaces let you talk to programs ,NA,NA
"written in ""foreign languages""","An FFI lets your Lisp program interact with code that is ""foreign"" -- i.e. not Lisp. 
  
 This Lisp-centric view of the world is probably motivated by the Lisp machines, where everything --
 even the low-level portions of the OS -- was written in Lisp. A good many of the people involved 
 with Lisp during that time are responsible as well for the development of modern Lisp 
 implementations; hence, the not-so-subtle nod toward the notion of Lisp as the center of the 
 programmer’s universe.
  
 A typical FFI provides for both calls from Lisp to separately-compiled code, and from separately compiled 
 code to Lisp. (In the latter case, it is almost always true that the external code must have been called from 
 Lisp; it can then call back into Lisp.) Most often, an FFI supports a C calling convention.",NA
"Would you wrap this, please?","Why is an FFI even necessary? Why can’t you link-in separately compiled code as in any other language? 
 The main reason is that Lisp datatypes don’t generally have equivalents in conventional languages. For 
 example, C integers typically fill (depending upon declaration) one-half, one, or two machine words and 
 produce mathematically incorrect results when a result exceeds the representational capacity of the 
 integer’s storage. A Lisp integer can fit in a machine word, saving a few bits for a type tag. These are 
 called fixnums. Lisp integers having magnitudes exceeding the capacity of the single word representation 
 are converted to a representation that has an unlimited number of bits -- these are bignums. And with a 
 good compiler, you can define subtypes of integers that, when packed into an array, have just enough bits 
 in their representation to handle the declared range of values. 
  
 So, one purpose of an FFI is to translate Lisp datatypes to (and from) ""foreign"" datatypes. Not all 
 conversions are possible -- a good FFI will signal an error when a conversion is not possible at runtime. 
  
 When a non-Lisp function accepts or returns values in a record datatype, the FFI must provide a means of 
 constructing appropriate records. Typically, the FFI gives you a way to construct records that are bit-for-
 bit identical to those that would have been produced by another language. Fields within a record are set 
 and retrieved using specialized Lisp accessors. 
  
 220",NA
I’ll call you back...,"Usually a foreign function is called for its results or to have some effect on the external environment, and 
 a simple call/return sequence is all that’s needed. But some foreign functions, particularly those that deal 
 with user interface or device I/O, require access to 
 callback functions
  during their operation. A callback 
 function is called 
 from
  the foreign function. 
  
 To define a callback function in Lisp, the FFI basically has to solve all of the foreign function problems in 
 the reverse direction. You use the FFI to define a Lisp function that is callable from another language. The 
 result is typically a function object or pointer that can be passed (as a parameter) to a call of a foreign 
 function. When the foreign function is called, it references the callback parameter in the normal manner to 
 invoke the Lisp callback function. The FFI wrapper around the callback translates the foreign calling 
 sequence and parameter values to the corresponding Lisp format, invokes the Lisp callback function, and 
 returns the callback’s results after suitable translation from Lisp to foreign formats.",NA
Network Interfaces: beyond these four walls,"Although network protocols are hightly standardized and interoperable, networking APIs are not. 
 Common Lisp vendors usually provide their own interface to the target platform’s networking software. 
 Franz’s Allegro Common Lisp provides a simple sockets library for IP networking. Digitool’s Macintosh 
 Common Lisp comes with a complete set of interfaces to the low-level networking APIs (IP, AppleTalk 
 and PPC) of the Mac OS, plus a collection of sample code that uses the low-level calls to perform 
 common networking tasks; you can use the samples as-is or customize them to your requirements. 
  
 221",NA
Chapter 26 - Put on a Happy Face: Interface ,NA,NA
Builders,"Graphical user interfaces (GUIs) have changed the way that people use computers. High-end Lisp systems 
 had sophisticated GUIs as far back as the late 1970s, with low-cost consumer computers adopting GUIs in 
 1984. Modern Lisp systems include tools to build GUIs using both platform-specific and platform-
 independent techniques. The former can take advantage of proprietary features of the platform’s user 
 interface, while the latter provide an abstraction that is portable across multiple platforms.",NA
Event-driven interfaces,"Events
  are key to the operation of all GUIs. An event is a gesture initiated by the user: typically a 
 keystroke, mouse movement or click, menu selection, pen stroke, or speech utterance. An event can occur 
 at any time. This means that the program must be prepared to handle any event at any time in some 
 meaningful way. The interpretation of an event will depend upon the current state of the program, e.g. 
 what windows are visible on the screen and what each window is displaying. An event may change the 
 state of the program and therefore affect the interpretation of later events. But in all cases, the program 
 must be prepared to handle receipt of any event at any time. 
  
 Event-driven programs have a control structure known as an 
 event loop
 . The event loop receives events 
 and dispatches them to some part of the program, normally the portion of the program that is in control of 
 the current 
 focus
 , or site of user interest, among all of the information currently displayed by the program.",NA
Graphical programming,"The next, and more obvious, characteristic of graphical user interfaces is that they rely entirely upon 
 graphics. Even text is displayed as a graphical image. Of course, it would be incredibly painful (and silly) 
 for every programmer to write programs to render text, lines, circles, boxes, menus, controls, etc. The 
 operating system provides a collection of library routines to draw graphical objects, windows, and controls; 
 the Lisp environment typically provides wrappers (often by use of the Lisp foreign function interface) 
 around the graphics routines so that they may be called from within Lisp. 
  
 The availability and implementation details of graphics routines vary widely from platform to platform. 
 You should consult the documentation for your Lisp implementation to learn about how it supports 
 graphics.",NA
Example: MCL’s Interface Toolkit,"Macintosh Common Lisp (MCL) provides access to the underlying graphical toolkit of the Macintosh OS 
 in two ways. MCL provides a high-level interface for presenting windows, menus, controls, text, and 
 graphics. This interface is at a higher level of abstraction than the underlying OS primitives; it separates 
 the programmer from concerns about memory allocation, record layout, and pointers. MCL also provides a 
 low-level interface that lets you program with the underlying OS routines (not just for graphics, but for the 
 entire OS). When you use the low-level interface, you are faced with all the concerns that dog a C or
  
 222",NA
Creating a simple dialog,"MCL’s Interface Toolkit allows you to create dialogs and menus. To create a dialog, you first select a 
 window style. 
  
  
 Here, I’ve chosen to create a simple document window. 
  
  
 A palette of controls appears near the new window. From this palette you can drag and drop controls to 
 create the desired window layout. 
  
 223",NA
Editing a menu ,"The Interface Toolkit also lets you create and edit menubars, menus, and menu items. You begin with the 
 menubar editor. 
  
  
 Here, I’ve chosen to edit MCL’s Edit menu. 
  
  
 225",NA
Platform-independent interfaces,"A platform-independent interface abstracts away details of the underlying operating system’s GUI, 
 providing its own event loop, windows, menus, and controls. When you write a GUI using these 
 abstractions, the code can be moved to any other Lisp platform (assuming availability of the platform-
 independent interface) through recompilation. 
  
 CLIM is a commercially-supported platform-independent user interface available on all Lisp platforms. 
 CLIM 2.0 even preserves the native look and feel of each platform by mapping platform-independent 
 requests for windows, menus, and controls onto calls to the native OS graphics services. 
  
 Garnet is a free, unsupported platform-independent user interface that is available for most Lisp platforms. 
 Source code is freely available, so you could port Garnet to a new platform if you are so inclined. Unlike 
 CLIM 2.0, Garnet uses its own definitions for windows, menus, and controls; this means that a Garnet 
 GUI will look the same regardless of platform. 
  
 226",NA
Chapter 27 - A Good Editor is Worth a Thousand ,NA,NA
Keystrokes,"Lisp’s simple syntax combines with an integrated editor to ease many of the common tasks of writing a 
 Lisp program. Anyone who tries to tell you that ""it’s hard to balance parentheses in a Lisp program"" is 
 using the wrong editor.",NA
Simple syntax; smart editors,"Lisp has a very simple syntax; it’s just a bunch of tokens bracketed by a pair of parentheses, recursively. 
 This simple syntax, combined with the fact that the first token following a left parenthesis usually says 
 something about the meaning of the following tokens, lets editors do relatively smart things with program 
 text given only local information. 
  
 Virtually every Lisp environment comes with its own Lisp-aware editor. The rare (usually free and 
 minimalist) Lisp environment that doesn’t provide its own editor can use Emacs, which has a mode for 
 editing Lisp source code.",NA
Matching and flashing,"As you type a Lisp program for the first time, it’s handy to see the matching parentheses at a glance. Most 
 Lisp editors facilitate this by briefly highlighting the opening parenthesis for each close parenthesis that 
 you type. Highlighting can take different forms, depending upon the implementation. Sometimes, the text 
 insertion cursor jumps back to the opening parenthesis for a fraction of a second (and then returns to its 
 proper position before inserting the next typed character.) Another common technique is to briefly display 
 the opening parenthesis in a bold font or a different color. And some editors even draw an outline around 
 the entire list. No matter how it’s done, you can see at a glance how your closing parentheses match their 
 opening counterparts, with not so much as a pause in your typing of the program. 
  
 Once you’ve entered the program, you can find matching parentheses by positioning the cursor to either 
 the beginning or ending parenthesis, then typing a keystroke that will either flash or move the cursor to the 
 matching parenthesis.",NA
Automatic indentation,"Parenthesis matching is important when you’re entering or editing a program. When you’re reading a Lisp 
 program, proper indentation is important to give you visual cues as to the program structure. In fact, you 
 should be able to hide the parentheses in a properly indented Lisp program and still understand the 
 program. 
  
 Lisp editors typically supply proper indentation as you type a new program; with some editors this is done 
 automatically, while others require that you use a different keystroke in place of the return key to end a 
 line. Together with parenthesis matching, automatic indentation lets you type a properly parenthesized and 
 indented Lisp program without ever having to count parentheses or spaces. 
  
 227",NA
Symbol completion,"Lisp programmers tend not to abbreviate names. The short, mnemonic names in Common Lisp are there 
 for historical reasons; the newer additions to Lisp have fully spelled out, descriptive names. Fortunately, a 
 good Lisp program editor can save you a lot of typing by providing a symbol completion facility. 
  
 Symbol completion works like this. As you type your program, you’re using names that are both built into 
 the Lisp system and defined anew by your program. As you type a name, you can press a symbol-
 completions keystroke anytime after having typed the first few characters. If the typed prefix 
 uniquely
  
 matches some symbol already known to the Lisp environment (either because it’s built in, or because 
 you’ve previously typed the whole name), the editor will type the rest of the symbol for you. If the typed 
 prefix matches more than one completion, the editor may either pick the first and let you cycle through the 
 rest by repeating the completion keystroke, or it may present a list of possible completions from which you 
 can choose. In any case, it’s important to note that symbol completion does 
 not
  depend upon having 
 compiled your program; completion works even during initial program entry.",NA
Finding definitions,"As you develop your program, you’ll often find that it’s helpful to refer to a function that you’ve defined 
 earlier; perhaps you need to see the source code to confirm that it will respond appropriately to unexpected 
 inputs, or maybe you need to see how some vendor-supplied function is implemented. Lisp editors support 
 this kind of exploration with yet another keystroke; just position the cursor somewhere in a name, press a 
 key, and (if the definition is accessible in source form) you’re instantly shown a view of the defining 
 source code.",NA
On-line documentation,"Despite its underlying simplicity, Lisp is a large language. The formal ANSI specification fills some 1,500 
 pages of paper describing the language and 978 predefined symbols. On top of that, your vendor’s 
 development environment will define hundreds of thousands of additional symbols. And, of course, your 
 program will only add to the roster of symbol names. 
  
 Most Lisp editors will let you access documentation in various forms. For built-in and user-defined code, 
 the editor should give you quick access to the documentation string and argument list. In fact, many Lisp 
 editors automatically find and inobtrusively display the argument list whenever you type a space following 
 a function or macro name. A quick glance at the argument list helps you avoid usage mistakes. 
  
 228",NA
Access to debugging tools,"The editor (or the Lisp environment in general if the environment is not editor-centric) should support 
 easy access to debugging tools such as browsers, trace and step facilities, backtraces, inspectors, and 
 program databases such as apropos, who-calls, and callers-of (see Chapters 10, 16, and 22).",NA
Extending the editor using Lisp,"The editor in many Lisp development environments is itself written in Lisp. The vendor should document 
 the external APIs of the editor and supply source code; then you can add your own extensions to the editor 
 and customize your Lisp environment to fit the way that you work. 
  
 229",NA
Chapter 28 - Practical Techniques for Programming,"In this chapter, we’ll learn some brief yet useful guidelines for Lisp style, followed by practical advice on 
 tradeoffs among debugging, performance, and readability.",NA
Elements of Lisp style,"The art of Lisp style is simpler and more fruitful than in most other languages. Lisp’s simple, consistent 
 syntax eliminates the need for the rules of style that plague more complicated languages. And the direct, 
 standardized availability of complex functionality within Lisp helps to drive down the size of programs, 
 thereby providing improved readability through brevity. (In my experience, a Lisp program may range in 
 size from 5 percent to 20 percent of an equivalent C++ program.) 
  
 Furthermore, the universal availability of Lisp-aware program editing tools -- such as Emacs or its 
 equivalent built into many Lisp IDEs -- means that you can let the computer handle the details of 
 indentation that are so important to the ability of a person to comprehend the structure of a Lisp program. 
 I’ve said this before, but it bears repeating: you should 
 not
  be programming in Lisp without the aid of a 
 Lisp-aware editor. 
  
 So, if we don’t have to worry about conventions for spelling, capitalization, indentation, and other such 
 mundane details, then what remains for us to discuss as elements of Lisp style? How about things that are 
 truly important? Lisp programming style is about the choice of proper abstractions, and about 
 communicating not just with the compiler, but with other people who will eventually read your program.
  
 (For that matter, good style will help you read your own program some months or years in the future.)",NA
Property lists are handy for small (very small) ad-hoc ,NA,NA
databases,"A long, long time ago the capabilities of a typical Lisp implementation were very much less than what 
 you’ll find in any Common Lisp system today. After all, Lisp has been around for over forty years since 
 John McCarthy first invented the notations (see Chapter 34 [p 257] ). Strangely, when Lisp is taught at all 
 in computer science curricula, it is taught using a circa-1965 view of the state of Lisp implementations: 
 interpreted execution, limited data structures, and no real application beyond the manipulation of symbols. 
  
 Unfortunately, authors and publishers of Lisp textbooks did little to help correct these misperceptions, 
 ignoring Common Lisp (and indeed, many of its recent forebears) in highly-recommened Lisp textbooks 
 published as recently as 1989. 
  
 In the bad old days -- when Lisp didn’t have arrays, vectors, hash tables, structures, or CLOS --
 programmers learned to rely heavily on property lists as an important mechanism for structuring data. 
 You’ll still find -- in bookstores and on the shelves of college libraries -- Lisp and AI books that 
 recommend the use of property lists as the underlying basis for looking up values identified by a symbolic 
 key. 
  
 230",NA
"Declarations help the compiler, sometimes","Common Lisp defines the following declarations: 
  
 special 
  
  
 declares a variable to have dynamic (not lexical) scope 
  
 optimize 
  
  
 instructs the compiler how to weight the relative importance of 
  
  
 speed 
  
  
 safety 
  
  
 space 
  
  
 debug 
  
  
  
  
 compilation-speed 
  
 dynamic-extent 
  
  
 declares that the programmer expects the lifetime of a function or variable to end when control leaves 
  
 the enclosing form 
  
 type 
  
  
 declares that a variable will always have values of a given type 
  
 231",NA
DEFVAR versus DEFPARAMETER,"Although not required by the Common Lisp standard, almost all implementations require that you load 
 code from a file. (The one exception that I know of is the Venue Medley environment, which normally 
 saves the entire Lisp world when you end a session. Medley also keeps track of new definitions created in 
 the listener and allows you to save just those definitions to a file.) 
  
 In a file-based Lisp environment, you’ll normally add definitions to a file of source code. One reason for 
 so doing is to periodically save your work; unless you’re debugging FFI code or running buggy Lisp code 
 with a low optimization value for safety, your Lisp environment will almost never crash. However, other 
 disasters can happen -- another application could crash and bring down the system in an unprotected OS 
 such as the Mac OS or Windows, the power could fail, or your cat could walk across the keyboard when 
 you leave to refill your coffee. 
  
 As your program gets larger, you may find that it’s useful to reload an entire source file after making a 
 series of changes. Most Lisp environments also let you evaluate one definition at a time in any open 
 window. This is quite useful because you can edit, then recompile, one definition at a time. But sometimes 
 you’ll forget, and then it’s easier to just reload the entire file than to spend time figuring out which 
 definition you might have forgotten to recompile after last changing its definition. 
  
 But you may also be in the midst of debugging your program when you’d like to reload its source code. If 
 your program uses any global variables to keep track of its state, you really 
 don’t
  want to reinitialize these 
 in the midst of your debugging session. So, how do you handle this? You could put definitions of your 
 program’s state variables in a separate file, but that increases your mental workload and increases 
 debugging time by splitting clearly interrelated parts of your program into two separate files. (I know that 
 this is an accepted practice in many programming languages, but it really does increase the amount of 
 work you do as a programmer. Imagine how much less pleasurable reading a novel would be if the novel 
 was delivered as a set of pamphlets, one per character, and you had to follow page references to get to the 
 next part of the dialog.) 
  
 Fortunately, Lisp has grown through decades of real-world programming experience, and has a very simple 
 mechanism to handle whether variables get reinitialized or not when you load a file. You use 
 DEFVAR
  to 
 declare variables with values that need to be initialized only once. To declare a variable with
  
 233",NA
Define constants with DEFCONSTANT,"You should define global constants using 
 DEFCONSTANT
 . From the viewpoint of reading a Lisp program, 
 the distinction between 
 DEFPARAMETER
  and 
 DEFCONSTANT
  is that the value defined by 
 DEFPARAMETER
  could concievably be altered by the user after the program is compiled, but a 
 DEFCONSTANT
  value will 
 never
  change. A good Lisp compiler will take advantage of 
 DEFCONSTANT 
 declarations to perform classical optimizations such as constant folding or compiling immediate load 
 instructions. 
  
 Fewer Lisp programmers follow a naming convention for constants. The one I use puts a leading and 
 trailing plus sign on the name of the constant, as in 
 +RTS-OPCODE+
 .",NA
Know when (not) to use the compiler,"Most Lisp systems include both an interpreter and a compiler; when both are available, you’ll normally 
 find that it’s easier to debug interpreted code. Consult your vendor’s documentation to learn how to switch 
 between the interpreter and the compiler. 
  
 Of course, when performance is important, you’ll want to run your code compiled once it’s debugged. But 
 see the earlier cautions about running buggy code with low safety settings. 
  
 When you’re writing Lisp code to run on multiple platforms, it’s safest to assume that code will run 
 interpreted unless you call 
 COMPILE
  or 
 COMPILE-FILE
 . For this reason, you should develop the 
 practice of writing (or using) a system definition procedure that first loads all of your Lisp source files, 
 then compiles them, then loads the compiled files. This is usually overkill, but it’s a very safe, 
 conservative approach. With suitable source code organization and proper use of 
 EVAL-WHEN
  you can 
 reduce the number of source files that must first be loaded; the main idea is to ensure that all macros are 
 defined before compiling code that uses the macros, but there are other possible situations that can depend 
 upon the current state of the Lisp world.",NA
Speed vs. ability to debug,"Interpreted programs are easier to debug because it’s easier for the debugger to access the actual source 
 code at the point of an error. Once you’ve compiled your program, the debugger typically has less source 
 information available; you may find yourself puzzling over a transformed version of the source code or 
 grovelling through assembly-language instructions to find the source of the error. Fortunately, the need for 
 such low-level debugging will be rare if you follow some simple advice: 
  
 234",NA
"Efficiency: spotting it, testing it","The first rule of efficiency in any programming language is to start with an efficient algorithm. It’s a little 
 harder to spot inefficiencies in a Lisp program because the underlying operations don’t usually map 
 directly onto a hardware instruction. But with a certain amount of knowledge and practice, you should be 
 able to tell why the following four programs have radically different resource requirements. 
  
 These four programs return the sum of a list of numbers, but do it in different ways. In each case, we test 
 the program with the 
 TIME
  form, which reports run time and memory allocation. Each program is tested 
 twice, once with a list of ten thousand elements, then again with one hundred thousand. 
  
 ;; Runtime increases as the square of the number of elements 
  
 ? (defun sum-list-bad-1 (list)
  
  (let ((result 0))
  
  
  (dotimes (i (length list))
  
  
   
  (incf result (elt list i)))
  
  
  result)) 
  
 SUM-LIST-BAD-1 
  
 ? (let ((list (make-list 10000 :initial-element 1)))
  
  (time (sum-list-bad-1 list))) 
  
 (SUM-LIST-BAD-1 LIST) took 2,199 milliseconds (2.199 seconds) to run.
  
 Of that, 102 milliseconds (0.102 seconds) were spent in The Cooperative Multitasking Experience. 
 16 bytes of memory allocated.
  
 10000 
  
 ? (let ((list (make-list 100000 :initial-element 1)))
  
  (time (sum-list-bad-1 list))) 
  
 (SUM-LIST-BAD-1 LIST) took 336,650 milliseconds (336.650 seconds) to run.
  
 Of that, 15,680 milliseconds (15.680 seconds) were spent in The Cooperative Multitasking Experience. 
 2,704 bytes of memory allocated.
  
 100000
  
 ;; Recursive version works when compiler does tail-call optimization 
 ? 
 (defun sum-list-bad-2 (list)
  
  (labels ((do-sum (rest-list sum)
  
  
   
  (if (null rest-list)
  
  
   
  
  sum
  
  
   
  
  (do-sum (rest rest-list) (+ sum (first rest-list))))))
  
  (do-sum list 0))) 
  
 SUM-LIST-BAD-2 
  
 ? (let ((list (make-list 10000 :initial-element 1)))
  
  (time (sum-list-bad-2 list))) 
  
 (SUM-LIST-BAD-2 LIST) took 2 milliseconds (0.002 seconds) to run.
  
 10000 
  
 ? (let ((list (make-list 100000 :initial-element 1)))
  
  (time (sum-list-bad-2 list))) 
  
 (SUM-LIST-BAD-2 LIST) took 21 milliseconds (0.021 seconds) to run.
  
 100000
  
 235",NA
"Recognizing inefficiency, profiling; performance vs. ",NA,NA
readability,"Avoidance is the best defense against inefficiency. Use appropriate data structures and control techniques. 
 When you’re not sure, put together a 
 small
  test program and time it with a variety of inputs. 
  
 Every Common Lisp implementation will have the 
 TIME
  macro that we used to show the differences in 
 the 
 SUM-LIST-
 xxx
  functions. You can use this to examine and tune small portions of a program. 
  
 Once you have assembled a larger program, you may need to find the bottleneck that causes unexpectedly 
 low performance. For this, you’ll need a profiler. A profiler watches the execution of your whole program 
 and generates a report to show where the program spends its time. Some profilers also report on memory 
 allocation. A profiler is not a standard part of Lisp, but most vendors provide one. Consult your vendor’s 
 documentation. 
  
 Lisp provides abstractions that help you solve problems. You’ll find that you don’t have to make a 
 tradeoff between readability and performance; an efficient Lisp program is usually one that is written 
 using the most appropriate abstractions and operations to solve a given problem. 
  
 237",NA
Chapter 29 - I Thought it was Your Turn to Take Out ,NA,NA
the Garbage,"Chapter objective: Describe the benefits and costs of garbage collection. Show how to improve program 
 performance by reducing the amount of garbage it generates.",NA
What is garbage?,"In simplest terms, garbage is any storage that your program once used, but uses no longer. Here’s a simple 
 example: 
  
 (let ((x (list 1 2 3 4 5)))
  
  (print x))
  
 When you evaluate this form, the list 
 ’(1 2 3 4 5 6)
  is first bound to 
 X
  and then printed. Once 
 control leaves the 
 LET
  form, the list bound to 
 X
  is no longer accessible; its storage can be reclaimed by the 
 garbage collector. 
  
 Actually, there’s a minor complication that you should know about. When you evaluate a form in the 
 Lisp listener, the form itself is assigned to the symbol 
 +
 , and the value is assigned to the symbol 
 *
 . 
 The previous form and value are assigned to 
 ++
  and 
 **
 , respectively, and the form and value before 
 that are assigned to 
 +++
  and 
 ***
 . Because these three pairs of variables give you a way to access the 
 forms and results, a form and its result can’t really become garbage until you’ve evaluated additional 
 forms to flush these six variables. 
  
 You won’t normally have to worry about this unless you’ve done something in the listener to exhaust 
 all available memory in Lisp; if you can evaluate a simple expression (like 
 T
 ) three times, you’ll 
 release any storage held by 
 +
 , 
 *
 , and friends.",NA
Why is garbage collection important?,"Lisp allocates storage as needed for your program’s data. You don’t have direct control over how or when 
 storage is allocated; the compiler is free to do the best job it can to satisfy the meaning of your program. 
  
 Lisp does not provide a way for your program to explicitly deallocate storage. This is an important feature, 
 because you can never write a program to mistakenly deallocate storage that is still needed elsewhere in 
 the program. This eliminates an entire class of errors, sometimes referred to as ""dead pointer bugs"" in 
 languages that support explicit storage allocation and deallocation. 
  
 On the other hand, your program may eventually run out of memory if your program never deallocates 
 storage. So a language (like Lisp) that doesn’t support explicit deallocation must still provide a mechanism 
 to automatically deallocate storage when the storage is no longer needed. The garbage collector’s job is to 
 figure out which storage can no longer be accessed by your program, and then recycle those inaccessible 
 storage blocks for later use. 
  
 238",NA
How does garbage collection work?,"Lisp compiles your program in such a way that all of its allocated storage can be found by following 
 pointers from a small number of known 
 root
  pointers. The compiler and runtime system arrange for your 
 program to retain type information at runtime; this is combined with compile-time knowledge of storage 
 layouts to encode knowledge of the locations of pointers within data structures. 
  
 The garbage collector follows every pointer in every reachable data structure, starting with the root set. As 
 it does so, it marks the reachable data structures. Once every pointer has been followed, and its referenced 
 data structure marked, any block of memory that is unmarked is unreachable by your program. The 
 garbage collector then reclaims these unmarked blocks for future use by the storage allocator. 
  
 The actual marking algorithm used by the garbage collector must account for cycles in the reachable 
 data structures, and must perform in limited space and time; these details complicate the 
 implementation of a garbage collector. Also, most collectors will relocate the marked data (and adjust 
 references accordingly). [Jones96] [p 255] provides an excellent survey and analysis of various 
 garbage collection techniques.",NA
What effect does garbage have on my program?,"Garbage causes your program to run slower. The more garbage your program creates, the more time the 
 garbage collector will need to spend recycling the garbage. Modern garbage collectors are very efficient; 
 it’s unlikely that you’ll see a noticeable pause in your program’s execution as the garbage collector runs. 
 However, the cumulative effect of many small pauses will cause a detectable degradation in overall 
 performance. 
  
 The good news is that garbage collection ensures that your program will 
 never
  suffer from memory leaks 
 or dead pointers. 
  
 Also, because many garbage collector implementations rearrange storage as your program runs, heap 
 fragmentation is minimized; thus, a large Lisp program’s performance will not degrade over time like a C 
 or C++ program that performs comparable storage allocation (typically 25 to 50 percent degradation for a 
 C or C++ program, depending upon heap size, malloc/free implementation, and allocation/deallocation 
 patterns). 
  
 You should note that explicit storage allocation and deallocation has overheads which are not strictly 
 predictable. In typical malloc and free implementations, block allocation involves a search and 
 deallocation involves extra work to coalesce free blocks; both of these activities are of effectively 
 indeterminate duration, affected by the size and fragmentation of the heap.",NA
How can I reduce garbage collection pauses in my ,NA,NA
program?,239,NA
Chapter 30 - Helpful Hints for Debugging and ,NA,NA
Bug-Proofing,"As with any programming language, error avoidance is the best debugging strategy. Take advantage of the 
 online documentation (available with most systems) and test functions, or even parts of functions, as you 
 write them. 
  
 Still, you’ll inevitably face the unexpected error, and you should know how to use the debugger. More 
 often than not, a quick look at the error location as shown by the debugger will point out an obvious 
 problem. 
  
 Some problems, though, are not obvious; your program will run without error, but produce incorrect 
 results. When examination of the code does not reveal an error, you can rely upon built in Lisp tools to 
 expose the details of your program’s operation and find the error during execution.",NA
Finding the cause of an error,"There are two ways to notice an error. The intrusion of the Lisp debugger is the most obvious. The 
 debugger will appear whenever your program causes Lisp to signal an error. This is often the result of 
 something obvious, like trying to perform arithmetic on 
 NIL
  or trying to 
 FUNCALL
  an object that is not a 
 function. 
  
 Your program’s failure to produce expected results is also an error, even though the debugger never 
 appears. In this case, your program doesn’t make any mistakes in its use of Lisp, but the successful 
 sequence of Lisp operations doesn’t do what you had intended. Another possibility is that your program 
 will fail to terminate at all. 
  
 The best defense against all of these problems is to write short, clear function definitions and test each one 
 as soon as you’ve written it. I find it helpful to write one or more test cases and include them as comments 
 (bracketed by #| and |#) in the same file.",NA
"Reading backtraces, compiler settings for debugging","Every Lisp debugger will provide at least two important pieces of information: an error message and a 
 stack backtrace. 
  
 The error message describes 
 how
  the program failed. Normally, this is a description of an error 
 encountered while executing some built in Lisp function. If your program calls 
 ERROR
 , the debugger will 
 display the message you specify. 
  
 The stack backtrace describes 
 where
  your program failed by displaying the call stack at the point of the 
 error. The function which signalled the error will be at the ""top"" of the stack. Below that is the function 
 that called the function which signalled the error, and so on all the way to (and sometimes beyond) the 
 listener’s read-eval-print loop. 
  
 241",NA
Simple debugging tools,"If your program runs to completion but produces incorrect results, or if it runs but fails to terminate, then 
 you’ll need some additional tools. The first of these tools should be familiar to all programmers: insert a 
 call to the debugger or (more commonly) insert a print statement.",NA
"BREAK, PRINT","BREAK
  causes your program to call the debugger. Once inside the debugger you can examine the call 
 stack. Most debuggers also allow you to examine values local to each active function on the call stack; by 
 looking at these values at a critical point during your program’s execution, you may find an important clue 
 as to why your program malfunctions. 
  
 The debugger will allow you to continue from a break. You may find it helpful -- if you don’t yet 
 understand the cause of a problem -- to correct one or more wrong values before continuing; with other 
 BREAK
  forms inserted at key points in your program, this strategy may lead you to a place where the error 
 is
  apparent. 
  
 Of course, you can always insert 
 PRINT
  forms at key locations in your program and examine the resulting 
 output. In Lisp, this is most useful when you need to get a feel for what’s happening deep inside some 
 function. For example, you might have a complex calculation to determine whether a sequence of code is 
 executed or not. A 
 PRINT
  can tell you as the program runs. 
  
 Don’t forget that you can use 
 FORMAT
  to print the values of several variables together with explanatory 
 text. And with either 
 PRINT
  or 
 FORMAT
 , be careful that you do not change the meaning of the code by 
 inserting the debugging statement. Remember that some flow-control forms (e.g. 
 IF
  and 
 UNWIND-
 PROTECT
 ) expect a single form at certain places. Also beware of wrapping 
 PRINT
  around a value-
 returning form; this won’t work if the value-receiving form expects multiple values. 
  
 242",NA
Power tools for tough problems,Lisp provides additional debugging tools to help you observe the dynamic behavior of your program.,NA
"TRACE, STEP, ADVISE, WATCH","TRACE
  allows you to observe each call and return from a specific function, no matter where the function 
 appears in your program. To trace a function, invoke 
 TRACE
  with the name of the function. You can do 
 this for as many functions as needed. You can also pass several function names to 
 TRACE
 . 
  
 When your program runs a traced function, it will print the name of the function on entry and exit. Most 
 TRACE
  implementations will also print the function arguments on entry and returned values on exit. 
  
 To discontinue tracing of a function, pass its name to 
 UNTRACE
 . To discontinue tracing of 
 all
  traced 
 functions, evaluate 
 (UNTRACE)
 . 
  
 See Chapter 16 for an example of 
 TRACE
 . 
  
 STEP
  allows you to interactively control evaluation of an expression. If you step a function invocation, 
 you should be able to examine each subform of the function’s definition just before it is evaluated. 
 STEP 
 implementations vary widely, so you should consult your vendor’s documentation for further details. In 
 general, the same optimizations and controls that aid the debugger will also aid the stepper. 
  
 STEP
  is a very labor-intensive way to debug a program, since you must tell its user interface to evaluate 
 each subform. This is reasonable for straight-line code, but quickly becomes tedious in the presence of 
 looping or recursion. 
  
 Some Lisp implementations provide two additional tools, 
 ADVISE
  and 
 WATCH
 , that can be of use during 
 debugging. 
  
 ADVISE
  modifies a function without changing its source code. 
 ADVISE
  can usually examine the advised 
 function’s arguments, execute its own code, execute the advised function, examine the advised function’s 
 return values, and modify the returned values. For debugging purposes, 
 ADVISE
  can be used to 
 implement conditional 
 BREAK
 s and 
 TRACE
 s, or to temporarily patch incorrect behavior in one part of a 
 program while you’re debugging another part. 
  
 WATCH
  lets you specify variables to be displayed as your program executes. This is normally available 
 only in Lisp implementations that provide a windowed user interface. Because of issues of variable scope 
 and display update timing and overhead, 
 WATCH
  is of limited value. Most Lisp implementations do not 
 provide this tool.",NA
Into the belly of the beast,"As you debug your program, you may need to see the internal details of composite objects such as lists, 
 structures, arrays, streams and CLOS instances. Lisp lets you do this whether the data has been defined by 
 your program or by the Lisp runtime system. 
  
 243",NA
"INSPECT, DESCRIBE","DESCRIBE
  is a function that accepts any object as an argument and prints a description of that object. The 
 form and content of the description may vary among Lisp implementations. 
 DESCRIBE
  accepts an output 
 stream as an optional second argument. 
  
 INSPECT
  is an interactive version of 
 DESCRIBE
 . This is most useful for examining complex objects by 
 ""drilling down"" into the implementation details of enclosed data elements.",NA
Continuing from an error,"When faced with the debugger, you will have a choice of restart actions depending upon how the error was 
 signalled. 
 ERROR
  requires that you abandon your program’s executions. However, many internal Lisp 
 functions use 
 CERROR
 , which gives you a chance to continue from an error. 
  
 In most debuggers, you can do quite a few useful things before continuing from an error: 
  
  
  
  
  
  
 alter variable values 
  
 redefine the function that caused the error and run it again 
  
 skip the rest of the function that caused the error and specify values to be returned restart 
 any function further down the call stack 
  
 skip the rest of any function further down the call stack and specify values to be returned",NA
Problems with unwanted definitions,"Unwanted definitions are not usually a problem in a Lisp program. You can get rid of function definitions 
 using 
 FMAKUNBOUND
 , variable values with 
 MAKUNBOUND
 , and even symbols with 
 UNINTERN
 . In 
 practice, there’s usually no need to use any of these; available memory is commonly large compared to the 
 size of a few misdefined variables or functions, and they will be eliminated anyway the next time you 
 restart your Lisp image and load your program. 
  
 Method definitions are an entirely different matter. Remember that methods must have congruent 
 argument lists; if you change your mind during program development about a method’s argument list --
 perhaps you thought that it needed two arguments at first but then realized three arguments are really 
 needed -- then you’ll have to remove the old method definition before adding the new one. Some Lisp 
 environments facilitate this redefinition: 
  
 ? (defmethod baz (a b)) 
  
 #<STANDARD-METHOD BAZ (T T)> 
  
 ? (defmethod baz (a b c)) 
  
 Error: Incompatible lambda list in #<STANDARD-METHOD BAZ (T T T)>
  
  for #<STANDARD-GENERIC-FUNCTION BAZ #x3D2CB66>.
  
 Restart options:
  
  1. Remove 1 method from the generic-function and change its lambda list 
 2. Top levl
  
  ?
  
 244",NA
Package problems; method definitions,"Symbol conflicts across packages can be frustrating during development. If you have defined multiple 
 packages for your program, you’ll need to be careful to set the proper package (using 
 IN-PACKAGE
 ) 
 before defining an object intended for that package. If you inadvertently create an object in the wrong 
 package and then attempt to define it in the correct package, Lisp will signal an error if there is a ""uses"" 
 relationship between the two packages. The proper response is to first remove the erroneous definition 
 using 
 UNINTERN
 . 
  
 You can also get into trouble with packages by having unexported classes defined in two packages and 
 specializing a method based on the wrong class.",NA
The problem with macros,"Macros must always be defined before use. This is especially important when you redefine a macro during 
 development: every piece of code that uses the redefined macro 
 must
  be recompiled. You can help 
 yourself avoid macro redefinition problems by reloading your source code after redefining any macro(s).",NA
"Runtime tests catch ""can’t happen cases"" when they do...","When I read code, finding the phrase ""can’t happen"" in a comment always raises a red flag. Usually, this 
 statement is made after the programmer has examined the code’s execution environment and intended use. 
 Unfortunately, things change and ""can’t happen"" cases do happen. 
  
 Lisp provides a very handy facility for checking ""can’t happen"" statements at runtime. The 
 ASSERT 
 macro expects a form that will evaluate to true at runtime. If the form evaluates to 
 NIL
  instead, 
 ASSERT 
 signals a continuable error, transferring control to the debugger. At the very least, this will help you to 
 learn which assertion was violated so you can correct your program. 
  
 245",NA
Use method dispatch rather than case dispatch,"When your program needs to make a decision based on the type of an object, you have two choices. You 
 can use 
 TYPECASE
  or 
 DEFMETHOD
 . Unless you have a circumstance that particularly warrants the use of 
 TYPECASE
  (or its variants 
 CTYPECASE
  and 
 ETYPECASE
 ) -- and especially if the set of types will change 
 during normal program evolution or maintenance -- you should probably construct your program to operate 
 on the individual types via generic functions. This more clearly exposes the intent of the program and 
 eliminates the likelihood that you will forget to update a 
 TYPECASE
  form during maintenance. 
  
 246",NA
Chapter 31 - Handling Large Projects in Lisp,"This book is primarily a tutorial, designed to give you enough of an understanding of Lisp to get started 
 writing your own programs. Eventually, you’ll find yourself in a situation where you need to collaborate 
 with other programmers to implement a larger system. The strategies and tools used to organize Lisp 
 programs for large projects and team efforts are similar to those used for other languages. The main 
 difference is that the coordination tools are part of the same environment in which you develop your 
 program.",NA
Packages keep your names separate from my names,"One of the first concerns in group development is to avoid namespace collisions. You don’t want to have 
 to poll all the other programmers to make sure that no one has already used the name you’re planning to 
 give the routine you’re about to write. That would interrupt not only your train of thought, but all the 
 programmers’ as well. The alternative -- to ignore the namespace problem and resolve collisions during 
 integration -- is even more unappealing. 
  
 One tried and true approach, used in many organizations, is to give every subsystem a unique prefix for its 
 exported names. Your job as a programmer is to tack the proper prefix onto the name of each routine you 
 write for a given subsystem. Like other approaches, this is both annoying and fragile. Prefixes tend to be 
 abbreviations (to save typing); system designers tend to be particularly bad at anticipating future 
 developments -- eventually, you’ll have to make exceptions to the prefix naming rule to accommodate 
 new development, and with the exceptions comes the extra mental effort of keeping track of another piece 
 of information which has nothing to do with solving a problem. 
  
 Object-based languages at least give you a class scope for naming, but this only pushes the conflict-
 avoidance strategy somewhere else. 
  
 Lisp’s package system (see Chapter 3, Lesson 10) lets you partition namespaces independent of other 
 language constructs. If you really want to give each programmer the freedom to create without the 
 overhead of coordinating on matters unrelated to problem-solving, you can give each programmer her own 
 package. As the subsystems are completed, you can integrate by referring to the qualified names of the 
 public APIs of each subsystem. Using this approach, there’s no cognitive overhead during subsystem 
 construction, no rework needed during integration, and no runtime overhead in the delivered product. 
  
 The keyword package (remember that keywords are symbols with the empty package name, such as 
 :FOO
 ) 
 is useful for symbols that are used only for their identity. Without associated code or data, a symbol can 
 readily be shared across all subsystems.",NA
System builders let you describe dependencies,"Lisp does not yet have a standard declarative way to describe the process of building a system from its 
 source files. Most projects use one of two approaches: 
  
 247",NA
Source control systems keep track of multiple revisions,"Did you ever change a file, save it, and then discover that you had broken something so badly that you 
 wanted to go back to the previous version of the file and start over? A source code control system can help 
 you do this. 
  
 There is no standard for source code control in Lisp, nor is there likely to be any time soon. Source code 
 control systems are typically provided as an essential programming tool independent of the Lisp 
 environment. Some Lisp vendors offer a way to operate the source code control system from the Lisp 
 environment. 
  
 For projects involving more than one programmer, a source code control system offers additional benefits; 
 most such systems allow a programmer to 
 reserve
  a file which she intends to edit. A reserved file can’t be 
 edited by any other programmer. Furthermore, the process of reserving a file usually creates a local 
 editable copy for the programmer making the changes; the other programmers see the previous, unedited 
 copy of the file. When the programmer completes (and, of course, tests) the changes, she returns the 
 completed file to the source code control system, which makes the file’s new contents available to all the 
 programmers and allows anyone to reserve the file for a new round of updates. 
  
 I highly recommend that you take the time to locate and use a source code control system. The effort will 
 pay dividends in the time you don’t spend recovering from lost source code changes.",NA
Modules: another way to describe file dependencies,"Lisp actually does have a rudimentary system of maintaining file dependencies. I didn’t mention the 
 module system earlier because it is deprecated; it might be removed, replaced, or augmented in some 
 future revision of the Lisp specification. I also didn’t mention the module system because it has quite 
 limited expressive power. The module system is best suited for finished, stable systems; it does not have 
 enough functionality to support incremental program development in a useful manner. Given all these
  
 248",NA
PROVIDE and REQUIRE,"PROVIDE
  and 
 REQUIRE
  are the sole standardized interface to Lisp’s module system. A 
 (REQUIRE 
 name
 )
  form tells Lisp to see whether the file associated with 
 name
  has already been loaded; if so, 
 REQUIRE
  does nothing, otherwise it loads the file. The loaded file must at some point include a top level 
 form 
 (PROVIDE
 name
 )
 ; this informs the module system that the module associated with 
 name
  has been 
 loaded. 
  
 The means by which the Lisp system locates the file according to 
 name
  is implementation-dependent; 
 usually the name maps onto a source or object file in the current directory. 
  
 The biggest problem with this module system is that it is not designed to handle incremental program 
 changes; it is better suited for loading a completed, stable system. Once a 
 REQUIRE
 d file is loaded, it will 
 never be reloaded. (Your vendor may give you enough information to override this behavior, but you can’t 
 depend on it.) 
  
 Of course, if you use an ad-hoc loader or a 
 DEFSYSTEM
  during program development, there is little 
 reason to not to deliver the system using the same approach to loading. Better yet, some Lisp 
 environments let you dump an image of your Lisp world, which lets you load the system without having 
 source or object files at all. Either way, there is no good reason to use 
 PROVIDE
  and 
 REQUIRE
 . 
  
 249",NA
Chapter 32 - Dark Corners and Curiosities,"This chapter is almost at the end of our survey of Lisp. Here, we’ll examine some Lisp features that are 
 newer, unstandardized, experimental, or controversial.",NA
Extended LOOP: Another little language,"Chapter 5 described several iterative control forms: 
 DO
 , 
 DOTIMES
 , 
 DOLIST
 , and a simple 
 LOOP
 . We also 
 saw that 
 FORMAT
  (Chapter 24) has its own control constructs for iteration. 
  
 Recursion is a useful tool for describing (and implementing) some algorithms. But in many cases it’s 
 easier to write efficient iterative code than it is to write efficient recursive code. In chapters 4 and 28 we 
 saw how to write tail-recursive code, and learned that Lisp is 
 not
  required to optimize tail calls. Ironically, 
 iteration is very important in this implementation of a language originally conceived as a notation for 
 recursive functions [p 256] . 
  
 An 
 extended
  loop facility was introduced late in the specification of Common Lisp. Extended loop, like 
 FORMAT
  control strings, breaks away from the Lisp tradition of a simple, consistent syntax. Extended loop 
 uses keywords to specify initialization, actions and termination conditions. Here are a few examples: 
  
 ;; Sum the integers from 1 to 100 
  
 ? (loop for n from 1 to 100
  
  
  sum n) 
  
 5050
  
 ;; Compute factorial 10 iteratively 
  
 ? (loop for n from 1 to 10
  
  
  with result = 1
  
  
  do (setq result (* result n))
  
  
  finally return result) 
  
 3628800
  
 ;; Gather the even numbers from a list 
  
 ? (loop for item in ’(1 5 8 9 7 2 3)
  
  
  when (evenp item)
  
  
  collect item) 
  
 (8 2)
  
 Extended loop inspires heated disagreements among Lisp users. Its detractors point out that the behavior is 
 underspecified for complex combinations of options, while its supporters point out that extended loop 
 forms are easier to read than most 
 DO
  forms for simple operations. You should heed the advice of both 
 camps: use extended loop to improve readability of simple looping operations.",NA
TAGBODY: GO if you must,"Ever since the structured programming revolution of the 1970’s, programmers and language designers alike 
 have been apologetic about the 
 GOTO
  construct. Yet there are rare cases where a well-placed 
 GOTO
 , used 
 with careful consideration, is the clearest way to structure the control flow of an algorithm. 
  
 250",NA
Processes & Stack Groups: Juggling multiple tasks,"Leading-edge Lisp systems on dedicated hardware, and more recently on the Unix platform, have 
 implemented a feature called ""lightweight processes."" In the C world these are known as ""threads."" 
  
 Lightweight processes allow you to write pieces of code which share the CPU’s time along with all of the 
 global variables in your LISP environment. Although this is a limited form of multitasking, lacking 
 protection between processes, it is very useful for handling computations which must run ""in the 
 background"" or in response to asynchronous events. 
  
 In the last few years, low-cost Lisp systems have started to include a process facility. Of all the vendors of 
 low-cost Lisp system, Digitool was the first to include processes in its product. Starting with its 4.0/3.1 
 release, MCL includes a complete implementation of lightweight processes including a full range of 
 control, synchronization, and communication abstractions. MCL’s process API is very close to the API 
 used on the Lisp machines. I’ll use MCL’s API to illustrate the rest of this section. 
  
 The MCL processes are fully preemptive -- you can set both priority and time slice (the ""quantum"") for 
 each process. Each process can have private variables simply by using local variables in the process run 
 function (i.e., Lisp ""closures""). As you’ll probably have a need to access shared data as well, the MCL 
 process facility provides locks (""mutexes"") to ensure access to critical data by only one process at a time; 
 this is especially useful when multiple fields of a complex structure must be updated in a single operation 
 (""atomically""). 
  
 The following code implements a solution to Dijkstra’s [p 256] ""dining philosophers"" problem using MCL 
 processes and locks. In case you’re not familiar with this, imagine a group of philosophers seated around a 
 round table. Each philosopher has a plate of food. The food can only be eaten if a philosopher holds a fork 
 in each hand. There is a fork between each pair of philosophers, so there are exactly as many forks as there 
 are philosophers. The objective is to make the philosophers behave so that they all get a fair chance to eat. 
 The classic solution imposes a protocol on how resources (forks) are acquired, in order to prevent 
 deadlock (starvation). 
  
 (defstruct philosopher
  
  (amount-eaten 0)
  
  (task nil))
  
 (defmacro acquire-lock-or-skip (lock post-acquire pre-release &body body)
  
  ‘(progn
  
 ;; Random sleep makes the output more interesting
  
 ;; by introducing variability into the order of
  
 ;; execution.  This is a simple way of simulating
  
 ;; the nondeterminacy that would result from having
  
 ;; additional processes compete for CPU cycles.
  
  (sleep (random 5))
  
  (unless (lock-owner ,lock)
  
  
  (process-lock ,lock)
  
 251",NA
Series: Another approach to iteration and filtering,"Series were formally introduced with the printing of Common Lisp: The Language (2nd ed) [p 255] (also 
 known as CLtL2), but were not adopted as part of the ANSI Common Lisp standard. Still, some Lisp 
 vendors include series in their product because customers came to depend upon it during the time between 
 the publication of CLtL2 and the ANSI Specification. 
  
 Series combine the behaviors of sequences, streams and loops. Using series, you can write iterative code 
 using a functional notation. Control is achieved by selecting or filtering elements as they pass through a 
 series
  of filters and operators. 
  
 The best place to find information and examples is in Appendix A of CLtL2. 
  
 254",NA
Chapter 33 - Where to Go Next,"I hope that this book has whetted your appetite for Lisp. If so, you’ll want to explore further; this chapter 
 provides pointers to other sources of information and products.",NA
Suggestions for further reading,"The Art of the Metaobject Protocol, Kiczales et al, MIT Press, 1991, ISBN 0-262-61074-4 
  
 This is the definitive text on the metaobject protocol, referred to in Lisp circles as ""AMOP."" This is 
 not
  light reading; save it for when you feel quite confident in your Lisp abilities. 
  
 ANSI Common Lisp, Graham, 1996, Prentice-Hall, ISBN 0-13-370875-6 
  
  
 This is a good refresher for an experienced Lisp programmer, as well as being an excellent second 
  
 text for the beginner. (I think it’s a bit too terse to use as a first text for a beginner, but you may want 
  
 to look at it and see whether you think it’s approachable.) 
  
 On Lisp: Advanced Techniques for Common Lisp, Graham, Prentice Hall, 1994, ISBN 0-13-030552-9 
  
 This 
 has become the canonical reference for macro techniques. 
  
 Object-Oriented Programming in Common Lisp: A Programmer’s Guide to CLOS, Keene, 1989, Addison-
 Wesley, ISBN 0-201-17589-4 
  
  
 Keene’s book is quite simply 
 the
  book to read when you want to understand CLOS. It’s short, and it 
  
 covers all of the essentials. Its best feature is its profuse application of real-world examples. 
  
 Understanding CLOS: The Common Lisp Object System, Lawless & Miller, 1991, Digital Press, ISBN 1-
 55558-064-5 
  
  
 Lawless and Miller’s book covers more of CLOS than Keene’s book, but the treatment is closer to a 
  
 reference than a tutorial. 
  
 Common Lisp: The Language, 2nd Ed., Steele, 1990, Digital Press, ISBN 1-55558-041-6 
  
 Dubbed ""CLtL2,"" this was an interim interpretation of the work of the ANSI standardization 
 committee. It has no standing as part of the standards process, but was used by many Lisp vendors to 
 anticipate the final outcome of the committee’s work. Some Lisp systems still implement portions of 
 both the CLtL2 description and the ANSI standard. 
  
 Garbage Collection: Algorithms for Automatic Dynamic Memory Management, Jones et al, 1996, Wiley, 
 ISBN 0-471-94184-4 
  
  
 This is an excellent reference covering all aspects of dynamic storage allocation techniques. 
  
 Object-Oriented Common Lisp, Slade, 1998, Prentice-Hall, ISBN 0-13-605940-6 
  
 Slade’s book is probably the best book available on actually 
 using
  a Common Lisp environment for 
 something other than AI programming. I think it’s suitable for a beginner, but should probably be 
 supplemented by another title that provides better insight into the Lisp language. 
  
 Common LISPcraft, Wilensky, 1986, W.W. Norton & Co., ISBN 0-393-95544-3 
  
 When I was first learning Common Lisp, I found Wilensky’s book the most helpful at exposing some 
 of Lisp’s unique concepts, such as closures. This book is easy to read (without being patronizing) and 
 includes a lot of very clear examples. There’s also a brief Common Lisp reference in the appendix. I 
 still recommend this as a first book for beginners. 
  
 255",NA
Historical References,"Cooperating Sequential Processes, Dijkstra, pp. 43-112 in Programming Languages, Genuys (ed.), 
 Academic Press, 1968. 
  
 Dijkstra described the techniques used for process coordination. The dining philosophers problem is 
 one of Dijkstra’s examples of process coordination when resources must be shared. 
  
 Recursive Functions of Symbolic Expressions, J. McCarthy, CACM, 3, 4, 1960, ppg. 184-195. 
  
 This is McCarthy’s seminal Lisp paper. (Available online in various formats at his web site: 
 http://www-formal.stanford.edu/jmc/index.html (http://www-formal.stanford.edu/jmc/index.html))",NA
On-line sources,"The Association of Lisp Users (http://www.lisp.org/) 
  
  
 Information on conferences, jobs, implementations, etc. 
  
 Common Lisp HyperSpec (TM) (http://www.xanalys.com/software_tools/reference/HyperSpec/) A 
 hypertext version of the ANSI Common Lisp standard (ftp://parcftp.xerox.com/pub/cl/dpANS3/) , 
 constructed by Kent Pittman and hosted by XANALYS (formerly Harlequin, Inc.). 
  
 MetaObject Protocol (http://www.lisp.org/mop/index.html) 
  
 Not a part of the Common Lisp standard, the MetaObject Protocol is widely supported as a interface to 
 the mechanism underlying CLOS.",NA
Commercial vendors,"Digitool, Inc. Home Page (http://www.digitool.com/) 
  
 Digitool provides both 68K and PPC versions of Macintosh Common Lisp, a world-class Lisp 
 development system. 
  
 The Franz Inc. Home Page (http://www.franz.com/) 
  
 Franz makes Common Lisp compilers for Unix and Windows. They have trial versions for Windows 
 and Linux. 
  
 XANALYS (http://www.harlequin.com/) 
  
 XANALYS (formerly Harlequin) ofers a free Lisp interpreter based upon their LispWorks 
 environment. 
  
 256",NA
"Chapter 34 - Lisp History, or: Origins of ",NA,NA
Misunderstandings,"I’d like to conclude this book with a short history of Lisp’s development, providing insights to some 
 lingering misconceptions about Lisp.",NA
John McCarthy’s Notation,"In the late 1950s, John McCarthy had proposed a mathematical notation to describe recursive functions of 
 symbolic expressions. At this point, McCarthy clearly envisioned a notation rather than a programming 
 language.",NA
Earliest implementations,"A couple years later Steve Russell, one of McCarthy’s students at MIT, noticed that McCarthy’s notation 
 would be easy to interpret on a computer, and LISP was born. While working on an international standards 
 committee to define Algol-60, McCarthy proposed numerous innovations which were not adopted. 
 Perhaps these rejections prompted McCarthy to gather his ideas into what would become Lisp. By late 
 1959, the first complete Lisp interpreter was in use at MIT.",NA
Special hardware,"In the early days, Lisp consistently outstripped the resources of its host machines -- mainframes and 
 minicomputers having memory spaces measured in tens of kilobytes and instruction cycle times measured 
 in microseconds. This prompted Lisp researchers to develop specialized hardware for Lisp program 
 execution. These machines, called ""Lisp Machines"" (or LispMs) spawned an entire industry that rose in 
 the 1970s and fell during the 1980s. This industry, and not the personal computer industry, was the first to 
 sell personal interactive computers having windowed user interfaces.",NA
Diverging dialects,"Concurrent with the rise of the LispM industry, many researchers -- put off by the high costs of the 
 specialized hardware -- engaged in the development of Lisp implementations for stock hardware. This was 
 a time of great diversity and innovation. However, the profusion of dialects prevented researchers from 
 readily sharing their work.",NA
The DARPA directive,"DARPA, the Defense Advanced Research Projects Agency, was (and still is) the funding source for much 
 of the Lisp and AI research community. Seeing the problems caused by the explosion in the number of 
 distinct Lisp dialects, DARPA sponsored a project to develop a unified Common Lisp specification. 
  
 257",NA
"East vs. West, and European competition","Despite the large number of competing dialects at this time, two were clearly dominant. On the West 
 coast, Interlisp became the standard, with its emphasis on programming aids and tools, such as the aptly 
 named ""Do What I Mean."" On the East coast, MACLISP was de rigueur, with its focus on low-level 
 system programming access and an efficient compiler. 
  
 The Common Lisp effort raised animosities between the two camps, causing most of the Interlisp 
 advocates to withdraw. Also, political forces in Europe prompted the formation of additional 
 standardization efforts, leading to the development of at least one competing (although quite 
 unsuccessfully) standard.",NA
The emergence of compilers for stock hardware,"As work began in earnest on the Common Lisp standard, vendors -- most of whom had employees on the 
 standardization committee -- were quick to implement the recommendations under discussion. One of the 
 biggest benefits was the definition of the interface to and behavior of the Lisp compiler; this, together with 
 advances in compiler and garbage collector technology, was a first step toward making Lisp competitive 
 in the arena of general-purpose programming languages.",NA
The long road to standardization,"The committee produced the first public edition of the Common LISP specification in 1984. In a shining 
 example of computer mediated cooperative work, hundreds of LISP users and implementers exchanged 
 thousands of email messages to propose, debate, and vote upon each feature of the new language. Each 
 topic and issue was carefully categorized, indexed, and cross-referenced. Very few areas were ambiguous 
 or inadequately specified. Because of the extensive electronic record of the committee’s discussions, these 
 remaining areas were clearly identified and served as a basis for continuing work by the committee. An 
 interim report of the committee’s work was published in late 1990, and a draft proposed ANSI standard 
 was published in 1992. The X3.226 ANSI Common Lisp standard was finalized in December 1994, and 
 formally published about a year later.",NA
State of the Art?,"Lisp has been around in various forms for over forty years. Fortunately, many improvements have been 
 made during that time. Unfortunately, quite a few people in education and industry still think of Lisp as it 
 was twenty or more years in the past. 
  
 Today, commercial Lisp implementations have compilers that compete successfully against compilers for 
 lower-level languages such as C and C++. At the same time, C++ has failed to increase its expressive 
 power in a way that competes successfully with Common Lisp. 
  
 Java, a newcomer, makes some interesting (yet unfulfilled) promises about portability and security. Java 
 has strengths in the areas of system integration, but struggles with performance and reliability. I believe 
 that Java will carve out a niche for itself only by sacrificing some of its stated goals -- which ones remain
  
 258",NA
Appendix A - Successful Lisp Applications,"Lisp is used to build applications in which the underlying data is complex and highly dynamic, and where 
 symbolic manipulation is a key feature of the application. Lisp is also used in situations where an 
 application must be readily updated and customized. 
  
 You should be aware that Common Lisp is unlikely to become a key component of any commercial 
 operating system in the forseeable future. It is very difficult to merge Lisp storage management techniques 
 with code compiled for traditional pointer-centric languages. Therefore, Lisp must continue to provide its 
 own operating environment. As a Lisp programmer, you should set your expectations accordingly. Once 
 you become facile with Lisp, you’ll tend to use Lisp as a workbench and proving ground for algorithmic 
 ideas and programming utilities both large and small. Just don’t expect to write and sell a small, simple 
 program in Lisp; the size and cost of the runtime system that you must distribute with your program may 
 be prohibitive. 
  
 On the other hand, Lisp excels as a framework for developing large, complex applications. Once past a 
 certain size threshold (for program or data), the fixed overhead of a Lisp environment becomes 
 inconsequential. Also, that rich development environment makes it possible to develop large applications 
 with fewer programmers since much of the algorithmic framework is already provided by Common Lisp’s 
 built-in data types and functions. Knowledgeable Lisp programmers achieve even greater productivity by 
 using Common Lisp to write application specific programming tools and language constructs. 
  
 The message I want you to take away is that learning and using Lisp is a process. Unless the computer 
 software industry undergoes an unexpected (and unlikely) change, having read this book won’t get you a 
 job. However, I’m hoping that what you’ve learned here will forever color your perceptions as to what is 
 possible, and suggest both techniques and ways of thinking that will be helpful to you in building those 
 ""small"" applications like word processors, spreadsheets, and OLTP systems. 
  
 Meanwhile, I’d like to show you some of the more visible applications that people have developed using 
 Lisp. 
  
  
  
  
  
  
  
 Emacs [p 260] 
  
 G2 [p 261] 
  
 AutoCAD [p 261] 
  
 Igor Engraver [p 261] 
  
 Yahoo Store [p 261] 
  
 ... [p 261]",NA
Emacs ,"More programmers are familiar with Emacs than with any other Lisp application. Richard Stallman 
 conceived Emacs as an extensible editor. He wrote his own Lisp interpreter (not a compiler) specifically 
 for the tasks used in editing text - the low-level text manipulation functions are built-in functions of Emacs 
 Lisp. Over the decades, Emacs has grown to accomodate windowing systems and has accumulated a vast 
 library of code to support programming, writing and personal communications. 
  
 260",NA
G2,"Gensym wrote their G2 real-time expert system in Lisp, and later (at greater cost and effort) ported it to C 
 to meet customer expectations. Gensym was able to create a real-time system in Lisp through careful 
 attention to memory allocation; they eliminated unpredictable garbage-collection pauses by simply not 
 generating garbage. (See Chapter 29.)",NA
AutoCAD,"AutoCAD is a large-scale Computer Aided Design application. A complex design can contain thousands 
 or millions of parts having complex hierarchical and semantic relationships. Like many application 
 developers who face similar problems, the AutoCAD developers leaned heavily on Lisp for their tools and 
 techniques.",NA
Igor Engraver,"Igor Engraver, written by a small team of programmers at Noteheads.com, is an editing and publishing 
 system for musical scores. They’ve integrated a direct-manipulation graphical interface with a rule-based 
 system that automatically adjusts the layout to conform to complicated rules to meet the expectations of 
 musicians and publishers alike. If that’s not enough, Engraver can also play your scores using MIDI 
 instruments. Engraver is targeted to professional composers and musicians, who are encouraged to upload 
 their scores to Noteheads’ online e-commerce system for purchase by other musicians. Still want more? 
 Engraver has the slickest software update mechanism you’ll find anywhere: select the Check For Patches 
 menu item and Engraver will connect to the Noteheads server, download any patches it needs, and 
 upgrade itself all in a few tens of seconds, without interrupting work in progress.",NA
Yahoo Store,"Yahoo Store is one of the best high-profile Lisp success stories of the past few years. Paul Graham and his 
 team, working out of an attic loft, built and operated a server-side e-commerce site builder for hundreds of 
 customers using Common Lisp and generic Linux servers. Paul’s venture was so successful that it drew 
 the attention of Yahoo, who saw it as a better tool for their online stores. Paul sold his company to Yahoo 
 for $49 million. An interesting aside is that Paul hired a couple dozen extra programmers during Yahoo’s 
 due diligence investigations, since ""no one would believe that three guys in a loft"" could have done what 
 Paul’s team accomplished with the help of Lisp. Perception is everything...",NA
...,"Each vendor has its own list of success stories. See Chapter 33 for some starting points. 
  
 261",NA
