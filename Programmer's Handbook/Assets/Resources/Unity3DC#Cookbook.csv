Larger Text,Smaller Text,Symbol
Jeff W. Murray,NA,NA
C,NA,NA
#,NA,NA
 ,NA,NA
GaMe,NA,NA
 ,NA,NA
ProGraMMinG ,NA,NA
Cookbook,NA,NA
 ,NA,NA
for,NA,NA
 ,NA,NA
Unity 3D,NA,NA
Contents,"Acknowledgments 
 xiii
 Introduction 
 xv
  1. Making Games the Modular Way 
 1
 1.1 
 Important Programming Concepts.....................................2
 1.1.1 
 Manager and Controller Scripts...............................2
 1.1.2 
 Script Communication.......................................3
 1.1.3 
 Using the Singleton Pattern in Unity...........................5
 1.1.4 
 Inheritance.................................................6
 1.1.5 
 Where to Now? .............................................8
  2. Building the Core Game Framework 
 9
 2.1 
 Controllers and Managers............................................11
 2.1.1 
 Controllers................................................11
 2.1.2 
 Managers .................................................11
 2.2 
 Building the Core Framework Scripts..................................11
 2.2.1 
 BaseGameController.cs .....................................12
 2.2.1.1 
 Script Breakdown ................................14",NA
Acknowledgments,NA,NA
Introduction,NA,NA
Prerequisites,"You can get up and running with the required software for the grand total of zero dollars. 
 Everything you need can be downloaded free of charge with no catches. You may want to 
 consider an upgrade to Unity Pro at some point in the future, to take advantage of some 
 of its advanced features, but to get started all you need to do is grab the free version from 
 the Unity website.
 Unity Free or Unity Pro (available from the Unity store at http://www.unity3d.com)
  
 Unity Free is completely free for anyone or any company making less than 
 $100,000 per year—it may be downloaded for no charge at all, and you don’t even 
 need a credit card. It’s a really sweet deal! We are talking about a fully functional 
 game engine, ready to make 3D or 2D games that may be sold commercially or 
 otherwise. There are no royalties to pay, either.
  
 Unity Pro adds a whole host of professional functionality to the engine, such as 
 render culling and profiling. If you are a company with more than $100,000 per 
 year of turnover, you will need a Pro license, but if you find that Unity Free doesn’t 
 pack quite enough power, you may also want to consider going Pro. You can 
 arrange a free trial of the Pro version right from the Unity website to try before 
 you buy. If the trial licence runs out before you feel you know enough to make a 
 purchase, contact Unity about extending it and they are usually very friendly and 
 helpful about it (just don’t try using a trial license for 6 months at a time, as they 
 may just figure it out!).
 C# programming knowledge
  
 Again, to reiterate this very important point, this is 
 not
  a book about learn-
 ing how to program. You will need to know some C#, and there are a number 
 of other books out there for that purpose, even if I have tried to make the 
 examples as simple as possible! This book is about making games, not about 
 learning to program.",NA
What This Book Doesn’t Cover,"This is not a book about programming and it is not a book about the right or wrong way 
 to do things. We assume that the reader has some experience with the C# programming 
 language. I am a self-taught programmer, and I understand that there may well be better 
 ways to do things.",NA
1,NA,NA
Making Games the ,NA,NA
Modular Way,"When I first started making games, I would approach development on a project-to-project 
 basis, recoding and rebuilding everything from scratch each time. As I became a pro-
 fessional developer, landing a job at a game development studio making browser-based 
 games, I was lucky enough to work with a guy who was innovating the scene. He was a 
 master at turning out great games (both visually and gameplay-wise) very quickly. One 
 secret to his success lay in the development of a reusable framework that could easily 
 be refactored to use on all of his projects. His framework was set up to deal with server 
 communication, input handling, browser communication, and UI among other things, 
 saving an incredible amount of time in putting together all of the essentials. By reusing 
 the framework, it allowed more time for him and his team to concentrate on great game-
 play and graphics optimization, resulting in games that, at the time, blew the competi-
 tion away. Of course, the structure was tailored to how he worked (he did build it, after 
 all), and it took me a while to get to grips with his style of development; but once I did, 
 it really opened my eyes. From then on, I used the framework for every project and even 
 taught other programmers how to go about using it. Development time was substantially 
 reduced, which left more time to concentrate on making better games.
 This book is based on a similar concept of a game-centric framework for use with 
 many different types of games, rather than a set of different games in different styles. The 
 overall goal of this book is to provide script-based components that you can use within 
 that framework to make a head start with your own projects in a way that reduces recod-
 ing, repurposing, or adaptation time.",NA
1.1   Important Programming Concepts,"I had been programming in C# for a fairly long time before I actually sat down and figured 
 out some of the concepts covered in this chapter. It was not because of any particular prob-
 lem or difficulty with the concepts themselves but more because I had solved the prob-
 lems in a different way that meant I had no real requirement to learn anything new. For 
 most programmers, these concepts will be second nature and perhaps something taught 
 in school, but I did not know how important they could be. I had heard about things like 
 inheritance, and it was something I put in the to-do list, buried somewhere under “finish 
 the project.” Once I took the time to figure them out, they saved me a lot of time and led to 
 much cleaner code than I would have previously pulled together. If there’s something you 
 are unsure about, give this chapter a read-through and see whether you can work through 
 the ideas. Hopefully, they may save some of you some time in the long run.
 1.1.1   Manager and Controller Scripts
 I am a strong believer in manager and controller scripts. I like to try and split things out 
 into separate areas; for example, in the 
 Metal Vehicle Doom
  game, I have race controller 
 scripts and a global race controller script. The race controller scripts are attached to the 
 players and track their positions on the track, waypoints, and other relevant player-specific 
 race information. The global race controller script talks to all the race controller scripts 
 attached to the players to determine who is winning and when the race starts or finishes. 
 By keeping this logic separate from the other game scripts and contained in their own 
 controller scripts, it makes it easier to migrate them from project to project. Essentially, I 
 can take the race controller and global race controller scripts out of the game and apply 
 them to another game, perhaps one that features a completely different type of gameplay—
 for example, alien characters running around a track instead of cars. As long as I apply 
 the correct control scripts, the race logic is in place, and I can access it in the new game.
 In the framework that this book contains, there are individual manager and control-
 ler scripts dealing with user data, input, game functions, and user interface. We look at 
 those in detail in Chapter 2, but as you read this chapter, you should keep in mind the idea 
 of separated scripts dedicated to managing particular parts of the game structure. It was",NA
2,NA,NA
Building the Core ,NA,NA
Game Framework,"In this chapter, we look at the structure of the base project, to which we will be adding all 
 of the game script components, and the thinking behind it. This chapter will give context 
 to the design decisions made in the core framework as well as provide a good base for 
 understanding how the individual code recipes work together and why they may some-
 times have dependencies on other components.
 The framework for this book (as seen in Figure 2.1) features six main areas:
  
 1. 
 Game Controller
  
 The game controller acts like a central communication script for all of the differ-
 ent parts of the game. In a way, it is the main glue that holds together the various 
 components that make up the game.
  
 2. 
 Scene Manager
  
 This script deals with the loading and saving of scenes. Scenes are what Unity calls 
 its level files.
  
 3. 
 UI Manager
  
 The UI manager draws all of the main in-game user interface elements, such as 
 score display and lives.
  
 4. 
 Sound Manager
  
 The sound manager handles sound playback. The manager holds an array con-
 taining the AudioClips of possible sounds to play. When the game first begins, the",NA
2.1   Controllers and Managers,"By specializing tasks to particular managers, it is possible to swap out other components 
 without affecting core functions, which, in turn, makes it easy to carry the same code from 
 game to game without having to rewrite it; from a first-person shooter to a racing game, 
 the same code may be used to store user session data, load levels, or control weapons. In 
 this book, I use two terms to specify the type of class: 
 controllers
  and 
 managers
 .
 2.1.1  Controllers
 Controllers
  specialize in specific tasks such as helping scripts communicate with each 
 other, holding game-specific player information, or dealing with session data. For exam-
 ple, at the center of all of the example games in this book is a game controller script that 
 acts as a central location for game scripts to communicate. Each game has its own game 
 controller script acting like glue between the different components that otherwise have no 
 built-in method for communicating.
 2.1.2  Managers
 Managers
  are used in this book as a term to represent a script that manages objects or data 
 specifically (dealing with players, audio, or other game elements in a similar way to how 
 a manager might manage staff in a company). For example, the GlobalBattleManager.cs 
 script is used to manage RaceController.cs instances to keep track of a deathmatch battle 
 in the example game 
 Tank Battle
 . The manager script takes care of calculating the position 
 of the players on the scoreboard as well as informing players as to the game’s current run-
 ning state.",NA
2.2   Building the Core Framework Scripts,"There are several scripts in the Scripts/BASE folder that are intended to act as templates 
 for your own versions, or as classes to derive from, in your own games. In this section, we 
 will be looking at the scripts that make up the main framework.
 Those core framework scripts in the BASE folder that will be covered in this chapter 
 are as follows:
  
 ◾
 2.2.1. BaseGameController.cs
  
 ◾
 2.2.2. SceneManager.cs
  
 ◾
 2.2.3. ExtendedCustomMonoBehavior.cs
  
 ◾
 2.2.4. BaseUserManager.cs
  
 ◾
 2.2.5. BasePlayerManager.cs
  
 ◾
 2.2.6. BaseInputController.cs",NA
3,NA,NA
Player Structure,"A player can take just about any form—humans, aliens, animals, vehicles; designing a struc-
 ture that can deal with all of them is a challenge in itself. The way that players store data, the 
 data they need to store, the various types of movement codes and their control systems make 
 for hundreds of different possible combinations. Dealing with a player structure in a modular 
 way requires a little careful consideration not just for how to deal with all these different sce-
 narios but also for how our components will need to communicate with each other and com-
 municate with the rest of the game—for example, player objects often need to communicate 
 with the game controller, the game controller often needs to communicate with players (to 
 relay game states, etc.), and players may also need to interact with the environment and other 
 objects within it.
 The overall player structure for this book may be broken down into several main 
 components, as shown in Figure 3.1.
  
 1. 
 Game-specific player controller
 . This is a script to deal with game-specific player 
 actions. For example, some games may require a vehicle that requires weapons, 
 whereas some games may not. The game-specific control script will “add on” 
 the specific extra functionality and tie together the main components to work 
 together or communicate with other game-specific elements.
  
 2. 
 Movement controller
 . The movement controller takes the job of moving the player 
 around and defines the type of player we are using. For example, a vehicle-based 
 player would have a vehicle-based movement control script that would drive the",NA
3.1   Game-Specific Player Controller,"The player controller derives from a movement controller (which specializes in nothing 
 more than movement of a particular player type) and builds on its movement functional-
 ity to provide full player logic.
 The movement controllers are explained later in this book. Chapter 5 outlines three 
 different movement controllers for three different player types: a spaceship, a humanoid 
 player, and a wheeled vehicle.
 What logic goes into the player controllers depends on the game; the example games 
 in this book use the movement controllers from Chapter 5 and add extra functionality to 
 them, such as combining the movement controller with the weapon controllers to make 
 armed players or combining the AI controller to have computer controller players.
 For real examples of player controllers, take a look at the example games in Chapters 
 10 to 13.
 In this section, we build a simple player controller to move a spaceship. It derives 
 from BaseTopDownSpaceShip.cs, which can be found in full in Chapter 5. This script also 
 includes a player manager.
 using UnityEngine;
 using System.Collections;
 public class SimplePlayerController : BaseTopDownSpaceShip 
 {
  
 public BasePlayerManager myPlayerManager;
  
 public BaseUserManager myDataManager;
  
  
 public override void Start()
  
 {
  
  
 // tell our base class to initialize
  
  
 base.Init ();
  
  
  
  
 // now do our own init
  
  
 this.Init();
  
 }
  
  
 public override void Init ()
  
 { 
  
  
  
  
 // if a player manager is not set in the editor, let's try   
  
  
 // to find one
  
  
 if(myPlayerManager==null)
  
  
  
 myPlayerManager= myGO.GetComponent<BasePlayerManager>();
  
  
  
  
 myDataManager= myPlayerManager.DataManager;
  
  
 myDataManager.SetName(""Player"");
  
  
 myDataManager.SetHealth(3);
  
  
  
  
 didInit=true;
  
 }
  
 public override void Update ()
  
 {
  
  
 // do the update in our base
  
  
 UpdateShip ();
  
  
  
  
 // don’t do anything until Init() has been run",NA
3.2   Dealing with Input,"Separate scripts provide input for the movement controllers to react to. This is so they may 
 be switched out for whatever input is required, without having to change anything within 
 the movement control script. The movement controller remains intact, regardless of what 
 you “feed” into it, which means you could use the exact same movement control script 
 for the main player, for AI players, and perhaps even for remote players connected over a 
 network—just using different inputs.
 BaseInputController.cs provides a collection of common variables and functions. 
 Other input scripts will derive from it:
 public class BaseInputController : MonoBehavior
 {
  
 // directional buttons
  
 public bool Up;
  
 public bool Down;",NA
3.3   Player Manager,"The player manager script acts as a simple bridge between the player controller and the 
 user data manager. It also creates the user data manager if one is not already attached to 
 the player prefab.
 using UnityEngine;
 using System.Collections;
 public class BasePlayerManager : MonoBehavior
 {
  
 public bool didInit;
  
  
 // the user manager and AI controllers are publically accessible so
  
 // that our individual control scripts can access them easily
  
 public BaseUserManager DataManager;
  
  
 // note that we initialize on Awake in this class so that it is
  
 // ready for other classes to access our details when they
  
 // initialize on Start
  
 public virtual void Awake ()
  
 {
  
  
 didInit=false;
  
  
 Init();
  
 }
  
  
 public virtual void Init ()
  
 {
  
  
 // cache ref to our user manager
  
  
 DataManager= gameObject.GetComponent<BaseUserManager>();
  
  
  
  
 if(DataManager==null)
  
   
 DataManager= gameObject.AddComponent<BaseUserManager>();",NA
3.4   User Data Manager (Dealing with Player Stats ,NA,NA
"Such as Health, Lives, etc.)","It is not uncommon to store player information in a game controller or similar script 
 removed from individual player objects. This approach may be well suited to single-player 
 games, but moving to games that have more than one player may prove to be problematic. 
 One solution may be for the game controller to have an array of classes containing player 
 stats, manipulating them when other functions tell it to; but why not attach the player stats 
 to each player and make it self-sufficient?
 The framework for this book uses a data manager class for each player, consisting of 
 everything we need to store for a single player:
  
 1. 
 Score
  
 2. 
 High score
  
 3. 
 Level
  
 4. 
 Health
  
 5. 
 Whether or not the player is finished (no longer active)
  
 6. 
 Name of the player
 Each player has the BaseUserManager.cs script attached to its gameObject, giving 
 each player its own set of stats. The game controller or other script elsewhere in the game 
 structure can easily search for and access a player’s information.
 The user manager script looks like this:
 public class BaseUserManager : MonoBehavior
 {
  
 // gameplay specific data
  
 // we keep these private and provide methods to modify them
  
 // instead, just to prevent any accidental corruption or invalid
  
 // data coming in",NA
4,NA,NA
Recipes: Common ,NA,NA
Components,NA,NA
4.1   Introduction,"Many of the scripts in this book are in some way linked to the base framework or parts 
 of larger systems, but there are some that we will use that could fit into a whole number 
 of positions in a whole number of different game types. Utility scripts or commonly used 
 systems are also going to come in really handy for the game projects. This chapter is all 
 about those, an eclectic bunch of reusable scripts such as timers or utilities.
 In the example source files, the COMMON folder can be found within the Scripts 
 folder. This is where we store all of the scripts that may crop up now and again that are not 
 part of the base framework. Within the COMMON folder, there are a number of subfold-
 ers. Those are
 BOTS OR PLAYER CONTROL
 Contains scripts related to player or automatic control, such as a script to talk 
 to the BaseAIController.cs script and act as a simple, functional bot moving 
 around in a game environment.
 CAMERA
 Scripts related to the camera should go in here, such as third-person or top-down 
 camera code.",NA
4.2   The Timer Class,"Our timer system will be named TimerClass.cs and the full script looks like this:
 public class TimerClass
 {
  
 public bool isTimerRunning= false;
  
 private float timeElapsed= 0.0f;
  
 private float currentTime= 0.0f;
  
 private float lastTime= 0.0f; 
  
 private float timeScaleFactor= 1.1f;  // <-- If you need to scale 
 // time, change this!
  
 private string timeString;
  
 private string hour;
  
 private string minutes;
  
 private string seconds;
  
 private string mills;
  
 private int aHour;
  
 private int aMinute;
  
 private int aSecond;
  
 private int aMillis;
  
 private int tmp;
  
 private int aTime;
  
 private GameObject callback;
  
 public void UpdateTimer ()
  
 {
  
  
 // calculate the time elapsed since the last Update()
  
  
 timeElapsed=Mathf.Abs(Time.realtimeSinceStartup-lastTime);
  
  
  // if the timer is running, we add the time elapsed to the 
 // current time (advancing the timer)
  
  
 if(isTimerRunning)
  
  
 {
  
  
  
 currentTime+=timeElapsed*timeScaleFactor;
  
     }
  
  
  // store the current time so that we can use it on the next 
 // update
  
  
 lastTime=Time.realtimeSinceStartup;
  
 }",NA
4.3   Spawn Scripts,"In many cases, using Unity’s built-in Instantiate function would be enough for creat-
 ing objects for a desktop computer-based game, but instantiating gameObjects in Unity 
 can be an expensive process, particularly noticeable on mobile devices. One common 
 method of getting around the processor hit is to use pooling. Pooling is where you have 
 a group of objects that you use and reuse without destroying them. Instead, pooled 
 objects are hidden rather than entirely removed from memory. With this method, the 
 memory is already allocated and the objects already exist but you are enabling and dis-
 abling them rather than having the performance hit of creating new ones and deleting 
 unused ones.
 Building a pool management system is beyond the scope of this book, although cen-
 tralizing the spawning system will make it easy to switch out spawning for a better solu-
 tion in the future. There are a couple of pool managers available to buy from the Unity 
 Asset Store, or you may want to take a look at some free code to handle pooling from an 
 awesome website called Unity Patterns (http://unitypatterns.com/new-tool-objectpool/).",NA
4.4   Set Gravity,"Changing gravity is often frowned upon by developers because doing so changes the way 
 objects behave in the physics simulation. It is highly recommended that your game physics 
 values, game world scale, and speeds are as close to real-life numbers as possible. Making 
 a game with an environment scaled too high or too low can cause problems with the 
 collisions system as well as make your coordinate system difficult to manage. Altering 
 gravity to extremely high values may cause objects to behave strangely or even push down 
 through collision meshes. Dealing with strange physics values needs to be handled with a 
 little care and awareness of “entering the twilight zone” in physics behavior terms.
 The reality is that having realistic gravity with realistically scaled 3D models and 
 realistic physics behavior may not always be either possible or, in fact, necessary. Perhaps 
 the effect you are going for is something outside of realistic, in which case it may become 
 necessary to modify physics values such as gravity. Games based on another planet would 
 likely be the most obvious use for changing these values. In the example games in this 
 book, when gravity is altered it is purely on a personal preference of how I like game phys-
 ics to feel. 
 The SetGravity.cs script sets gravity once in the Start() function and disables itself 
 to save any unnecessary overhead. Its logic is extremely simple, being a single call to set 
 Physics.gravity to a 3D vector and then disabling itself by setting this.enabled to false. The 
 variable this is simply a reference to itself, a way of telling the script to refer to itself:
 public class SetGravity : MonoBehavior {
  
 public Vector3 gravityValue = new Vector3(0,-12.81f,0);
  
 void Start () {
  
  
 Physics.gravity=gravityValue;
  
  
 this.enabled=false;
  
 }
 }",NA
4.5   Pretend Friction—Friction Simulation to Prevent ,NA,NA
Slipping Around,"The easiest way to move objects around in Unity is to simply apply forces to your rigid-
 bodies. By using Rigidbody.AddForce and perhaps a multiplier based on Input.GetAxis 
 or something similar, it is quite easy to get objects moving around, but the only way to 
 have them come to a stop is either to have them make friction against something else in 
 the game world or to change drag values on the rigidbody. This may not always be an ideal",NA
4.6   Cameras,"There are just two camera scripts for the example games in this book. Those are a third-
 person camera (a camera that sits behind and orbits around the player) and a top-down 
 camera (a camera that sits up above the player, looking down). They use a similar interface 
 for other scripts to be able to communicate with them, and both cameras should provide 
 a good starting point for camera systems in your own games.",NA
4.7   Input Scripts,"In Chapter 3, we saw that the main player structure contained a single input script 
 designed to take keyboard input. Adding input systems is a case of building custom input 
 scripts that follow a similar format, so that the existing player code need not be changed 
 to accommodate different controls.
 It may be required to take input from other methods than the keyboard, such as a 
 mouse or a joystick. You can easily set up alternate controls in the Unity editor via the Edit 
 –> 
 Project Settings
  –> 
 Input
  menu.
 4.7.1   Mouse Input
 The Mouse_Input.cs script calculates the movement of the mouse between each frame and 
 uses it for input.
 Below is the script:
 public class Mouse_Input : BaseInputController
 {
  
 private Vector2 prevMousePos;
  
 private Vector2 mouseDelta;
  
  
 private float speedX = 0.05f;
  
 private float speedY = 0.1f;
  
 public void Start ()
  
 {
  
  
 prevMousePos= Input.mousePosition;
  
 }
  
 public override void CheckInput ()
  
 {
  
  
  // get input data from vertical and horizontal axis and 
 // store them internally in vert and horz so we don't",NA
4.8   Automatic Self-Destruction Script,"The main use for a script that automatically destroys its gameObject will be for special 
 effects. Particle effects such as explosions will be instantiated, their effect will play out, and 
 then they need to be destroyed. 
 In the example games, a short and simple class called AutomaticDestroyObject is 
 attached to a gameObject. After a set amount of time, set in the Unity editor Inspector 
 window, the gameObject is destroyed along with any associated child objects attached to 
 it.
 Below is the full script:
 public class AutomaticDestroyObject : MonoBehavior 
 {
  
 public float timeBeforeObjectDestroys;
  
 void Start () {
  
  
  // the function destroyGO() will be called in 
 // timeBeforeObjectDestroys seconds
  
  
 Invoke(""DestroyGO"",timeBeforeObjectDestroys);
  
 }
  
 void DestroyGO () {
  
  
 // destroy this gameObject
  
  
 Destroy(gameObject);
  
 }
 }
 4.8.1   Script Breakdown
 The class, which derives from MonoBehavior, is very simple. It uses Invoke to schedule a 
 call to the DestroyGO() function at a time set by the public variable timeBeforeObjectDe-
 stroys. It probably goes without saying that DestroyGO() takes care of destroying itself, 
 with Destroy(gameObject).",NA
4.9   Automatic Object Spinner,"One common action you may need to do is spin an object. This may be for a number of 
 reasons, the most obvious (in this book, at least) being to draw attention to power-ups in 
 the 
 Interstellar Paranoids
  game. By spinning the power-ups, they are more obvious to the 
 player as something that may be interacted with, whereas static power-ups may be easily 
 missed or ignored.
 Making an object spin in Unity may be very simple, but having a script to take care of 
 this is a useful little tool to keep in the toolkit.
 Below is the script in full:
 using UnityEngine;
 using System.Collections;",NA
4.10   Scene Manager,"The scene manager deals with loading and saving different scenes. It is intended to be used 
 for loading different levels in a game, but also it may easily be used for loading the menu 
 if required.
 The example game 
 Interstellar Paranoids
  uses it to load game levels. It is attached to an 
 empty gameObject in the menu scene, and thanks to its call to DontDestroyOnLoad() in 
 the Start() function, it will persist across scenes so that it is always available.
 Additionally, this class provides some very basic functionality for game level manage-
 ment in linearly progressive games; that is, games that progress through the same levels 
 each time.
 The script is designed to use an array of scenes set in the Unity editor Inspector win-
 dow. The script retrieves a scene reference from the array as required. It has an integer 
 variable named gameLevelNum, which is used as an index for the array. To advance to the 
 next level, gameLevelNum is incremented.
 Below are the level management functions:
  
 ◾
 GoNextLevel()—Increments gameLevelNum and loads the next scene in the 
 array. If gameLevelNum is higher than the array length, it loops back to zero.
  
 ◾
 ResetGame()—Resets gameLevelNum back to zero, as though the game were 
 restarting. 
 Below is the script in full:
 using UnityEngine;
 using System.Collections;
 public class SceneManager : MonoBehavior
 {
  
 public string[] levelNames;
  
 public int gameLevelNum;
  
 public void Start ()
  
 {
  
  
 // keep this object alive
  
  
 DontDestroyOnLoad (this.gameObject);
  
 }
  
 public void LoadLevel( string sceneName )
  
 {
  
  
 Application.LoadLevel( sceneName );
  
 }
  
 public void ResetGame()
  
 {
  
  
 // reset the level index counter
  
  
 gameLevelNum = 0;
  
 }",NA
5,NA,NA
Building Player ,NA,NA
Movement Controllers,"As discussed in Chapter 3, what we called a player controller is focused on movement; it 
 is the script that determines the way that a player moves and behaves in the physics world. 
 It is entirely focused on movement—making a ship fly, a human move along the ground, 
 or a car to drive.
 The example games call for three different vehicle types:
  
 1. 
 Shoot ’em up spaceship—A spaceship that moves up, down, left, and right. Its 
 movement need not be physics based.
  
 2. 
 Humanoid character—This control script is capable of general human things, 
 such as running forward, backward, and turning around.
  
 3. 
 Wheeled vehicle—The vehicle controller utilizes Unity’s wheel colliders to work 
 toward a more realistic physics simulation. There will be no gearing, but the vehi-
 cle will be able to accelerate, brake, or steer left and right.",NA
5.1   Shoot ’Em Up Spaceship,"This script moves the player transform left, right, up, or down on the screen. It does not use 
 any physics forces, but instead Transform.Translate manipulates the gameObject’s trans-
 form position directly.",NA
5.2   Humanoid Character,"The human control script uses Unity’s character controller and is based on the third- 
 person character controller provided by Unity (which is provided free, as part of the 
 included assets with the Unity game engine).
 The complete BaseTopDown.cs script looks like this:
 using UnityEngine;
 using System.Collections;
 public class BaseTopDown : ExtendedCustomMonoBehavior
 {
  
 public AnimationClip idleAnimation;
  
 public AnimationClip walkAnimation;
  
  
 public float walkMaxAnimationSpeed = 0.75f;
  
 public float runMaxAnimationSpeed = 1.0f;
  
  
 // When did the user start walking (Used for going into run after a  
  
 // while)
  
 private float walkTimeStart= 0.0f;
  
  
 // we've made the following variable public so that we can use an   
  
 // animation on a different gameObject if needed
  
 public Animation _animation;
  
  
 enum CharacterState {
  
 Idle = 0,
  
 Walking = 1,
  
 Running = 2,
  
 }
  
  
 private CharacterState _characterState;
  
  
 // The speed when walking
  
 public float walkSpeed= 2.0f;
  
  
 // after runAfterSeconds of walking we run with runSpeed
  
 public float runSpeed= 4.0f;
  
  
 public float speedSmoothing= 10.0f;
  
 public float rotateSpeed= 500.0f;
  
 public float runAfterSeconds= 3.0f;
  
  
 // The current move direction in x-z
  
 private Vector3 moveDirection= Vector3.zero;
  
  
 // The current vertical speed
  
 private float verticalSpeed= 0.0f;",NA
5.3   Wheeled Vehicle,"The BaseVehicle.cs script relies on Unity’s built-in WheelCollider system. WheelCollider com-
 ponents are added to gameObjects positioned in place of the wheels supporting the car body. 
 The WheelCollider components themselves do not have any visual form, and meshes repre-
 senting wheels are not aligned automatically. WheelColliders are physics simula tions; they 
 take care of all of the physics actions such as suspension and wheel friction.
 The Unity documentation describes the WheelCollider as
 …a special collider for grounded vehicles. It has built-in collision detection, wheel phys-
 ics, and a slip-based tire friction model.
 The physics and math behind the friction system are beyond the scope of this book, 
 though thankfully, the Unity documentation has an extensive investigation of the subject 
 on the WheelCollider page in the online help (http://docs.unity3d.com/Documentation/
 Components/class-WheelCollider.html).
 The BaseVehicle.cs script uses four WheelColliders for its drive (in the example games, 
 these are attached to empty gameObjects), and the actual orientation of wheel meshes is 
 dealt with by a separate script called BaseWheelAlignment.cs and will be explained in full 
 later on in the chapter.
 BaseVehicle.cs looks like this:
 using UnityEngine;
 using System.Collections;
 public class BaseVehicle : ExtendedCustomMonoBehavior
 {
  
 public WheelCollider frontWheelLeft;
  
 public WheelCollider frontWheelRight;
  
 public WheelCollider rearWheelLeft;
  
 public WheelCollider rearWheelRight;
  
 public float steerMax = 30f;
  
 public float accelMax = 5000f;
  
 public float brakeMax = 5000f;
  
 public float steer = 0f;
  
 public float motor = 0f;
  
 public float brake = 0f;
  
 public float mySpeed;
  
 public bool isLocked;
  
 [System.NonSerialized]
  
 public Vector3 velo;
  
 [System.NonSerialized]
  
 public Vector3 flatVelo;
  
 public BasePlayerManager myPlayerController;",NA
6,NA,NA
Weapon Systems,"The weapon system, or more specifically at this point, the firing system, needs to be capa-
 ble of dealing with either single or multiple weapons. To be as flexible as possible, we 
 will build a weapon management system that will control individual weapon controllers. 
 Those weapon controllers, in turn, will deal with spawning projectiles, and finally, projec-
 tiles will take care of themselves independently. Our weapon management system should 
 function with a single weapon, or we should be able to add many different weapons and 
 switch between them.
 Our parent system should work independently of each specific weapon and fire out a 
 generic message to the currently selected one. The selected weapon will deal with the call 
 itself, and the overall weapon management system can continue unaffected.
 The weapon controller deals with how weapons are stored or manipulated and passes 
 on messages to the actual weapons themselves. It contains an array containing all weap-
 ons and a method to activate and deactivate them as required (switching between them).
 Each weapon is a prefab with a script attached that derives from BaseWeaponScript.
 cs. The weapon should be self-contained except when it receives a call to Fire() in which 
 it should do whatever it is supposed to do. BaseWeaponScript contains the basics for a 
 weapon (ammunition, reload time, and the ability to be disabled or enabled).",NA
6.1   Building the Scripts,"For the weapon system, there are just two main scripts:
  
 1. 
 BaseWeaponController.cs
  
 This is the framework for our weapon control system. It offers everything the sys-
 tem requires, and it is intended to be overridden for customization.
  
 2. 
 BaseWeaponScript.cs
  
 This script takes care of individual weapon types. If you were to think of the 
 BaseWeaponController as the arms of the player, the BaseWeaponScript would be 
 the design of the weapon it is holding.
 6.1.1   BaseWeaponController.cs
 Here is the BaseWeaponController.cs script in its completed form:
 using UnityEngine;
 using System.Collections;
 public class BaseWeaponController : MonoBehavior
 {
  
 public GameObject[] weapons;
  
 public int selectedWeaponSlot;
  
 public int lastSelectedWeaponSlot;
  
 public Vector3 offsetWeaponSpawnPosition;
  
 public Transform forceParent;
  
 private ArrayList weaponSlots;
  
 private ArrayList weaponScripts;
  
 private BaseWeaponScript TEMPWeapon;
  
 private Vector3 TEMPvector3;
  
 private Quaternion TEMProtation;
  
 private GameObject TEMPgameObject;
  
 private Transform myTransform;
  
 private int ownerNum;
  
 public bool useForceVectorDirection;
  
 public Vector3 forceVector;
  
 private Vector3 theDir;",NA
7.1   Waypoint System,"Both the racing game 
 Motor Vehicle Doom
  and the shoot ’em up 
 Interstellar Paranoids
  will 
 need waypoints for the AI players. In 
 Motor Vehicle Doom
 , we use waypoints for the AI and 
 also for the main player for the following reasons:
  
 1. 
 To check that the main player is heading in the right direction. The car controller 
 code will track the player’s position on the track (based on which waypoint has 
 been passed) and check its forward vector to make sure that it is facing the next 
 waypoint along the track. If the player’s forward vector is not within a certain tol-
 erance angle, the game will display a wrong way message and eventually respawn 
 the car facing the right way.
  
 2. 
 To enable the respawning system to find a “safe” place along the track to respawn 
 the player as well as to use its rotation to point the respawned car in the right 
 direction along the track.
  
 3. 
 To find out how far the vehicle has traveled around the track, which is used to 
 compare the other players progress amounts to calculate race positions.
 Interstellar Paranoids
  uses waypoints for moving all of the enemies. Enemies are simple 
 path followers that move along a path firing until they reach the end, where they are destroyed.",NA
7,NA,NA
Recipe: Waypoints ,NA,NA
Manager,NA,NA
Recipe: Sound ,NA,NA
Manager,NA,NA
8,"Audio can make or break a video game. Good audio can provide a deeper level of immer-
 sion by reinforcing the themes of the game world and filling out environments into living, 
 noise-making places. On the other hand, bad audio can irritate players and turn a good 
 gameplay experience into something repetitive and empty.
 Most commercial games have several different layers of audio playing at the same 
 time, transitioning or changing contextually. To achieve commercial levels of audio, 
 Unity’s audio system will need a lot of help. Out of the box, it isn’t exactly an easy process 
 to do some simple tasks, such as fading audio in and out or controlling volume levels. To 
 accomplish even basic functionality, extra audio management code is required.
 The audio code in this book provides the following functionality to our framework:
  
 1. 
 To provide a single audio source for multiple audio clips
  
 2. 
 To be able to manage audio clips from a single source
  
 3. 
 To be able to play, pause, or stop an audio clip
  
 4. 
 To be able to play, pause, or stop music streaming from disc
  
 5. 
 To provide volume control functions to set volume and fade music in and out
  
 6. 
 To provide accessibility, by being a static singleton instance, so that all calls to 
 audio are of the same format",NA
8.1  The Sound Controller,"In the example framework for this book, it is assumed that each scene has a sound con-
 troller, an empty gameObject with the BaseSoundController.cs script attached to it. The 
 component has an array populated in the Unity editor Inspector window by the sounds 
 required for the game (their AudioClips). When a sound is required by another script, it 
 calls upon the sound manager to play it, passing in the index of the AudioClip as it stands 
 in the array:
 BaseSoundController.Instance.PlaySoundByIndex( the index number from the 
 array of sounds );
 Centralizing the audio playback avoids dealing with properties in multiple places, 
 such as having to set the volume level on every AudioSource when a user changes it in the 
 options menu. When audio is centralized like this, one volume setting and one volume 
 script can easily change all of the game audio.
 Below is the full sound controller script:
 using UnityEngine;
 using System.Collections;
 public class SoundObject
 {
  
 public AudioSource source;
  
 public GameObject sourceGO;
  
 public Transform sourceTR;
  
  
 public AudioClip clip;
  
 public string name;
  
  
  
  
 public SoundObject(AudioClip aClip, string aName, float aVolume)
  
 {
  
  
  // in this (the constructor) we create a new audio source 
 // and store the details of the sound itself
  
  
 sourceGO= new GameObject(""AudioSource_""+aName);
  
  
 sourceTR= sourceGO.transform;
  
  
 source= sourceGO.AddComponent<AudioSource>();
  
  
 source.name= ""AudioSource_""+aName;
  
  
 source.playOnAwake= false;
  
  
 source.clip= aClip;
  
  
 source.volume= aVolume;
  
  
 clip= aClip;
  
  
 name= aName;
  
 }
  
  
 public void PlaySound(Vector3 atPosition)
  
 {
  
  
 sourceTR.position= atPosition;
  
  
 source.PlayOneShot(clip);
  
 }",NA
8.2  The Music Player,"The MusicController.cs script is intended for playing music. It will set the volume accord-
 ing to a PlayerPrefs value and handle volume fading and audio clip looping.
 Below is the full script:
 using UnityEngine;
 using System.Collections;
 public class MusicController : MonoBehavior
 {
  
 private float volume;
  
  public string gamePrefsName= ""DefaultGame"";  // DO NOT FORGET TO SET 
 // THIS IN THE EDITOR!!
  
 public AudioClip music;
  
  
 public bool loopMusic;
  
  
 private AudioSource source;
  
 private GameObject sourceGO;
  
 private int fadeState;
  
 private int targetFadeState;
  
 private float volumeON;
  
 private float targetVolume;
  
 public float fadeTime=15f;
  
 public bool shouldFadeInAtStart= true;",NA
8.3  Adding Sound to the Weapons,"There are two places that may, at first glance, make good sound trigger points for weap-
 ons. One is when the fire button is pressed in the player script, and the other is when the 
 projectile itself is created.
 Making a sound when the fire button is pressed may seem like a good idea, but to do 
 that, we have to make sure that the projectile actually makes it into the world. After the 
 fire button is pressed, it may be that there is no ammunition left in the weapon or that the 
 weapon is in its reloading period. Making the sound without firing the projectile would 
 be rather silly.
 Making a sound when the projectile is spawned may in fact be a better option, as it 
 will only make a sound when a projectile is successfully made. Also, the sound can be",NA
9,NA,NA
AI Manager,"When computer scientist John McCarthy coined the term artificial intelligence (AI) in the 
 mid-1950s, I doubt anything like the path-finding killer robot cars we will be building in 
 this book would have been on his mind.
 The AI Controller in this book is a basic state machine, focused on function rather 
 than on any kind of emotional simulation. For it to work for the example games later on 
 in the book, our AI controller will be able to perform several different actions. It will need 
 to be able to control a vehicle (as in a body, a spaceship, or other moving entity) by turning 
 and moving forward and backward and using vision to try to avoid obstacles. When we 
 need the controller to follow a specific path, it should be capable of turning toward and 
 moving in the direction of waypoints.
 Achieving this will require the controller to act differently in several different states. 
 The BaseAIController.cs states are as follows:
  
 1. 
 moving_looking_for_target
  
 Moves forward, continuously checking the distance between this object and the 
 target. If the distance is below a set chase distance (maxChaseDistance), then the 
 AI uses raycasting to check the line of sight between object and target. If the target 
 is visible, the AIState changes to chasing_target.
  
  
 Two “feeler” raycasts will be made out from the front of this object, looking for 
 obstacles. If an obstacle is found on the right, the AIState changes to turn left. If an",NA
9.1  The AI State Control Script,"Before getting to the main BaseAIController.cs script, take a look at AIStates.cs below. It 
 contains all of the AIStates from the previous section stored in an enumerator list similar 
 to the one used by the character controller from Chapter 5. This list will be used by the AI 
 to determine its current required behavior. The list is in its own file (the AIStates.cs file) 
 and in a namespace called AIStates so that we can easily make it accessible from any script 
 used by the game:
 using UnityEngine;
 namespace AIStates
 {
  
 public enum AIState
  
 {
  
  
 moving_looking_for_target,
  
  
 chasing_target,
  
  
 backing_up_looking_for_target,
  
  
 stopped_turning_left,
  
  
 stopped_turning_right,
  
  
 paused_looking_for_target,
  
  
 translate_along_waypoint_path,
  
  
 paused_no_target,
  
  
 steer_to_waypoint,
  
  
 steer_to_target,
  
 }
 }",NA
9.2  The Base AI Control Script,"The BaseAIController.cs script includes the standard namespaces along with the addition 
 of AIStates, so that the AI controller can easily have access to the behavior enumerator list.
 The full AI controller script looks like this:
 using UnityEngine;
 using System.Collections;
 using AIStates;
 [AddComponentMenu(""Base/AI Controller"")]
 public class BaseAIController : ExtendedCustomMonoBehavior {
  
  
 // AI states are defined in the AIStates namespace
  
  
  
 private Transform proxyTarget;
  
 private Vector3 relativeTarget;
  
 private float targetAngle;
  
 private RaycastHit hit;
  
 private Transform tempTransform;
  
 private Vector3 tempDirVec;
  
  
 public float horz;
  
 public float vert;
  
  
 private int obstacleHitType;
  
  
  
 // editor changeable / visible
  
 public bool isStationary;
  
  
 public AIState currentAIState;
  
  
 public float patrolSpeed= 5f;
  
 public float patrolTurnSpeed= 10f;
  
 public float wallAvoidDistance= 40f;
  
  
 public Transform followTarget;
  
  
 public float modelRotateSpeed= 15f;
  
 public int followTargetMaxTurnAngle= 120;
  
  
  
 public float minChaseDistance= 2f;
  
 public float maxChaseDistance= 10f;
  
 public float visionHeightOffset= 1f;
  
 [System.NonSerialized]
  
 public Vector3 moveDirection;
  
  
 // waypoint following related variables
  
 public Waypoints_Controller myWayControl;
  
  
 public int currentWaypointNum;
  
  
 [System.NonSerialized]
  
 public Transform currentWaypointTransform;",NA
9.3  Adding Weapon Control to the AI Controller,"The BaseArmedEnemy.cs script is intended to be added to a player to take control of the 
 weapons system and deal with firing. It does not specifically reference or require the AI con-
 troller, and it works independently, relying only on the Standard_SlotWeaponController.
 cs script to operate the weapon and a separate class named AIAttackStates.
 The AIAttackStates.cs script stores an enumerated list of the possible states for the 
 armed enemy to take:",NA
10.1   The Main Menu  ,"First impressions last. When you walk by a store, its appearance may influence your deci-
 sion whether to go in and browse or to keep walking. If the outside of the store looks run-
 down or badly kept, it may also affect how you feel about the goods inside. A quick visit 
 to an Apple Store can demonstrate the extreme of this idea, where everything is arranged 
 to exacting, some may say extreme, levels of detail. It was no coincidence that many of 
 Apple’s initial retail team came from the clothing store Gap, a company well known for its 
 cool image and stylish branding.* Owing to the nature of electronics (hardly stylish to go 
 cable shopping, for example), the appearance of electronics stores had taken a back seat to 
 function before Apple came along and changed things. Apple brought emotion, humanity, 
 function, and style to electronics. Steve Jobs said in a video tour of the first Apple store that 
 “
 [p]eople don’t just want to buy personal computers anymore, they want to know what 
 *
 http://online.wsj.com/article/SB10001424052702304563104576364071955678908.html.",NA
10,NA,NA
Menus and User ,NA,NA
Interface,NA,NA
10.2   In-Game User Interface,"The user interface used for the games in this book is extremely basic but entirely func-
 tional. Each script derives from a class called BaseUIDataManager, which declares several 
 common variables and provides some basic functions to deal with them. Those are
 player_score
 The player’s score
 player_lives
 The amount of health or lives that the player has
 player_highscore
 The highest score achieved in the game so far
 gamePrefsName
 A string to prefix all PlayerPrefs references (see the earlier section in this 
 chapter for a more in-depth discussion on how PlayerPrefs is used)
 The BaseUIDataManager.cs script looks like this:
 using UnityEngine;
 using System.Collections;
 public class BaseUIDataManager : MonoBehavior
 {
  
 // the actual UI drawing is done by a script deriving from this one  
  
 public int player_score;
  
 public int player_lives;",NA
11,NA,NA
Dish: ,NA,NA
Lazer Blast Survival,"In the late 1970s came a turn-based game called 
 Robots
  from Berkeley Software Distribution 
 (BSD). In 
 Robots
 , the player must escape from a swarm of enemies that move in closer toward 
 the player at each turn. In the original version of the game, the player moves around the arena 
 in an attempt to avoid contact between enemies and player, which would end the game.
 Robots
  is often referred to as the beginning of the arena shooter—a term used to describe 
 a top-down shoot ’em up game with the action locked into a limited area similar to an arena. 
 There were derivatives of the 
 Robots
  concept, but the overall idea of escaping from hoards of 
 enemies in an enclosed area remained the same and the game was perfect for the low-spec 
 computers of the time. Before long, it was inevitable that it would evolve into something 
 faster—and in real time. In 1980, Stern Electronics introduced the world to 
 Berserk
 .
 Berserk
  started out as an arcade game but quickly moved to home consoles such as 
 the Atari 2600, 5200, and Vectrex systems. It was, in essence, the evolution of 
 Robots
  into 
 a real-time arcade shooter. In this version, the player makes his way through a randomly 
 generated maze, zapping enemies. Each screen contained a number of enemies, which 
 could be either destroyed or left behind as the player made his way to the edge of the screen 
 to move on to the next part of the maze. There was no scrolling; movement between each 
 section was by a screen swap. One of 
 Berserk
 ’s most outstanding and well-remembered 
 features was a speech synthesis system in the arcade machines that allowed the robots to 
 talk. Arcades everywhere rumbled to random robot phrases and kids like me put on their 
 best robot voices to say “Get the humanoid”, “The intruder must not escape”, and “Flight 
 like a robot!”.",NA
11.1  Main Menu Scene (Enemy_Bot_LBS.cs) Armed enemy movement controller (BaseArmedEnemy.cs),"Lazer Blast Survival
  works across just two scenes. The main menu scene loads a game 
 scene containing an arena 3D environment and everything to make the game work how 
 it should.
 Manager and control objects
 Scene
 Game controller
 Te game controller is attached
 to a gameObject in the main
 game scene.
 UI
 manager
 Sound
 manager
 Scene manager
 (persists across all scenes)
 Enemy
 Slot-based
 weapon system
 AI controller
 Enemy manager
 Player manager
 User manager
 Humanoid
 movement
 controller
 Input controller
 Slot-based
 weapon system
 Class derived from
 Class derived from
 Player
 Figure 11.3
  
 The game structure for 
 Lazer Blast Survival
 .",NA
11.2  Main Game Scene,"Rather than loading different scenes for each attach wave, the game works by instantiat-
 ing prefabs full of enemies into the same scene over and over until the player has no lives 
 remaining.
 The main menu consists of a single 
 gameObject
 , and the main menu script is shown 
 in Chapter 10.
 The main game scene Hierarchy structure looks like this:
  
 ◾
 ARENA
  
 ⦁
 (Models that make up the environment)
  
 ◾
 Arena_Colliders
  
 ⦁
 (Colliders for the level)
  
 ◾
 Directional light
  
 ◾
 GameController
  
 ◾
 Main Camera
  
 ◾
 MusicController
  
 ◾
 Player_Startpoint
  
 ◾
 SoundController
  
 ◾
 SpawnController
  
 ◾
 UI
  
 ⦁
 Game Over Graphic
  
 ⦁
 Get Ready Graphic
 Note that the game controller dynamically creates players and enemies when the 
 game starts. References to several prefabs and gameObjects are set in the Unity Inspector 
 window:
  
 ◾
 Game controller prefabs
  
 ⦁
 Explosion prefab (a particle effect for explosions)
  
 ⦁
 Player Prefab List array containing a reference to the Top_Down_Player prefab
  
 ⦁
 StartPoints array containing a reference to the Player_Startpoint gameObject 
 in the scene",NA
11.3  Prefabs,"The prefabs that make up the game are
 ENEMIES
 EnemyBot
 ENEMY WAVES
 Spawn_Structure 1
 Spawn_Structure 2
 Spawn_Structure 3
 PLAYERS
 Top_down_player",NA
11.4  Ingredients,"Lazer Blast Survival
  uses the following ingredients:
  
 1. 
 Game Controller. The game controller script for this game derives from 
 BaseGameController.cs
  
 2. 
 The Main Player. The player rig is based on a Unity character controller and the 
 scripts used to control the main player are as follows:
  
 a. 
 A main player script derived from BaseTopDown.cs (found in Chapter 5, 
 Section 5.2.)
  
 b. 
 The player data manager BasePlayerManager.cs (found in Chapter 3, Section 3.3.)
  
 c. 
 The weapon controller Standard_Slot_Weapon_Controller.cs
  
 3. 
 The enemy bots. The enemies are made of the following scripts:
  
 a. 
 Enemy bot controller derived from BaseArmedEnemy.cs
  
 b. 
 BaseAIController.cs for patrolling and target chasing logic.
  
 c. 
 SimpleBotMover.cs to make the bot move around.
  
 d. 
 A rigidbody component.
  
 e. 
 The weapon controller Standard_Slot_Weapon_Controller.cs
  
 f. 
 A box collider component.",NA
11.5  Game Controller,"The Game Controller is a central communications hub for the game. It derives from 
 BaseGameController, overriding some of the base functions as well as adding some of its 
 own.
 The full GameController_LBS.cs script looks like this:
 using UnityEngine;
 using System.Collections;
 public class GameController_LBS : BaseGameController
 {
  
 public string mainMenuSceneName = ""menu_LBS"";
  
 public GameObject[] playerPrefabList;",NA
11.6  Player Controller,"Lazer Blast Survival
  uses an animated human player model from the Unity3d 
 Angry Bots
  
 tutorial, included with Unity. It uses a class that derives from the top-down controller 
 script shown in Chapter 5, adding custom game-specific scripting to it and a separate class 
 to take care of animating the character model.
 The player class Player_LBS derives from the controller script BaseTopDown.cs, a 
 modified version of the third-person controller script included with Unity that uses Unity’s 
 built-in character controller for physics. BaseTopDown.cs is detailed in full in Chapter 5 
 (Building Player Movement Controllers).
 Player_LBS.cs looks like this:
 using UnityEngine;
 using System.Collections;
 public class Player_LBS : BaseTopDown
 {
  
 private bool isInvulnerable;
  
 private bool isRespawning;
  
  
 public BasePlayerManager myPlayerManager;
  
 public BaseUserManager myDataManager;
  
  
  
 public bool godMode =false;
  
 public GameObject theMeshGO;
  
  
 public Standard_SlotWeaponController weaponControl;
  
 public bool canFire;
  
  
 public bool isFinished;
  
  
 public override void Init ()
  
 {
  
  
 base.Init();
  
  
  
  
 // do god mode, if needed)
  
  
 if(!godMode)
  
  
 {
  
  
  
 MakeVulnerable();
  
  
 } else {
  
  
  
 MakeInvulnerable();
  
  
 }
  
  
  
  
 // start out with no control from the player
  
  
 canControl=false;
  
  
  
  
 // get a ref to the weapon controller
  
  
 weaponControl=
  
  
 myGO.GetComponent<Standard_SlotWeaponController>();
  
  
  
  
  // if a player manager is not set in the editor, let's try 
 // to find one
  
  
 if(myPlayerManager==null)
  
  
  
 myPlayerManager=
  
  
  
 myGO.GetComponent<BasePlayerManager>();",NA
11.7  Enemies,"EnemyBot_LBS.cs is a surprisingly straightforward script, thanks to the BaseAIController.cs 
 and the BaseArmedEnemy.cs scripts it uses at its core:
 public class EnemyBot_LBS : BaseArmedEnemy
 {
  
 public void Start ()
  
 {
  
  
 base.Start ();
  
  
  
  
 // let's find our AI controller
  
  
 BaseAIController aControl= (BaseAIController)
  
  
 gameObject.GetComponent<BaseAIController>();",NA
11.8  Wave Spawning and Control,"Here is the Wave_Spawner.cs script in full:
 using UnityEngine;
 using System.Collections;
 public class Wave_Spawner : MonoBehavior
 {
  
 public bool randomSpawning;
  
  
 public float timeBeforeFirstSpawn=1f;
  
  
 public GameObject[] spawnObjectPrefabs;",NA
11.9  Wave Properties,"The Wave_Spawner.cs script outlined in the last section showed that we need to know how 
 many enemies there are in each attack wave. To take care of this, a simple WaveProperties 
 script is attached to the attack wave prefab. It contains just a single integer named enemies- 
 InWave that we set in the Unity editor Inspector window. The game controller script will 
 access this value whenever a new wave is spawned, and it will use the value of enemiesIn-
 Wave to keep track of enemies in each wave.
 WaveProperties.cs looks like this:
 public class WaveProperties : MonoBehavior
 {
  
 public int enemiesInWave; 
 }",NA
11.10  Weapons and Projectiles,"The main weapon (a prefab named Blaster) has a gun mesh with a single script attached to 
 it—BaseWeaponScript.cs—and it contains a reference to a projectile named Blast that will 
 be instantiated whenever it fires.
 The projectile is made from a cube, colored red to look more like laser fire. Attached 
 to the projectile are several scripts:
  
 ◾
 Automatic Destroy Object
  
  
 Destroys the gameObject after a set amount of time (to stop any projectiles 
 that never hit anything from travelling off into infinite space!).
  
 ◾
 Projectile Controller
  
  
 As discussed in full in Chapter 6.
  
 ◾
 Rigidbody
  
  
 The rigidbody has only 0.1 mass and no drag at all. The rigidbody is set to 
 interpolate its movement (in an attempt to help improve collisions). One other 
 point of note is that its collision method is set to Continuous. When projectiles 
 are moving as quickly as they do in this game, it is very probable that they will 
 sometimes go through other meshes with no registered collision. The Continuous 
 collision setting will mean increased accuracy but at a small processing cost. In 
 a game like this, the difference in performance is negligible but you should use 
 continuous collisions sparingly and as little as possible.
  
 ◾
 Sphere Collider
  
  
 The collider is a standard sphere collider.",NA
11.11  User Interface,"The main script looks like this:
 using UnityEngine;
 using System.Collections;
 [AddComponentMenu(""Sample Game Glue Code/Laser Blast Survival/In-Game UI"")]
 public class UI_LBS : BaseUIDataManager
 {
  
 public GameObject gameOverMessage;
  
 public GameObject getReadyMessage;
  
  
 void Awake()
  
 {
  
  
 Init();
  
 }",NA
12,NA,NA
Dish: ,NA,NA
Metal ,NA,NA
Vehicle Doom,NA,NA
12.1   Main Menu Scene,"The game works over two scenes, a main menu and the main track scene. The scene named 
 menu_MVD contains a single camera called Main Camera. The MainMenuController.cs 
 script component is attached to the camera object and deals with rendering the menu to 
 the screen and dealing with interaction.",NA
12.2   Main Game Scene,"The menu loads a scene containing the track and environmental specifics such as a light 
 and any collision meshes. When the game starts, the game controller adds the racers to the 
 scene (instantiating their prefabs) as the game begins.
 The main menu consists of a single gameObject and the main menu script is shown 
 in Chapter 10.
 Figure 12.1 
 Headlong Racing
  by PsychicParrot Games.
 Figure 12.2 
 Metal Vehicle Doom
 .",NA
12.3   Ingredients,"Metal Vehicle Doom
  uses these ingredients:
  
 1. 
 Game Controller—The game controller script for this game derives from 
 BaseGameController.cs.
  
 2. 
 Race Manager—Each player has a race controller script attached to it, which holds 
 information relevant to its race stats (position/waypoint, etc.). The race manager talks 
 to all of the player’s race controllers and tracks global information on the state of the 
 race, such as player race positions and whether or not the race is still in progress.",NA
13,NA,NA
Dish: Making the ,NA,NA
Game ,NA,NA
Tank Battle,NA,NA
13.1   Main Game Scene Wheeled vehicle movement controller,"Tank Battle
  has two scenes: a main menu and the main game battle arena scene.
 The main menu consists of a single gameObject, and the main menu script is shown 
 in Chapter 10.
 The main game scene Hierarchy structure contains the following:
  
 ◾
 ARENA
  
 ⦁
 (Models that make up the environment, including a directional light to 
 brighten it up)
  
 ◾
 GameController
  
 ◾
 Main Camera
  
 ◾
 MusicController
 Manager and control objects
 Game controller
 Te game controller is attached to
 a gameObject in
 the main game scene.
 UI
 manager
 Sound
 manager
 Scene manager
 (persists across all scenes)
 Slot-based
 weapon system
 AI controller
 Player manager
 User manager
 Input controller
 Path waypoint 
 controllers
 Players (both AI and user controlled)
 Scene
 Global battle manager
 Waypoint
 gameObjects
 Battle controller
 Class derived from
 Figure 13.2 
 Tank Battle
  game structure.",NA
13.2   Prefabs,"The prefabs that make up the game are as follows:
  
 ◾
 PLAYERS
  
 ⦁
 Tank
  
 ⦁
 AI_Tank
  
 ◾
 PROJECTILES
  
 ⦁
 Tank_StandardFire
  
 ◾
 WEAPONS
  
 ⦁
 TankProjectileBlaster_Player
  
 ⦁
 TankProjectileBlaster_Enemy",NA
13.3   Ingredients,"The game uses these ingredients:
  
 1. 
 Game Controller—The game controller script for this game derives from 
 BaseGameController.cs
  
 2. 
 Battle Controller—Each player has a battle controller script attached to it, which 
 holds information relevant to its battle stats (number of frags/number of times 
 fragged, etc.). To be clear, a frag is a hit. When the player is destroyed, it counts as 
 a frag.
  
 3. 
 Global Battle Manager—The global battle manager talks to all of the player’s battle 
 controllers and tracks global information on the state of the battle, such as player 
 battle positions and whether or not the battle is still in progress.
  
 4. 
 Vehicles (tanks):
  
 a. 
 Main player
  
 b. 
 AI opponents
  
 5. 
 Scene Manager",NA
13.4   Game Controller,"The game controller script GameController_TB.cs looks like this:
 using UnityEngine;
 using System.Collections;
 public class GameController_TB : BaseGameController
 {
  
 public string mainMenuSceneName = ""menu_TB"";
     public int numberOfBattlers = 4;
  
 public int gameTime= 120;
     public Transform playerParent;
     public Transform [] startPoints;
     public Camera_Third_Person cameraScript;
     [System.NonSerialized]
     public GameObject playerGO1;
     private CarController_TB thePlayerScript;
     private CarController_TB focusPlayerScript;
     private ArrayList playerList;
  
 private ArrayList playerTransforms;
  
     private float aSpeed;
  
     public GUIText timerText;
     public GUIText posText;
  
  
 private bool isAhead;
     private CarController_TB car2;
     private int focusPlayerBattlePosition;
     public GameObject count3;
     public GameObject count2;
     public GameObject count1;
     public GUIText finalPositionText;
     public GameObject [] playerPrefabList;
     [System.NonSerialized]
     public static GameController_TB Instance;
  
  
 public Waypoints_Controller WaypointControllerForAI;",NA
13.5   Battle Controller,"The battle controller is 
 Tank Battle
 ’s equivalent to 
 Metal Vehicle Doom
 ’s race controller. It is 
 applied to all players to be tracked as members of the battle, and the global battle manager 
 will talk to these script components to keep an overall picture of the battle (managing the 
 score board, etc.). The full script looks like this:
 using UnityEngine;
 using System.Collections;
 public class BattleController : MonoBehavior
 {
     private bool isFinished;
  
 private Vector3 myPosition;
  
 private Transform myTransform;
  
 public int howmany_frags;
  
 public int howMany_fraggedOthers;
  
 public bool battleRunning;
  
 private bool doneInit;
  
  // we default myID to -1 so that we will know if the script hasn't 
 // finished initializing when another script tries to GetID
  
 private int myID =-1;
  
 public BattleController ()
  
 {
  
  
 myID= GlobalBattleManager.Instance.GetUniqueID( this );
  
  
 Debug.Log (""ID assigned is ""+myID);
  
 }
  
 public void Init()",NA
13.6   Global Battle Manager,"The battle controller script manages data for each player and registers itself with the global 
 battle manager as it instantiates. The global battle manager takes care of managing the 
 bigger picture, dealing with comparing players to calculate score board positions and 
 keeping tabs on the global race state.
 The GlobalBattleManager.cs script in full:
 using UnityEngine;
 using System.Collections;
 public class GlobalBattleManager : ScriptableObject
 {
  
 private int currentID;
  
  
 private Hashtable battleControllers;
  
 private Hashtable battlePositions;
  
 private Hashtable battleFinished;
  
 private Hashtable sortedPositions;
  
  
 private int numberOfBattlers;
  
  
 private int myPos;
  
 private bool isAhead;
  
 private BattleController tempRC;
  
 private BattleController focusPlayerScript;
  
 private bool battleRunning;
  
  
 private static GlobalBattleManager instance;
  
 public static GlobalBattleManager Instance
  
 {
  
  
 get
  
  
 {
  
  
  
 if (instance == null)
  
  
  
 {
  
  
  
  
  instance =  
  
  
 ScriptableObject.CreateInstance 
 <GlobalBattleManager>();
  
  
  
 }
  
  
  
 return instance;
  
  
 }
  
 }
  
 public void OnApplicationQuit ()
  
 {
  
  
 instance = null;
  
 }",NA
13.7   Players,"The CarController_TB.cs script is attached to all tanks. It derives from BaseVehicle and 
 bears more than a passing resemblance to the controller script from the example game 
 Metal Vehicle Doom
  in Chapter 12. The full player script looks like this:
 using UnityEngine;
 using System.Collections;
 public class CarController_TB : BaseVehicle
 {
  
  public BaseWeaponController weaponControl;  // note that we don't 
 // use the standard slot 
 // system here!
  
  
 public bool canFire;
  
 public bool isRespawning;
  
 public bool isAIControlled;
  
 public bool isInvulnerable;",NA
13.8   AI Chasing with SetAIChaseTargetBasedOnTag.cs,"The AI system is programmed to patrol and then chase a specific target object around.  The 
 tanks in this game require this behavior to be more dynamic, with some kind of target-
 finding system that can pick out targets for itself. The script SetAIChaseTargetBasedOnTag 
 acts as a component to be added to an AI object, which will use Unity’s tag system to find 
 all objects of a specified tag to check their distance and pick the nearest one as a target for 
 the AIController component to use.
 The script:
 using UnityEngine;
 using System.Collections;
 using AIStates;
 public class SetAIChaseTargetBasedOnTag : MonoBehavior
 {
  
 public BaseAIController AIControlComponent;
  
 public string defaultTagFilter= ""enemy"";
  
 public bool checkForWalls;
  
 public LayerMask raycastWallLayerMask;
  
 public float chaseDistance;
  
 private GameObject myGO;
  
 private Transform myTransform;
  
 private GameObject tempGO;
  
 private RaycastHit hit;
  
 private Vector3 tempDirVec;
  
 private bool foundTarget;
  
 public float visionHeightOffset= 1f;
  
 void Start ()
  
 {
  
  
  // first, let's try to get the AI control script 
  
 // automatically",NA
14,NA,NA
Dish: Making the ,NA,NA
Game ,NA,NA
Interstellar ,NA,NA
Paranoids,"In 1978, a game came along from a company named Taito that would change the face 
 of video gaming forever. Designer Tomohiro Nishikado said that his inspiration came 
 from Atari’s arcade game, 
 Breakout
 , and his concept was so advanced that Nishikado, 
 a solo developer, had to develop the necessary hardware himself. He named it 
 Space 
 Monsters
 , but a superior of his changed the name before it was released, to 
 Space 
 Invaders
 .
 By the end of 1978, Taito had installed over 100,000 arcade machines and grossed 
 over $600 million in Japan alone.* The game was soon a hit right across the world, and 
 now, 35 years on, players still get to enjoy numerous remakes, clones, and arcade-style 
 games that pay homage to 
 it
 .
 A year on, in 1979, a new video game named 
 Galaxian
  was launched by Namco. It was 
 designed by Kazunori Sawano; unlike Nishikado, Sawano had a small team to work with, 
 and they were able to accomplish much more technically that would help them to build 
 on the original 
 Space Invaders
  concepts. This time around, the enemy sprites had bright 
 colored graphics, animations, and a scrolling starfield. Audio was much improved now, 
 too, with the addition of background music and a theme. 
 Galaxian
  saw the alien invaders 
 swooping down at the player, attacking much more aggressively than 
 Space Invaders
 , mak-
 ing for a faster-paced, more visceral experience.
 * “Can Asteroids Conquer Space Invaders?” 
 Electronic Games
 , Winter 1981, 30–33 (http://www.digitpress . 
 com/library/magazines/electronic_games/electronic_games_winter81.pdf).",NA
14.1   Main Menu,"Interstellar Paranoids
  has a main menu scene and two game levels. The main menu is con-
 tained in a single scene that uses the scene manager component (as discussed in Chapter 4, 
 Section 4.10) to load the first game scene. From there, the scene manager is used to manage 
 level count and level loading.
 The main menu scene has a single camera named Main Camera. The main menu script 
 is attached to it as a component, rendering the menu and dealing with its interaction. This is 
 the same script that is used in all of the example games menu screens, but it is the only one 
 that adds a two-player mode and displays an extra button on the menu to start it.
 On the script component MainMenuController, when the string variable coopGame-
 StartScene has something in it (entered in through the Unity editor Inspector window), an 
 extra button is displayed on the menu with the label START CO-OP.
 The MainMenuController.cs script is outlined in full in Chapter 10 of this book, but 
 to add some context, here is the code that adds the extra button to the menu:
  
 if(coopGameStartScene!="""")
  
 {
  
  
 if(GUI.Button(new Rect(0, 250, 300, 40 ),""START CO-OP""))
  
  
 {
  
  
  
 PlayerPrefs.SetInt( ""totalPlayers"", 2 );
  
  
  
 LoadLevel( coopGameStartScene );
  
  
 }
 When the button is clicked, the totalPlayers prefs key is set to 2. The game will pick up 
 on this and add the extra player when it is required to. The game is loaded in the same way 
 as the single-player game, through the LoadLevel() function of the menu script.",NA
14.2   Game Scenes,"Each game level’s environment and enemy objects are contained in single scenes, although 
 some core game elements persist throughout the game such as the game controller, player, 
 and camera. This means that the game only needs to run its main setup functions once to 
 create the player and arrange the core elements. They persist until the game ends, when 
 they are destroyed before the main menu scene reloads.
 There are two levels in the example game, but they have the exact same Hierarchy 
 structure in both scenes. The Hierarchy contains
  
 ◾
 Directional light
  
 ◾
 Level
  
 ⦁
 Models that make up the environment—in this game, this is mostly instances 
 of attack pattern prefabs (containing waypoints and spawners for enemies)
  
 ◾
 LevelSetup
  
 ◾
 ScrollStopper
  
 ◾
 SoundController",NA
14.3   Prefabs,"The prefabs used for this game are
  
 ◾
 ENEMIES
  
 ⦁
 EnemyShip_1
  
 ⦁
 EnemyShip_2
  
 ⦁
 EnemyShip_3
  
 ⦁
 Gameboss",NA
Final Note,NA,NA
